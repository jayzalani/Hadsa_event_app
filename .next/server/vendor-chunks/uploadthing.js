"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uploadthing";
exports.ids = ["vendor-chunks/uploadthing"];
exports.modules = {

/***/ "(ssr)/./node_modules/uploadthing/client/index.js":
/*!**************************************************!*\
  !*** ./node_modules/uploadthing/client/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DANGEROUS__uploadFiles: () => (/* binding */ DANGEROUS__uploadFiles),\n/* harmony export */   INTERNAL_DO_NOT_USE__fatalClientError: () => (/* binding */ INTERNAL_DO_NOT_USE__fatalClientError),\n/* harmony export */   INTERNAL_doFormatting: () => (/* binding */ INTERNAL_doFormatting),\n/* harmony export */   allowedContentTextLabelGenerator: () => (/* binding */ allowedContentTextLabelGenerator),\n/* harmony export */   capitalizeStart: () => (/* binding */ capitalizeStart),\n/* harmony export */   contentFieldToContent: () => (/* binding */ contentFieldToContent),\n/* harmony export */   genUploader: () => (/* binding */ genUploader),\n/* harmony export */   generateClientDropzoneAccept: () => (/* binding */ generateClientDropzoneAccept),\n/* harmony export */   generateMimeTypes: () => (/* binding */ generateMimeTypes),\n/* harmony export */   generatePermittedFileTypes: () => (/* binding */ generatePermittedFileTypes),\n/* harmony export */   resolveMaybeUrlArg: () => (/* binding */ resolveMaybeUrlArg),\n/* harmony export */   styleFieldToClassName: () => (/* binding */ styleFieldToClassName),\n/* harmony export */   styleFieldToCssObject: () => (/* binding */ styleFieldToCssObject),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uploadthing/shared */ \"(ssr)/./node_modules/@uploadthing/shared/dist/index.js\");\n/* harmony import */ var std_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! std-env */ \"(ssr)/./node_modules/std-env/dist/index.mjs\");\n\n\nvar version$1 = \"6.5.0\";\n/*\n * Returns a full URL to the dev's uploadthing endpoint\n * Can take either an origin, or a pathname, or a full URL\n * and will return the \"closest\" url matching the default\n * `<VERCEL_URL || localhost>/api/uploadthing`\n */ function getFullApiUrl(maybeUrl) {\n    const base = (()=>{\n        if (false) {}\n        if (std_env__WEBPACK_IMPORTED_MODULE_1__.process.env?.VERCEL_URL) return `https://${std_env__WEBPACK_IMPORTED_MODULE_1__.process.env.VERCEL_URL}`;\n        return \"http://localhost:3000\";\n    })();\n    try {\n        const url = new URL(maybeUrl ?? \"/api/uploadthing\", base);\n        if (url.pathname === \"/\") {\n            url.pathname = \"/api/uploadthing\";\n        }\n        return url;\n    } catch (err) {\n        throw new Error(`Failed to parse '${maybeUrl}' as a URL. Make sure it's a valid URL or path`);\n    }\n}\nfunction resolveMaybeUrlArg(maybeUrl) {\n    return maybeUrl instanceof URL ? maybeUrl : getFullApiUrl(maybeUrl);\n}\nconst maybeParseResponseXML = (maybeXml)=>{\n    const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n    const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n    const code = codeMatch?.[1];\n    const message = messageMatch?.[1];\n    if (!code || !message) return null;\n    return {\n        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n        message\n    };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */ const DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n    AccessDenied: \"FORBIDDEN\",\n    EntityTooSmall: \"TOO_SMALL\",\n    EntityTooLarge: \"TOO_LARGE\",\n    ExpiredToken: \"FORBIDDEN\",\n    IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n    InternalError: \"INTERNAL_SERVER_ERROR\",\n    KeyTooLongError: \"KEY_TOO_LONG\",\n    MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\n/**\n * Used by client uploads where progress is needed.\n * Uses XMLHttpRequest.\n */ async function uploadPartWithProgress(opts, retryCount = 0) {\n    return new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"PUT\", opts.url, true);\n        xhr.setRequestHeader(\"Content-Type\", opts.fileType);\n        xhr.setRequestHeader(\"Content-Disposition\", (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.contentDisposition)(opts.contentDisposition, opts.fileName));\n        xhr.onload = async ()=>{\n            if (xhr.status >= 200 && xhr.status < 300) {\n                const etag = xhr.getResponseHeader(\"Etag\");\n                etag ? resolve(etag) : reject(\"NO ETAG\");\n            } else if (retryCount < opts.maxRetries) {\n                // Add a delay before retrying (exponential backoff can be used)\n                const delay = Math.pow(2, retryCount) * 1000;\n                await new Promise((res)=>setTimeout(res, delay));\n                await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n            } else {\n                reject(\"Max retries exceeded\");\n            }\n        };\n        let lastProgress = 0;\n        xhr.onerror = async ()=>{\n            lastProgress = 0;\n            if (retryCount < opts.maxRetries) {\n                // Add a delay before retrying (exponential backoff can be used)\n                const delay = Math.pow(2, retryCount) * 100;\n                await new Promise((res)=>setTimeout(res, delay));\n                await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n            } else {\n                reject(\"Max retries exceeded\");\n            }\n        };\n        xhr.upload.onprogress = (e)=>{\n            const delta = e.loaded - lastProgress;\n            lastProgress += delta;\n            opts.onProgress(delta);\n        };\n        xhr.send(opts.chunk);\n    });\n}\nconst createAPIRequestUrl = (config)=>{\n    const url = new URL(config.url);\n    const queryParams = new URLSearchParams(url.search);\n    queryParams.set(\"actionType\", config.actionType);\n    queryParams.set(\"slug\", config.slug);\n    url.search = queryParams.toString();\n    return url;\n};\n/**\n * Creates a \"client\" for reporting events to the UploadThing server via the user's API endpoint.\n * Events are handled in \"./handler.ts starting at L200\"\n */ const createUTReporter = (cfg)=>{\n    return async (type, payload)=>{\n        const url = createAPIRequestUrl({\n            url: cfg.url,\n            slug: cfg.endpoint,\n            actionType: type\n        });\n        const response = await cfg.fetch(url, {\n            method: \"POST\",\n            body: JSON.stringify(payload),\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"x-uploadthing-package\": cfg.package,\n                \"x-uploadthing-version\": version$1\n            }\n        });\n        switch(type){\n            case \"failure\":\n                {\n                    // why isn't this narrowed automatically?\n                    const p = payload;\n                    const parsed = maybeParseResponseXML(p.s3Error ?? \"\");\n                    if (parsed?.message) {\n                        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: parsed.code,\n                            message: parsed.message\n                        });\n                    } else {\n                        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"UPLOAD_FAILED\",\n                            message: `Failed to upload file ${p.fileName} to S3`,\n                            cause: p.s3Error\n                        });\n                    }\n                }\n        }\n        return response.ok;\n    };\n};\n/**\n * Shared helpers for our premade components that's reusable by multiple frameworks\n */ const generatePermittedFileTypes = (config)=>{\n    const fileTypes = config ? (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(config) : [];\n    const maxFileCount = config ? Object.values(config).map((v)=>v.maxFileCount) : [];\n    return {\n        fileTypes,\n        multiple: maxFileCount.some((v)=>v && v > 1)\n    };\n};\nconst capitalizeStart = (str)=>{\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nconst INTERNAL_doFormatting = (config)=>{\n    if (!config) return \"\";\n    const allowedTypes = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(config);\n    const formattedTypes = allowedTypes.map((f)=>f === \"blob\" ? \"file\" : f);\n    // Format multi-type uploader label as \"Supports videos, images and files\";\n    if (formattedTypes.length > 1) {\n        const lastType = formattedTypes.pop();\n        return `${formattedTypes.join(\"s, \")} and ${lastType}s`;\n    }\n    // Single type uploader label\n    const key = allowedTypes[0];\n    const formattedKey = formattedTypes[0];\n    const { maxFileSize, maxFileCount } = config[key];\n    if (maxFileCount && maxFileCount > 1) {\n        return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;\n    } else {\n        return `${formattedKey} (${maxFileSize})`;\n    }\n};\nconst allowedContentTextLabelGenerator = (config)=>{\n    return capitalizeStart(INTERNAL_doFormatting(config));\n};\nconst styleFieldToClassName = (styleField, args)=>{\n    if (typeof styleField === \"string\") return styleField;\n    if (typeof styleField === \"function\") {\n        const result = styleField(args);\n        if (typeof result === \"string\") return result;\n    }\n    return \"\";\n};\nconst styleFieldToCssObject = (styleField, args)=>{\n    if (typeof styleField === \"object\") return styleField;\n    if (typeof styleField === \"function\") {\n        const result = styleField(args);\n        if (typeof result === \"object\") return result;\n    }\n    return {};\n};\nconst contentFieldToContent = (contentField, arg)=>{\n    if (!contentField) return null;\n    if (typeof contentField !== \"function\") return contentField;\n    if (typeof contentField === \"function\") {\n        const result = contentField(arg);\n        return result;\n    }\n};\n// Don't want to ship our logger to the client, keep size down\nconst version = version$1;\nconst INTERNAL_DO_NOT_USE__fatalClientError = (e)=>new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n        code: \"INTERNAL_CLIENT_ERROR\",\n        message: \"Something went wrong. Please report this to UploadThing.\",\n        cause: e\n    });\nconst DANGEROUS__uploadFiles = async (endpoint, opts)=>{\n    // Fine to use global fetch in browser\n    const fetch = globalThis.fetch.bind(globalThis);\n    const reportEventToUT = createUTReporter({\n        endpoint: String(endpoint),\n        url: opts.url,\n        package: opts.package,\n        fetch\n    });\n    // Get presigned URL for S3 upload\n    const s3ConnectionRes = await fetch(createAPIRequestUrl({\n        url: opts.url,\n        slug: String(endpoint),\n        actionType: \"upload\"\n    }), {\n        method: \"POST\",\n        body: JSON.stringify({\n            input: \"input\" in opts ? opts.input : null,\n            files: opts.files.map((f)=>({\n                    name: f.name,\n                    size: f.size\n                }))\n        }),\n        // Express requires Content-Type to be explicitly set to parse body properly\n        headers: {\n            \"Content-Type\": \"application/json\",\n            \"x-uploadthing-package\": opts.package,\n            \"x-uploadthing-version\": version$1\n        }\n    }).then(async (res)=>{\n        // check for 200 response\n        if (!res.ok) {\n            const error = await _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.fromResponse(res);\n            throw error;\n        }\n        const jsonOrError = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(res);\n        if (jsonOrError instanceof Error) {\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: jsonOrError.message,\n                cause: res\n            });\n        }\n        return jsonOrError;\n    });\n    if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes)) {\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"No URL. How did you even get here?\",\n            cause: s3ConnectionRes\n        });\n    }\n    const fileUploadPromises = s3ConnectionRes.map(async (presigned)=>{\n        const file = opts.files.find((f)=>f.name === presigned.fileName);\n        if (!file) {\n            console.error(\"No file found for presigned URL\", presigned);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"NOT_FOUND\",\n                message: \"No file found for presigned URL\",\n                cause: `Expected file with name ${presigned.fileName} but got '${opts.files.join(\",\")}'`\n            });\n        }\n        opts.onUploadBegin?.({\n            file: file.name\n        });\n        if (\"urls\" in presigned) {\n            await uploadMultipart(file, presigned, {\n                reportEventToUT,\n                ...opts\n            });\n            // wait a bit as it's unsreasonable to expect the server to be done by now\n            await new Promise((r)=>setTimeout(r, 750));\n        } else {\n            await uploadPresignedPost(file, presigned, {\n                reportEventToUT,\n                ...opts\n            });\n        }\n        let serverData = null;\n        if (!opts.skipPolling) {\n            serverData = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.withExponentialBackoff)(async ()=>{\n                const res = await fetch(presigned.pollingUrl, {\n                    headers: {\n                        authorization: presigned.pollingJwt\n                    }\n                }).then((r)=>r.json());\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return res.status === \"done\" ? res.callbackData : undefined;\n            });\n        }\n        return {\n            name: file.name,\n            size: file.size,\n            key: presigned.key,\n            serverData,\n            url: \"https://utfs.io/f/\" + presigned.key\n        };\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return Promise.all(fileUploadPromises);\n};\nconst genUploader = (initOpts)=>{\n    const url = resolveMaybeUrlArg(initOpts?.url);\n    const utPkg = initOpts.package;\n    return (endpoint, opts)=>DANGEROUS__uploadFiles(endpoint, {\n            ...opts,\n            url,\n            package: utPkg\n        });\n};\nconst generateMimeTypes = (fileTypes)=>{\n    const accepted = fileTypes.map((type)=>{\n        if (type === \"blob\") return \"blob\";\n        if (type === \"pdf\") return \"application/pdf\";\n        if (type.includes(\"/\")) return type;\n        else return `${type}/*`;\n    });\n    if (accepted.includes(\"blob\")) {\n        return undefined;\n    }\n    return accepted;\n};\nconst generateClientDropzoneAccept = (fileTypes)=>{\n    const mimeTypes = generateMimeTypes(fileTypes);\n    if (!mimeTypes) return undefined;\n    return Object.fromEntries(mimeTypes.map((type)=>[\n            type,\n            []\n        ]));\n};\nasync function uploadMultipart(file, presigned, opts) {\n    let etags;\n    let uploadedBytes = 0;\n    try {\n        etags = await Promise.all(presigned.urls.map(async (url, index)=>{\n            const offset = presigned.chunkSize * index;\n            const end = Math.min(offset + presigned.chunkSize, file.size);\n            const chunk = file.slice(offset, end);\n            const etag = await uploadPartWithProgress({\n                url,\n                chunk: chunk,\n                contentDisposition: presigned.contentDisposition,\n                fileType: file.type,\n                fileName: file.name,\n                maxRetries: 10,\n                onProgress: (delta)=>{\n                    uploadedBytes += delta;\n                    const percent = uploadedBytes / file.size * 100;\n                    opts.onUploadProgress?.({\n                        file: file.name,\n                        progress: percent\n                    });\n                }\n            });\n            return {\n                tag: etag,\n                partNumber: index + 1\n            };\n        }));\n    } catch (error) {\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: presigned.uploadId,\n            fileName: file.name,\n            s3Error: error.toString()\n        });\n        throw \"unreachable\"; // failure event will throw for us\n    }\n    // Tell the server that the upload is complete\n    const uploadOk = await opts.reportEventToUT(\"multipart-complete\", {\n        uploadId: presigned.uploadId,\n        fileKey: presigned.key,\n        etags\n    });\n    if (!uploadOk) {\n        console.log(\"Failed to alert UT of upload completion\");\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: \"Failed to alert UT of upload completion\"\n        });\n    }\n}\nasync function uploadPresignedPost(file, presigned, opts) {\n    const formData = new FormData();\n    Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));\n    formData.append(\"file\", file); // File data **MUST GO LAST**\n    const response = await new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", presigned.url);\n        xhr.setRequestHeader(\"Accept\", \"application/xml\");\n        xhr.upload.onprogress = (p)=>{\n            opts.onUploadProgress?.({\n                file: file.name,\n                progress: p.loaded / p.total * 100\n            });\n        };\n        xhr.onload = (e)=>resolve(e.target);\n        xhr.onerror = (e)=>reject(e);\n        xhr.send(formData);\n    }).catch(async (error)=>{\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: null,\n            fileName: file.name,\n            s3Error: error.toString()\n        });\n        throw \"unreachable\"; // failure event will throw for us\n    });\n    if (response.status > 299 || response.status < 200) {\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: null,\n            fileName: file.name\n        });\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvY2xpZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEg7QUFDNUY7QUFFbEMsSUFBSU0sWUFBWTtBQUVoQjs7Ozs7Q0FLQyxHQUFHLFNBQVNDLGNBQWNDLFFBQVE7SUFDL0IsTUFBTUMsT0FBTyxDQUFDO1FBQ1YsSUFBSSxLQUE2QixFQUFFLEVBQThCO1FBQ2pFLElBQUlKLDRDQUFPQSxDQUFDUSxHQUFHLEVBQUVDLFlBQVksT0FBTyxDQUFDLFFBQVEsRUFBRVQsNENBQU9BLENBQUNRLEdBQUcsQ0FBQ0MsVUFBVSxDQUFDLENBQUM7UUFDdkUsT0FBTztJQUNYO0lBQ0EsSUFBSTtRQUNBLE1BQU1DLE1BQU0sSUFBSUMsSUFBSVIsWUFBWSxvQkFBb0JDO1FBQ3BELElBQUlNLElBQUlFLFFBQVEsS0FBSyxLQUFLO1lBQ3RCRixJQUFJRSxRQUFRLEdBQUc7UUFDbkI7UUFDQSxPQUFPRjtJQUNYLEVBQUUsT0FBT0csS0FBSztRQUNWLE1BQU0sSUFBSUMsTUFBTSxDQUFDLGlCQUFpQixFQUFFWCxTQUFTLDhDQUE4QyxDQUFDO0lBQ2hHO0FBQ0o7QUFDQSxTQUFTWSxtQkFBbUJaLFFBQVE7SUFDaEMsT0FBT0Esb0JBQW9CUSxNQUFNUixXQUFXRCxjQUFjQztBQUM5RDtBQUVBLE1BQU1hLHdCQUF3QixDQUFDQztJQUMzQixNQUFNQyxZQUFZRCxTQUFTRSxLQUFLLENBQUM7SUFDakMsTUFBTUMsZUFBZUgsU0FBU0UsS0FBSyxDQUFDO0lBQ3BDLE1BQU1FLE9BQU9ILFdBQVcsQ0FBQyxFQUFFO0lBQzNCLE1BQU1JLFVBQVVGLGNBQWMsQ0FBQyxFQUFFO0lBQ2pDLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxTQUFTLE9BQU87SUFDOUIsT0FBTztRQUNIRCxNQUFNRSx1QkFBdUIsQ0FBQ0YsS0FBSyxJQUFJRztRQUN2Q0Y7SUFDSjtBQUNKO0FBQ0E7Ozs7OztDQU1DLEdBQUcsTUFBTUUs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QUFDQyxTQUFTQztRQUN6QyxNQUFNQyxNQUFNLElBQUlDO1FBQ2hCRCxJQUFJRSxJQUFJLENBQUMsUUFBUXdHLFVBQVV2SSxHQUFHO1FBQzlCNkIsSUFBSUcsZ0JBQWdCLENBQUMsVUFBVTtRQUMvQkgsSUFBSWtCLE1BQU0sQ0FBQ0MsVUFBVSxHQUFHLENBQUM2QjtZQUNyQnJELEtBQUtrSixnQkFBZ0IsR0FBRztnQkFDcEJsQyxNQUFNQSxLQUFLVixJQUFJO2dCQUNmNkMsVUFBVTlGLEVBQUUxQixNQUFNLEdBQUcwQixFQUFFNEcsS0FBSyxHQUFHO1lBQ25DO1FBQ0o7UUFDQTVKLElBQUlNLE1BQU0sR0FBRyxDQUFDYyxJQUFJdEIsUUFBUXNCLEVBQUV5SSxNQUFNO1FBQ2xDN0osSUFBSWlCLE9BQU8sR0FBRyxDQUFDRyxJQUFJckIsT0FBT3FCO1FBQzFCcEIsSUFBSXdCLElBQUksQ0FBQzZIO0lBQ2IsR0FBR1MsS0FBSyxDQUFDLE9BQU8xRDtRQUNaLE1BQU16RyxLQUFLaUcsZUFBZSxDQUFDLFdBQVc7WUFDbENxRCxTQUFTdkMsVUFBVS9CLEdBQUc7WUFDdEJ1RSxVQUFVO1lBQ1Y3SSxVQUFVc0csS0FBS1YsSUFBSTtZQUNuQi9DLFNBQVNrRCxNQUFNbEUsUUFBUTtRQUMzQjtRQUNBLE1BQU0sZUFBZSxrQ0FBa0M7SUFDM0Q7SUFDQSxJQUFJTSxTQUFTakMsTUFBTSxHQUFHLE9BQU9pQyxTQUFTakMsTUFBTSxHQUFHLEtBQUs7UUFDaEQsTUFBTVosS0FBS2lHLGVBQWUsQ0FBQyxXQUFXO1lBQ2xDcUQsU0FBU3ZDLFVBQVUvQixHQUFHO1lBQ3RCdUUsVUFBVTtZQUNWN0ksVUFBVXNHLEtBQUtWLElBQUk7UUFDdkI7SUFDSjtBQUNKO0FBRStVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVybnByb2plY3QvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvY2xpZW50L2luZGV4LmpzPzZmNDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29udGVudERpc3Bvc2l0aW9uLCBVcGxvYWRUaGluZ0Vycm9yLCBvYmplY3RLZXlzLCBzYWZlUGFyc2VKU09OLCB3aXRoRXhwb25lbnRpYWxCYWNrb2ZmIH0gZnJvbSAnQHVwbG9hZHRoaW5nL3NoYXJlZCc7XG5pbXBvcnQgeyBwcm9jZXNzIH0gZnJvbSAnc3RkLWVudic7XG5cbnZhciB2ZXJzaW9uJDEgPSBcIjYuNS4wXCI7XG5cbi8qXG4gKiBSZXR1cm5zIGEgZnVsbCBVUkwgdG8gdGhlIGRldidzIHVwbG9hZHRoaW5nIGVuZHBvaW50XG4gKiBDYW4gdGFrZSBlaXRoZXIgYW4gb3JpZ2luLCBvciBhIHBhdGhuYW1lLCBvciBhIGZ1bGwgVVJMXG4gKiBhbmQgd2lsbCByZXR1cm4gdGhlIFwiY2xvc2VzdFwiIHVybCBtYXRjaGluZyB0aGUgZGVmYXVsdFxuICogYDxWRVJDRUxfVVJMIHx8IGxvY2FsaG9zdD4vYXBpL3VwbG9hZHRoaW5nYFxuICovIGZ1bmN0aW9uIGdldEZ1bGxBcGlVcmwobWF5YmVVcmwpIHtcbiAgICBjb25zdCBiYXNlID0gKCgpPT57XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Py5WRVJDRUxfVVJMKSByZXR1cm4gYGh0dHBzOi8vJHtwcm9jZXNzLmVudi5WRVJDRUxfVVJMfWA7XG4gICAgICAgIHJldHVybiBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiO1xuICAgIH0pKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChtYXliZVVybCA/PyBcIi9hcGkvdXBsb2FkdGhpbmdcIiwgYmFzZSk7XG4gICAgICAgIGlmICh1cmwucGF0aG5hbWUgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICB1cmwucGF0aG5hbWUgPSBcIi9hcGkvdXBsb2FkdGhpbmdcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSAnJHttYXliZVVybH0nIGFzIGEgVVJMLiBNYWtlIHN1cmUgaXQncyBhIHZhbGlkIFVSTCBvciBwYXRoYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZU1heWJlVXJsQXJnKG1heWJlVXJsKSB7XG4gICAgcmV0dXJuIG1heWJlVXJsIGluc3RhbmNlb2YgVVJMID8gbWF5YmVVcmwgOiBnZXRGdWxsQXBpVXJsKG1heWJlVXJsKTtcbn1cblxuY29uc3QgbWF5YmVQYXJzZVJlc3BvbnNlWE1MID0gKG1heWJlWG1sKT0+e1xuICAgIGNvbnN0IGNvZGVNYXRjaCA9IG1heWJlWG1sLm1hdGNoKC88Q29kZT4oLio/KTxcXC9Db2RlPi9zKTtcbiAgICBjb25zdCBtZXNzYWdlTWF0Y2ggPSBtYXliZVhtbC5tYXRjaCgvPE1lc3NhZ2U+KC4qPyk8XFwvTWVzc2FnZT4vcyk7XG4gICAgY29uc3QgY29kZSA9IGNvZGVNYXRjaD8uWzFdO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlTWF0Y2g/LlsxXTtcbiAgICBpZiAoIWNvZGUgfHwgIW1lc3NhZ2UpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHMzQ29kZVRvVXBsb2FkVGhpbmdDb2RlW2NvZGVdID8/IERFRkFVTFRfRVJST1JfQ09ERSxcbiAgICAgICAgbWVzc2FnZVxuICAgIH07XG59O1xuLyoqXG4gKiBNYXAgUzMgZXJyb3IgY29kZXMgdG8gVXBsb2FkVGhpbmcgZXJyb3IgY29kZXNcbiAqXG4gKiBUaGlzIGlzIGEgc3Vic2V0IG9mIHRoZSBTMyBlcnJvciBjb2RlcywgYmFzZWQgb24gd2hhdCBzZWVtZWQgbW9zdCBsaWtlbHkgdG9cbiAqIG9jY3VyIGluIHVwbG9hZHRoaW5nLiBGb3IgYSBmdWxsIGxpc3Qgb2YgUzMgZXJyb3IgY29kZXMsIHNlZTpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvQVBJL0Vycm9yUmVzcG9uc2VzLmh0bWxcbiAqLyBjb25zdCBERUZBVUxUX0VSUk9SX0NPREUgPSBcIlVQTE9BRF9GQUlMRURcIjtcbmNvbnN0IHMzQ29kZVRvVXBsb2FkVGhpbmdDb2RlID0ge1xuICAgIEFjY2Vzc0RlbmllZDogXCJGT1JCSURERU5cIixcbiAgICBFbnRpdHlUb29TbWFsbDogXCJUT09fU01BTExcIixcbiAgICBFbnRpdHlUb29MYXJnZTogXCJUT09fTEFSR0VcIixcbiAgICBFeHBpcmVkVG9rZW46IFwiRk9SQklEREVOXCIsXG4gICAgSW5jb3JyZWN0TnVtYmVyT2ZGaWxlc0luUG9zdFJlcXVlc3Q6IFwiVE9PX01BTllfRklMRVNcIixcbiAgICBJbnRlcm5hbEVycm9yOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuICAgIEtleVRvb0xvbmdFcnJvcjogXCJLRVlfVE9PX0xPTkdcIixcbiAgICBNYXhNZXNzYWdlTGVuZ3RoRXhjZWVkZWQ6IFwiVE9PX0xBUkdFXCJcbn07XG5cbi8qKlxuICogVXNlZCBieSBjbGllbnQgdXBsb2FkcyB3aGVyZSBwcm9ncmVzcyBpcyBuZWVkZWQuXG4gKiBVc2VzIFhNTEh0dHBSZXF1ZXN0LlxuICovIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZFBhcnRXaXRoUHJvZ3Jlc3Mob3B0cywgcmV0cnlDb3VudCA9IDApIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKFwiUFVUXCIsIG9wdHMudXJsLCB0cnVlKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgb3B0cy5maWxlVHlwZSk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1EaXNwb3NpdGlvblwiLCBjb250ZW50RGlzcG9zaXRpb24ob3B0cy5jb250ZW50RGlzcG9zaXRpb24sIG9wdHMuZmlsZU5hbWUpKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV0YWcgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJFdGFnXCIpO1xuICAgICAgICAgICAgICAgIGV0YWcgPyByZXNvbHZlKGV0YWcpIDogcmVqZWN0KFwiTk8gRVRBR1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0cnlDb3VudCA8IG9wdHMubWF4UmV0cmllcykge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIGRlbGF5IGJlZm9yZSByZXRyeWluZyAoZXhwb25lbnRpYWwgYmFja29mZiBjYW4gYmUgdXNlZClcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgucG93KDIsIHJldHJ5Q291bnQpICogMTAwMDtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKT0+c2V0VGltZW91dChyZXMsIGRlbGF5KSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXBsb2FkUGFydFdpdGhQcm9ncmVzcyhvcHRzLCByZXRyeUNvdW50ICsgMSk7IC8vIFJldHJ5IHRoZSByZXF1ZXN0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChcIk1heCByZXRyaWVzIGV4Y2VlZGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgbGFzdFByb2dyZXNzID0gMDtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgbGFzdFByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIGlmIChyZXRyeUNvdW50IDwgb3B0cy5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgZGVsYXkgYmVmb3JlIHJldHJ5aW5nIChleHBvbmVudGlhbCBiYWNrb2ZmIGNhbiBiZSB1c2VkKVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5wb3coMiwgcmV0cnlDb3VudCkgKiAxMDA7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcyk9PnNldFRpbWVvdXQocmVzLCBkZWxheSkpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZFBhcnRXaXRoUHJvZ3Jlc3Mob3B0cywgcmV0cnlDb3VudCArIDEpOyAvLyBSZXRyeSB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJNYXggcmV0cmllcyBleGNlZWRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gKGUpPT57XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGUubG9hZGVkIC0gbGFzdFByb2dyZXNzO1xuICAgICAgICAgICAgbGFzdFByb2dyZXNzICs9IGRlbHRhO1xuICAgICAgICAgICAgb3B0cy5vblByb2dyZXNzKGRlbHRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnNlbmQob3B0cy5jaHVuayk7XG4gICAgfSk7XG59XG5cbmNvbnN0IGNyZWF0ZUFQSVJlcXVlc3RVcmwgPSAoY29uZmlnKT0+e1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoY29uZmlnLnVybCk7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5zZWFyY2gpO1xuICAgIHF1ZXJ5UGFyYW1zLnNldChcImFjdGlvblR5cGVcIiwgY29uZmlnLmFjdGlvblR5cGUpO1xuICAgIHF1ZXJ5UGFyYW1zLnNldChcInNsdWdcIiwgY29uZmlnLnNsdWcpO1xuICAgIHVybC5zZWFyY2ggPSBxdWVyeVBhcmFtcy50b1N0cmluZygpO1xuICAgIHJldHVybiB1cmw7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgXCJjbGllbnRcIiBmb3IgcmVwb3J0aW5nIGV2ZW50cyB0byB0aGUgVXBsb2FkVGhpbmcgc2VydmVyIHZpYSB0aGUgdXNlcidzIEFQSSBlbmRwb2ludC5cbiAqIEV2ZW50cyBhcmUgaGFuZGxlZCBpbiBcIi4vaGFuZGxlci50cyBzdGFydGluZyBhdCBMMjAwXCJcbiAqLyBjb25zdCBjcmVhdGVVVFJlcG9ydGVyID0gKGNmZyk9PntcbiAgICByZXR1cm4gYXN5bmMgKHR5cGUsIHBheWxvYWQpPT57XG4gICAgICAgIGNvbnN0IHVybCA9IGNyZWF0ZUFQSVJlcXVlc3RVcmwoe1xuICAgICAgICAgICAgdXJsOiBjZmcudXJsLFxuICAgICAgICAgICAgc2x1ZzogY2ZnLmVuZHBvaW50LFxuICAgICAgICAgICAgYWN0aW9uVHlwZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjZmcuZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXBhY2thZ2VcIjogY2ZnLnBhY2thZ2UsXG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXZlcnNpb25cIjogdmVyc2lvbiQxXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2h5IGlzbid0IHRoaXMgbmFycm93ZWQgYXV0b21hdGljYWxseT9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IG1heWJlUGFyc2VSZXNwb25zZVhNTChwLnMzRXJyb3IgPz8gXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQ/Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBwYXJzZWQuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXJzZWQubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJVUExPQURfRkFJTEVEXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEZhaWxlZCB0byB1cGxvYWQgZmlsZSAke3AuZmlsZU5hbWV9IHRvIFMzYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogcC5zM0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2s7XG4gICAgfTtcbn07XG5cbi8qKlxuICogU2hhcmVkIGhlbHBlcnMgZm9yIG91ciBwcmVtYWRlIGNvbXBvbmVudHMgdGhhdCdzIHJldXNhYmxlIGJ5IG11bHRpcGxlIGZyYW1ld29ya3NcbiAqLyBjb25zdCBnZW5lcmF0ZVBlcm1pdHRlZEZpbGVUeXBlcyA9IChjb25maWcpPT57XG4gICAgY29uc3QgZmlsZVR5cGVzID0gY29uZmlnID8gb2JqZWN0S2V5cyhjb25maWcpIDogW107XG4gICAgY29uc3QgbWF4RmlsZUNvdW50ID0gY29uZmlnID8gT2JqZWN0LnZhbHVlcyhjb25maWcpLm1hcCgodik9PnYubWF4RmlsZUNvdW50KSA6IFtdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVUeXBlcyxcbiAgICAgICAgbXVsdGlwbGU6IG1heEZpbGVDb3VudC5zb21lKCh2KT0+diAmJiB2ID4gMSlcbiAgICB9O1xufTtcbmNvbnN0IGNhcGl0YWxpemVTdGFydCA9IChzdHIpPT57XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5jb25zdCBJTlRFUk5BTF9kb0Zvcm1hdHRpbmcgPSAoY29uZmlnKT0+e1xuICAgIGlmICghY29uZmlnKSByZXR1cm4gXCJcIjtcbiAgICBjb25zdCBhbGxvd2VkVHlwZXMgPSBvYmplY3RLZXlzKGNvbmZpZyk7XG4gICAgY29uc3QgZm9ybWF0dGVkVHlwZXMgPSBhbGxvd2VkVHlwZXMubWFwKChmKT0+ZiA9PT0gXCJibG9iXCIgPyBcImZpbGVcIiA6IGYpO1xuICAgIC8vIEZvcm1hdCBtdWx0aS10eXBlIHVwbG9hZGVyIGxhYmVsIGFzIFwiU3VwcG9ydHMgdmlkZW9zLCBpbWFnZXMgYW5kIGZpbGVzXCI7XG4gICAgaWYgKGZvcm1hdHRlZFR5cGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgbGFzdFR5cGUgPSBmb3JtYXR0ZWRUeXBlcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGAke2Zvcm1hdHRlZFR5cGVzLmpvaW4oXCJzLCBcIil9IGFuZCAke2xhc3RUeXBlfXNgO1xuICAgIH1cbiAgICAvLyBTaW5nbGUgdHlwZSB1cGxvYWRlciBsYWJlbFxuICAgIGNvbnN0IGtleSA9IGFsbG93ZWRUeXBlc1swXTtcbiAgICBjb25zdCBmb3JtYXR0ZWRLZXkgPSBmb3JtYXR0ZWRUeXBlc1swXTtcbiAgICBjb25zdCB7IG1heEZpbGVTaXplLCBtYXhGaWxlQ291bnQgfSA9IGNvbmZpZ1trZXldO1xuICAgIGlmIChtYXhGaWxlQ291bnQgJiYgbWF4RmlsZUNvdW50ID4gMSkge1xuICAgICAgICByZXR1cm4gYCR7Zm9ybWF0dGVkS2V5fXMgdXAgdG8gJHttYXhGaWxlU2l6ZX0sIG1heCAke21heEZpbGVDb3VudH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtmb3JtYXR0ZWRLZXl9ICgke21heEZpbGVTaXplfSlgO1xuICAgIH1cbn07XG5jb25zdCBhbGxvd2VkQ29udGVudFRleHRMYWJlbEdlbmVyYXRvciA9IChjb25maWcpPT57XG4gICAgcmV0dXJuIGNhcGl0YWxpemVTdGFydChJTlRFUk5BTF9kb0Zvcm1hdHRpbmcoY29uZmlnKSk7XG59O1xuY29uc3Qgc3R5bGVGaWVsZFRvQ2xhc3NOYW1lID0gKHN0eWxlRmllbGQsIGFyZ3MpPT57XG4gICAgaWYgKHR5cGVvZiBzdHlsZUZpZWxkID09PSBcInN0cmluZ1wiKSByZXR1cm4gc3R5bGVGaWVsZDtcbiAgICBpZiAodHlwZW9mIHN0eWxlRmllbGQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdHlsZUZpZWxkKGFyZ3MpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59O1xuY29uc3Qgc3R5bGVGaWVsZFRvQ3NzT2JqZWN0ID0gKHN0eWxlRmllbGQsIGFyZ3MpPT57XG4gICAgaWYgKHR5cGVvZiBzdHlsZUZpZWxkID09PSBcIm9iamVjdFwiKSByZXR1cm4gc3R5bGVGaWVsZDtcbiAgICBpZiAodHlwZW9mIHN0eWxlRmllbGQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdHlsZUZpZWxkKGFyZ3MpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIikgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufTtcbmNvbnN0IGNvbnRlbnRGaWVsZFRvQ29udGVudCA9IChjb250ZW50RmllbGQsIGFyZyk9PntcbiAgICBpZiAoIWNvbnRlbnRGaWVsZCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiBjb250ZW50RmllbGQgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbnRlbnRGaWVsZDtcbiAgICBpZiAodHlwZW9mIGNvbnRlbnRGaWVsZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbnRlbnRGaWVsZChhcmcpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbi8vIERvbid0IHdhbnQgdG8gc2hpcCBvdXIgbG9nZ2VyIHRvIHRoZSBjbGllbnQsIGtlZXAgc2l6ZSBkb3duXG5jb25zdCB2ZXJzaW9uID0gdmVyc2lvbiQxO1xuY29uc3QgSU5URVJOQUxfRE9fTk9UX1VTRV9fZmF0YWxDbGllbnRFcnJvciA9IChlKT0+bmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICBjb2RlOiBcIklOVEVSTkFMX0NMSUVOVF9FUlJPUlwiLFxuICAgICAgICBtZXNzYWdlOiBcIlNvbWV0aGluZyB3ZW50IHdyb25nLiBQbGVhc2UgcmVwb3J0IHRoaXMgdG8gVXBsb2FkVGhpbmcuXCIsXG4gICAgICAgIGNhdXNlOiBlXG4gICAgfSk7XG5jb25zdCBEQU5HRVJPVVNfX3VwbG9hZEZpbGVzID0gYXN5bmMgKGVuZHBvaW50LCBvcHRzKT0+e1xuICAgIC8vIEZpbmUgdG8gdXNlIGdsb2JhbCBmZXRjaCBpbiBicm93c2VyXG4gICAgY29uc3QgZmV0Y2ggPSBnbG9iYWxUaGlzLmZldGNoLmJpbmQoZ2xvYmFsVGhpcyk7XG4gICAgY29uc3QgcmVwb3J0RXZlbnRUb1VUID0gY3JlYXRlVVRSZXBvcnRlcih7XG4gICAgICAgIGVuZHBvaW50OiBTdHJpbmcoZW5kcG9pbnQpLFxuICAgICAgICB1cmw6IG9wdHMudXJsLFxuICAgICAgICBwYWNrYWdlOiBvcHRzLnBhY2thZ2UsXG4gICAgICAgIGZldGNoXG4gICAgfSk7XG4gICAgLy8gR2V0IHByZXNpZ25lZCBVUkwgZm9yIFMzIHVwbG9hZFxuICAgIGNvbnN0IHMzQ29ubmVjdGlvblJlcyA9IGF3YWl0IGZldGNoKGNyZWF0ZUFQSVJlcXVlc3RVcmwoe1xuICAgICAgICB1cmw6IG9wdHMudXJsLFxuICAgICAgICBzbHVnOiBTdHJpbmcoZW5kcG9pbnQpLFxuICAgICAgICBhY3Rpb25UeXBlOiBcInVwbG9hZFwiXG4gICAgfSksIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgaW5wdXQ6IFwiaW5wdXRcIiBpbiBvcHRzID8gb3B0cy5pbnB1dCA6IG51bGwsXG4gICAgICAgICAgICBmaWxlczogb3B0cy5maWxlcy5tYXAoKGYpPT4oe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGYuc2l6ZVxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICB9KSxcbiAgICAgICAgLy8gRXhwcmVzcyByZXF1aXJlcyBDb250ZW50LVR5cGUgdG8gYmUgZXhwbGljaXRseSBzZXQgdG8gcGFyc2UgYm9keSBwcm9wZXJseVxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1wYWNrYWdlXCI6IG9wdHMucGFja2FnZSxcbiAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCI6IHZlcnNpb24kMVxuICAgICAgICB9XG4gICAgfSkudGhlbihhc3luYyAocmVzKT0+e1xuICAgICAgICAvLyBjaGVjayBmb3IgMjAwIHJlc3BvbnNlXG4gICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IFVwbG9hZFRoaW5nRXJyb3IuZnJvbVJlc3BvbnNlKHJlcyk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqc29uT3JFcnJvciA9IGF3YWl0IHNhZmVQYXJzZUpTT04ocmVzKTtcbiAgICAgICAgaWYgKGpzb25PckVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZToganNvbk9yRXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBjYXVzZTogcmVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbk9yRXJyb3I7XG4gICAgfSk7XG4gICAgaWYgKCFzM0Nvbm5lY3Rpb25SZXMgfHwgIUFycmF5LmlzQXJyYXkoczNDb25uZWN0aW9uUmVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIk5vIFVSTC4gSG93IGRpZCB5b3UgZXZlbiBnZXQgaGVyZT9cIixcbiAgICAgICAgICAgIGNhdXNlOiBzM0Nvbm5lY3Rpb25SZXNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVVcGxvYWRQcm9taXNlcyA9IHMzQ29ubmVjdGlvblJlcy5tYXAoYXN5bmMgKHByZXNpZ25lZCk9PntcbiAgICAgICAgY29uc3QgZmlsZSA9IG9wdHMuZmlsZXMuZmluZCgoZik9PmYubmFtZSA9PT0gcHJlc2lnbmVkLmZpbGVOYW1lKTtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gZmlsZSBmb3VuZCBmb3IgcHJlc2lnbmVkIFVSTFwiLCBwcmVzaWduZWQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiTk9UX0ZPVU5EXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBmaWxlIGZvdW5kIGZvciBwcmVzaWduZWQgVVJMXCIsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGBFeHBlY3RlZCBmaWxlIHdpdGggbmFtZSAke3ByZXNpZ25lZC5maWxlTmFtZX0gYnV0IGdvdCAnJHtvcHRzLmZpbGVzLmpvaW4oXCIsXCIpfSdgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLm9uVXBsb2FkQmVnaW4/Lih7XG4gICAgICAgICAgICBmaWxlOiBmaWxlLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChcInVybHNcIiBpbiBwcmVzaWduZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHVwbG9hZE11bHRpcGFydChmaWxlLCBwcmVzaWduZWQsIHtcbiAgICAgICAgICAgICAgICByZXBvcnRFdmVudFRvVVQsXG4gICAgICAgICAgICAgICAgLi4ub3B0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3YWl0IGEgYml0IGFzIGl0J3MgdW5zcmVhc29uYWJsZSB0byBleHBlY3QgdGhlIHNlcnZlciB0byBiZSBkb25lIGJ5IG5vd1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHIpPT5zZXRUaW1lb3V0KHIsIDc1MCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdXBsb2FkUHJlc2lnbmVkUG9zdChmaWxlLCBwcmVzaWduZWQsIHtcbiAgICAgICAgICAgICAgICByZXBvcnRFdmVudFRvVVQsXG4gICAgICAgICAgICAgICAgLi4ub3B0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlcnZlckRhdGEgPSBudWxsO1xuICAgICAgICBpZiAoIW9wdHMuc2tpcFBvbGxpbmcpIHtcbiAgICAgICAgICAgIHNlcnZlckRhdGEgPSBhd2FpdCB3aXRoRXhwb25lbnRpYWxCYWNrb2ZmKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2gocHJlc2lnbmVkLnBvbGxpbmdVcmwsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbjogcHJlc2lnbmVkLnBvbGxpbmdKd3RcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKHIpPT5yLmpzb24oKSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMgPT09IFwiZG9uZVwiID8gcmVzLmNhbGxiYWNrRGF0YSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICBrZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICBzZXJ2ZXJEYXRhLFxuICAgICAgICAgICAgdXJsOiBcImh0dHBzOi8vdXRmcy5pby9mL1wiICsgcHJlc2lnbmVkLmtleVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgIHJldHVybiBQcm9taXNlLmFsbChmaWxlVXBsb2FkUHJvbWlzZXMpO1xufTtcbmNvbnN0IGdlblVwbG9hZGVyID0gKGluaXRPcHRzKT0+e1xuICAgIGNvbnN0IHVybCA9IHJlc29sdmVNYXliZVVybEFyZyhpbml0T3B0cz8udXJsKTtcbiAgICBjb25zdCB1dFBrZyA9IGluaXRPcHRzLnBhY2thZ2U7XG4gICAgcmV0dXJuIChlbmRwb2ludCwgb3B0cyk9Pi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgIERBTkdFUk9VU19fdXBsb2FkRmlsZXMoZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBwYWNrYWdlOiB1dFBrZ1xuICAgICAgICB9KTtcbn07XG5jb25zdCBnZW5lcmF0ZU1pbWVUeXBlcyA9IChmaWxlVHlwZXMpPT57XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBmaWxlVHlwZXMubWFwKCh0eXBlKT0+e1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJibG9iXCIpIHJldHVybiBcImJsb2JcIjtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwicGRmXCIpIHJldHVybiBcImFwcGxpY2F0aW9uL3BkZlwiO1xuICAgICAgICBpZiAodHlwZS5pbmNsdWRlcyhcIi9cIikpIHJldHVybiB0eXBlO1xuICAgICAgICBlbHNlIHJldHVybiBgJHt0eXBlfS8qYDtcbiAgICB9KTtcbiAgICBpZiAoYWNjZXB0ZWQuaW5jbHVkZXMoXCJibG9iXCIpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBhY2NlcHRlZDtcbn07XG5jb25zdCBnZW5lcmF0ZUNsaWVudERyb3B6b25lQWNjZXB0ID0gKGZpbGVUeXBlcyk9PntcbiAgICBjb25zdCBtaW1lVHlwZXMgPSBnZW5lcmF0ZU1pbWVUeXBlcyhmaWxlVHlwZXMpO1xuICAgIGlmICghbWltZVR5cGVzKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMobWltZVR5cGVzLm1hcCgodHlwZSk9PltcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBbXVxuICAgICAgICBdKSk7XG59O1xuYXN5bmMgZnVuY3Rpb24gdXBsb2FkTXVsdGlwYXJ0KGZpbGUsIHByZXNpZ25lZCwgb3B0cykge1xuICAgIGxldCBldGFncztcbiAgICBsZXQgdXBsb2FkZWRCeXRlcyA9IDA7XG4gICAgdHJ5IHtcbiAgICAgICAgZXRhZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChwcmVzaWduZWQudXJscy5tYXAoYXN5bmMgKHVybCwgaW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwcmVzaWduZWQuY2h1bmtTaXplICogaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihvZmZzZXQgKyBwcmVzaWduZWQuY2h1bmtTaXplLCBmaWxlLnNpemUpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBmaWxlLnNsaWNlKG9mZnNldCwgZW5kKTtcbiAgICAgICAgICAgIGNvbnN0IGV0YWcgPSBhd2FpdCB1cGxvYWRQYXJ0V2l0aFByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogcHJlc2lnbmVkLmNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBmaWxlVHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgbWF4UmV0cmllczogMTAsXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzczogKGRlbHRhKT0+e1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZEJ5dGVzICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50ID0gdXBsb2FkZWRCeXRlcyAvIGZpbGUuc2l6ZSAqIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5vblVwbG9hZFByb2dyZXNzPy4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHBlcmNlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhZzogZXRhZyxcbiAgICAgICAgICAgICAgICBwYXJ0TnVtYmVyOiBpbmRleCArIDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBhd2FpdCBvcHRzLnJlcG9ydEV2ZW50VG9VVChcImZhaWx1cmVcIiwge1xuICAgICAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHVwbG9hZElkOiBwcmVzaWduZWQudXBsb2FkSWQsXG4gICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgczNFcnJvcjogZXJyb3IudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgXCJ1bnJlYWNoYWJsZVwiOyAvLyBmYWlsdXJlIGV2ZW50IHdpbGwgdGhyb3cgZm9yIHVzXG4gICAgfVxuICAgIC8vIFRlbGwgdGhlIHNlcnZlciB0aGF0IHRoZSB1cGxvYWQgaXMgY29tcGxldGVcbiAgICBjb25zdCB1cGxvYWRPayA9IGF3YWl0IG9wdHMucmVwb3J0RXZlbnRUb1VUKFwibXVsdGlwYXJ0LWNvbXBsZXRlXCIsIHtcbiAgICAgICAgdXBsb2FkSWQ6IHByZXNpZ25lZC51cGxvYWRJZCxcbiAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgZXRhZ3NcbiAgICB9KTtcbiAgICBpZiAoIXVwbG9hZE9rKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIGFsZXJ0IFVUIG9mIHVwbG9hZCBjb21wbGV0aW9uXCIpO1xuICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIGFsZXJ0IFVUIG9mIHVwbG9hZCBjb21wbGV0aW9uXCJcbiAgICAgICAgfSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkUHJlc2lnbmVkUG9zdChmaWxlLCBwcmVzaWduZWQsIG9wdHMpIHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIE9iamVjdC5lbnRyaWVzKHByZXNpZ25lZC5maWVsZHMpLmZvckVhY2goKFtrLCB2XSk9PmZvcm1EYXRhLmFwcGVuZChrLCB2KSk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlKTsgLy8gRmlsZSBkYXRhICoqTVVTVCBHTyBMQVNUKipcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihcIlBPU1RcIiwgcHJlc2lnbmVkLnVybCk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24veG1sXCIpO1xuICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSAocCk9PntcbiAgICAgICAgICAgIG9wdHMub25VcGxvYWRQcm9ncmVzcz8uKHtcbiAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHAubG9hZGVkIC8gcC50b3RhbCAqIDEwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmxvYWQgPSAoZSk9PnJlc29sdmUoZS50YXJnZXQpO1xuICAgICAgICB4aHIub25lcnJvciA9IChlKT0+cmVqZWN0KGUpO1xuICAgICAgICB4aHIuc2VuZChmb3JtRGF0YSk7XG4gICAgfSkuY2F0Y2goYXN5bmMgKGVycm9yKT0+e1xuICAgICAgICBhd2FpdCBvcHRzLnJlcG9ydEV2ZW50VG9VVChcImZhaWx1cmVcIiwge1xuICAgICAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHVwbG9hZElkOiBudWxsLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIHMzRXJyb3I6IGVycm9yLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IFwidW5yZWFjaGFibGVcIjsgLy8gZmFpbHVyZSBldmVudCB3aWxsIHRocm93IGZvciB1c1xuICAgIH0pO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPiAyOTkgfHwgcmVzcG9uc2Uuc3RhdHVzIDwgMjAwKSB7XG4gICAgICAgIGF3YWl0IG9wdHMucmVwb3J0RXZlbnRUb1VUKFwiZmFpbHVyZVwiLCB7XG4gICAgICAgICAgICBmaWxlS2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgdXBsb2FkSWQ6IG51bGwsXG4gICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgREFOR0VST1VTX191cGxvYWRGaWxlcywgSU5URVJOQUxfRE9fTk9UX1VTRV9fZmF0YWxDbGllbnRFcnJvciwgSU5URVJOQUxfZG9Gb3JtYXR0aW5nLCBhbGxvd2VkQ29udGVudFRleHRMYWJlbEdlbmVyYXRvciwgY2FwaXRhbGl6ZVN0YXJ0LCBjb250ZW50RmllbGRUb0NvbnRlbnQsIGdlblVwbG9hZGVyLCBnZW5lcmF0ZUNsaWVudERyb3B6b25lQWNjZXB0LCBnZW5lcmF0ZU1pbWVUeXBlcywgZ2VuZXJhdGVQZXJtaXR0ZWRGaWxlVHlwZXMsIHJlc29sdmVNYXliZVVybEFyZywgc3R5bGVGaWVsZFRvQ2xhc3NOYW1lLCBzdHlsZUZpZWxkVG9Dc3NPYmplY3QsIHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6WyJjb250ZW50RGlzcG9zaXRpb24iLCJVcGxvYWRUaGluZ0Vycm9yIiwib2JqZWN0S2V5cyIsInNhZmVQYXJzZUpTT04iLCJ3aXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwicHJvY2VzcyIsInZlcnNpb24kMSIsImdldEZ1bGxBcGlVcmwiLCJtYXliZVVybCIsImJhc2UiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImVudiIsIlZFUkNFTF9VUkwiLCJ1cmwiLCJVUkwiLCJwYXRobmFtZSIsImVyciIsIkVycm9yIiwicmVzb2x2ZU1heWJlVXJsQXJnIiwibWF5YmVQYXJzZVJlc3BvbnNlWE1MIiwibWF5YmVYbWwiLCJjb2RlTWF0Y2giLCJtYXRjaCIsIm1lc3NhZ2VNYXRjaCIsImNvZGUiLCJtZXNzYWdlIiwiczNDb2RlVG9VcGxvYWRUaGluZ0NvZGUiLCJERUZBVUxUX0VSUk9SX0NPREUiLCJBY2Nlc3NEZW5pZWQiLCJFbnRpdHlUb29TbWFsbCIsIkVudGl0eVRvb0xhcmdlIiwiRXhwaXJlZFRva2VuIiwiSW5jb3JyZWN0TnVtYmVyT2ZGaWxlc0luUG9zdFJlcXVlc3QiLCJJbnRlcm5hbEVycm9yIiwiS2V5VG9vTG9uZ0Vycm9yIiwiTWF4TWVzc2FnZUxlbmd0aEV4Y2VlZGVkIiwidXBsb2FkUGFydFdpdGhQcm9ncmVzcyIsIm9wdHMiLCJyZXRyeUNvdW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwiZmlsZVR5cGUiLCJmaWxlTmFtZSIsIm9ubG9hZCIsInN0YXR1cyIsImV0YWciLCJnZXRSZXNwb25zZUhlYWRlciIsIm1heFJldHJpZXMiLCJkZWxheSIsIk1hdGgiLCJwb3ciLCJyZXMiLCJzZXRUaW1lb3V0IiwibGFzdFByb2dyZXNzIiwib25lcnJvciIsInVwbG9hZCIsIm9ucHJvZ3Jlc3MiLCJlIiwiZGVsdGEiLCJsb2FkZWQiLCJvblByb2dyZXNzIiwic2VuZCIsImNodW5rIiwiY3JlYXRlQVBJUmVxdWVzdFVybCIsImNvbmZpZyIsInF1ZXJ5UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwic2V0IiwiYWN0aW9uVHlwZSIsInNsdWciLCJ0b1N0cmluZyIsImNyZWF0ZVVUUmVwb3J0ZXIiLCJjZmciLCJ0eXBlIiwicGF5bG9hZCIsImVuZHBvaW50IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiaGVhZGVycyIsInBhY2thZ2UiLCJwIiwicGFyc2VkIiwiczNFcnJvciIsImNhdXNlIiwib2siLCJnZW5lcmF0ZVBlcm1pdHRlZEZpbGVUeXBlcyIsImZpbGVUeXBlcyIsIm1heEZpbGVDb3VudCIsIk9iamVjdCIsInZhbHVlcyIsIm1hcCIsInYiLCJtdWx0aXBsZSIsInNvbWUiLCJjYXBpdGFsaXplU3RhcnQiLCJzdHIiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiSU5URVJOQUxfZG9Gb3JtYXR0aW5nIiwiYWxsb3dlZFR5cGVzIiwiZm9ybWF0dGVkVHlwZXMiLCJmIiwibGVuZ3RoIiwibGFzdFR5cGUiLCJwb3AiLCJqb2luIiwia2V5IiwiZm9ybWF0dGVkS2V5IiwibWF4RmlsZVNpemUiLCJhbGxvd2VkQ29udGVudFRleHRMYWJlbEdlbmVyYXRvciIsInN0eWxlRmllbGRUb0NsYXNzTmFtZSIsInN0eWxlRmllbGQiLCJhcmdzIiwicmVzdWx0Iiwic3R5bGVGaWVsZFRvQ3NzT2JqZWN0IiwiY29udGVudEZpZWxkVG9Db250ZW50IiwiY29udGVudEZpZWxkIiwiYXJnIiwidmVyc2lvbiIsIklOVEVSTkFMX0RPX05PVF9VU0VfX2ZhdGFsQ2xpZW50RXJyb3IiLCJEQU5HRVJPVVNfX3VwbG9hZEZpbGVzIiwiZ2xvYmFsVGhpcyIsImJpbmQiLCJyZXBvcnRFdmVudFRvVVQiLCJTdHJpbmciLCJzM0Nvbm5lY3Rpb25SZXMiLCJpbnB1dCIsImZpbGVzIiwibmFtZSIsInNpemUiLCJ0aGVuIiwiZXJyb3IiLCJmcm9tUmVzcG9uc2UiLCJqc29uT3JFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImZpbGVVcGxvYWRQcm9taXNlcyIsInByZXNpZ25lZCIsImZpbGUiLCJmaW5kIiwiY29uc29sZSIsIm9uVXBsb2FkQmVnaW4iLCJ1cGxvYWRNdWx0aXBhcnQiLCJyIiwidXBsb2FkUHJlc2lnbmVkUG9zdCIsInNlcnZlckRhdGEiLCJza2lwUG9sbGluZyIsInBvbGxpbmdVcmwiLCJhdXRob3JpemF0aW9uIiwicG9sbGluZ0p3dCIsImpzb24iLCJjYWxsYmFja0RhdGEiLCJ1bmRlZmluZWQiLCJhbGwiLCJnZW5VcGxvYWRlciIsImluaXRPcHRzIiwidXRQa2ciLCJnZW5lcmF0ZU1pbWVUeXBlcyIsImFjY2VwdGVkIiwiaW5jbHVkZXMiLCJnZW5lcmF0ZUNsaWVudERyb3B6b25lQWNjZXB0IiwibWltZVR5cGVzIiwiZnJvbUVudHJpZXMiLCJldGFncyIsInVwbG9hZGVkQnl0ZXMiLCJ1cmxzIiwiaW5kZXgiLCJvZmZzZXQiLCJjaHVua1NpemUiLCJlbmQiLCJtaW4iLCJwZXJjZW50Iiwib25VcGxvYWRQcm9ncmVzcyIsInByb2dyZXNzIiwidGFnIiwicGFydE51bWJlciIsImZpbGVLZXkiLCJ1cGxvYWRJZCIsInVwbG9hZE9rIiwibG9nIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImVudHJpZXMiLCJmaWVsZHMiLCJmb3JFYWNoIiwiayIsImFwcGVuZCIsInRvdGFsIiwidGFyZ2V0IiwiY2F0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uploadthing/client/index.js\n");

/***/ })

};
;