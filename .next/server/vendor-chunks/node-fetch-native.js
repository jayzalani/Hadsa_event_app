"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-fetch-native";
exports.ids = ["vendor-chunks/node-fetch-native"];
exports.modules = {

/***/ "(ssr)/./node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs":
/*!*************************************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n__webpack_require__(/*! node:fs */ \"node:fs\");\n__webpack_require__(/*! node:path */ \"node:path\");\nconst abortController = __webpack_require__(/*! ../shared/node-fetch-native.8afd3fea.cjs */ \"(ssr)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs\");\n__webpack_require__(/*! node:http */ \"node:http\");\n__webpack_require__(/*! node:https */ \"node:https\");\n__webpack_require__(/*! node:zlib */ \"node:zlib\");\n__webpack_require__(/*! node:stream */ \"node:stream\");\n__webpack_require__(/*! node:buffer */ \"node:buffer\");\n__webpack_require__(/*! node:util */ \"node:util\");\n__webpack_require__(/*! node:url */ \"node:url\");\n__webpack_require__(/*! node:net */ \"node:net\");\nlet s = 0;\nconst S = {\n    START_BOUNDARY: s++,\n    HEADER_FIELD_START: s++,\n    HEADER_FIELD: s++,\n    HEADER_VALUE_START: s++,\n    HEADER_VALUE: s++,\n    HEADER_VALUE_ALMOST_DONE: s++,\n    HEADERS_ALMOST_DONE: s++,\n    PART_DATA_START: s++,\n    PART_DATA: s++,\n    END: s++\n};\nlet f = 1;\nconst F = {\n    PART_BOUNDARY: f,\n    LAST_BOUNDARY: f *= 2\n};\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\nconst lower = (c)=>c | 0x20;\nconst noop = ()=>{};\nclass MultipartParser {\n    /**\n\t * @param {string} boundary\n\t */ constructor(boundary){\n        this.index = 0;\n        this.flags = 0;\n        this.onHeaderEnd = noop;\n        this.onHeaderField = noop;\n        this.onHeadersEnd = noop;\n        this.onHeaderValue = noop;\n        this.onPartBegin = noop;\n        this.onPartData = noop;\n        this.onPartEnd = noop;\n        this.boundaryChars = {};\n        boundary = \"\\r\\n--\" + boundary;\n        const ui8a = new Uint8Array(boundary.length);\n        for(let i = 0; i < boundary.length; i++){\n            ui8a[i] = boundary.charCodeAt(i);\n            this.boundaryChars[ui8a[i]] = true;\n        }\n        this.boundary = ui8a;\n        this.lookbehind = new Uint8Array(this.boundary.length + 8);\n        this.state = S.START_BOUNDARY;\n    }\n    /**\n\t * @param {Uint8Array} data\n\t */ write(data) {\n        let i = 0;\n        const length_ = data.length;\n        let previousIndex = this.index;\n        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;\n        const boundaryLength = this.boundary.length;\n        const boundaryEnd = boundaryLength - 1;\n        const bufferLength = data.length;\n        let c;\n        let cl;\n        const mark = (name)=>{\n            this[name + \"Mark\"] = i;\n        };\n        const clear = (name)=>{\n            delete this[name + \"Mark\"];\n        };\n        const callback = (callbackSymbol, start, end, ui8a)=>{\n            if (start === undefined || start !== end) {\n                this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n            }\n        };\n        const dataCallback = (name, clear)=>{\n            const markSymbol = name + \"Mark\";\n            if (!(markSymbol in this)) {\n                return;\n            }\n            if (clear) {\n                callback(name, this[markSymbol], i, data);\n                delete this[markSymbol];\n            } else {\n                callback(name, this[markSymbol], data.length, data);\n                this[markSymbol] = 0;\n            }\n        };\n        for(i = 0; i < length_; i++){\n            c = data[i];\n            switch(state){\n                case S.START_BOUNDARY:\n                    if (index === boundary.length - 2) {\n                        if (c === HYPHEN) {\n                            flags |= F.LAST_BOUNDARY;\n                        } else if (c !== CR) {\n                            return;\n                        }\n                        index++;\n                        break;\n                    } else if (index - 1 === boundary.length - 2) {\n                        if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n                            state = S.END;\n                            flags = 0;\n                        } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n                            index = 0;\n                            callback(\"onPartBegin\");\n                            state = S.HEADER_FIELD_START;\n                        } else {\n                            return;\n                        }\n                        break;\n                    }\n                    if (c !== boundary[index + 2]) {\n                        index = -2;\n                    }\n                    if (c === boundary[index + 2]) {\n                        index++;\n                    }\n                    break;\n                case S.HEADER_FIELD_START:\n                    state = S.HEADER_FIELD;\n                    mark(\"onHeaderField\");\n                    index = 0;\n                // falls through\n                case S.HEADER_FIELD:\n                    if (c === CR) {\n                        clear(\"onHeaderField\");\n                        state = S.HEADERS_ALMOST_DONE;\n                        break;\n                    }\n                    index++;\n                    if (c === HYPHEN) {\n                        break;\n                    }\n                    if (c === COLON) {\n                        if (index === 1) {\n                            // empty header field\n                            return;\n                        }\n                        dataCallback(\"onHeaderField\", true);\n                        state = S.HEADER_VALUE_START;\n                        break;\n                    }\n                    cl = lower(c);\n                    if (cl < A || cl > Z) {\n                        return;\n                    }\n                    break;\n                case S.HEADER_VALUE_START:\n                    if (c === SPACE) {\n                        break;\n                    }\n                    mark(\"onHeaderValue\");\n                    state = S.HEADER_VALUE;\n                // falls through\n                case S.HEADER_VALUE:\n                    if (c === CR) {\n                        dataCallback(\"onHeaderValue\", true);\n                        callback(\"onHeaderEnd\");\n                        state = S.HEADER_VALUE_ALMOST_DONE;\n                    }\n                    break;\n                case S.HEADER_VALUE_ALMOST_DONE:\n                    if (c !== LF) {\n                        return;\n                    }\n                    state = S.HEADER_FIELD_START;\n                    break;\n                case S.HEADERS_ALMOST_DONE:\n                    if (c !== LF) {\n                        return;\n                    }\n                    callback(\"onHeadersEnd\");\n                    state = S.PART_DATA_START;\n                    break;\n                case S.PART_DATA_START:\n                    state = S.PART_DATA;\n                    mark(\"onPartData\");\n                // falls through\n                case S.PART_DATA:\n                    previousIndex = index;\n                    if (index === 0) {\n                        // boyer-moore derrived algorithm to safely skip non-boundary data\n                        i += boundaryEnd;\n                        while(i < bufferLength && !(data[i] in boundaryChars)){\n                            i += boundaryLength;\n                        }\n                        i -= boundaryEnd;\n                        c = data[i];\n                    }\n                    if (index < boundary.length) {\n                        if (boundary[index] === c) {\n                            if (index === 0) {\n                                dataCallback(\"onPartData\", true);\n                            }\n                            index++;\n                        } else {\n                            index = 0;\n                        }\n                    } else if (index === boundary.length) {\n                        index++;\n                        if (c === CR) {\n                            // CR = part boundary\n                            flags |= F.PART_BOUNDARY;\n                        } else if (c === HYPHEN) {\n                            // HYPHEN = end boundary\n                            flags |= F.LAST_BOUNDARY;\n                        } else {\n                            index = 0;\n                        }\n                    } else if (index - 1 === boundary.length) {\n                        if (flags & F.PART_BOUNDARY) {\n                            index = 0;\n                            if (c === LF) {\n                                // unset the PART_BOUNDARY flag\n                                flags &= ~F.PART_BOUNDARY;\n                                callback(\"onPartEnd\");\n                                callback(\"onPartBegin\");\n                                state = S.HEADER_FIELD_START;\n                                break;\n                            }\n                        } else if (flags & F.LAST_BOUNDARY) {\n                            if (c === HYPHEN) {\n                                callback(\"onPartEnd\");\n                                state = S.END;\n                                flags = 0;\n                            } else {\n                                index = 0;\n                            }\n                        } else {\n                            index = 0;\n                        }\n                    }\n                    if (index > 0) {\n                        // when matching a possible boundary, keep a lookbehind reference\n                        // in case it turns out to be a false lead\n                        lookbehind[index - 1] = c;\n                    } else if (previousIndex > 0) {\n                        // if our boundary turned out to be rubbish, the captured lookbehind\n                        // belongs to partData\n                        const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n                        callback(\"onPartData\", 0, previousIndex, _lookbehind);\n                        previousIndex = 0;\n                        mark(\"onPartData\");\n                        // reconsider the current character even so it interrupted the sequence\n                        // it could be the beginning of a new sequence\n                        i--;\n                    }\n                    break;\n                case S.END:\n                    break;\n                default:\n                    throw new Error(`Unexpected state entered: ${state}`);\n            }\n        }\n        dataCallback(\"onHeaderField\");\n        dataCallback(\"onHeaderValue\");\n        dataCallback(\"onPartData\");\n        // Update properties for the next call\n        this.index = index;\n        this.state = state;\n        this.flags = flags;\n    }\n    end() {\n        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n            this.onPartEnd();\n        } else if (this.state !== S.END) {\n            throw new Error(\"MultipartParser.end(): stream ended unexpectedly\");\n        }\n    }\n}\nfunction _fileName(headerValue) {\n    // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n    const m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n    if (!m) {\n        return;\n    }\n    const match = m[2] || m[3] || \"\";\n    let filename = match.slice(match.lastIndexOf(\"\\\\\") + 1);\n    filename = filename.replace(/%22/g, '\"');\n    filename = filename.replace(/&#(\\d{4});/g, (m, code)=>{\n        return String.fromCharCode(code);\n    });\n    return filename;\n}\nasync function toFormData(Body, ct) {\n    if (!/multipart/i.test(ct)) {\n        throw new TypeError(\"Failed to fetch\");\n    }\n    const m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n    if (!m) {\n        throw new TypeError(\"no or bad content-type header, no multipart boundary\");\n    }\n    const parser = new MultipartParser(m[1] || m[2]);\n    let headerField;\n    let headerValue;\n    let entryValue;\n    let entryName;\n    let contentType;\n    let filename;\n    const entryChunks = [];\n    const formData = new abortController.FormData();\n    const onPartData = (ui8a)=>{\n        entryValue += decoder.decode(ui8a, {\n            stream: true\n        });\n    };\n    const appendToFile = (ui8a)=>{\n        entryChunks.push(ui8a);\n    };\n    const appendFileToFormData = ()=>{\n        const file = new abortController.File(entryChunks, filename, {\n            type: contentType\n        });\n        formData.append(entryName, file);\n    };\n    const appendEntryToFormData = ()=>{\n        formData.append(entryName, entryValue);\n    };\n    const decoder = new TextDecoder(\"utf-8\");\n    decoder.decode();\n    parser.onPartBegin = function() {\n        parser.onPartData = onPartData;\n        parser.onPartEnd = appendEntryToFormData;\n        headerField = \"\";\n        headerValue = \"\";\n        entryValue = \"\";\n        entryName = \"\";\n        contentType = \"\";\n        filename = null;\n        entryChunks.length = 0;\n    };\n    parser.onHeaderField = function(ui8a) {\n        headerField += decoder.decode(ui8a, {\n            stream: true\n        });\n    };\n    parser.onHeaderValue = function(ui8a) {\n        headerValue += decoder.decode(ui8a, {\n            stream: true\n        });\n    };\n    parser.onHeaderEnd = function() {\n        headerValue += decoder.decode();\n        headerField = headerField.toLowerCase();\n        if (headerField === \"content-disposition\") {\n            // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n            const m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n            if (m) {\n                entryName = m[2] || m[3] || \"\";\n            }\n            filename = _fileName(headerValue);\n            if (filename) {\n                parser.onPartData = appendToFile;\n                parser.onPartEnd = appendFileToFormData;\n            }\n        } else if (headerField === \"content-type\") {\n            contentType = headerValue;\n        }\n        headerValue = \"\";\n        headerField = \"\";\n    };\n    for await (const chunk of Body){\n        parser.write(chunk);\n    }\n    parser.end();\n    return formData;\n}\nexports.toFormData = toFormData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9jaHVua3MvbXVsdGlwYXJ0LXBhcnNlci5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUixNQUFNQyxrQkFBa0JELG1CQUFPQSxDQUFDO0FBQ2hDQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLElBQUlFLElBQUk7QUFDUixNQUFNQyxJQUFJO0lBQ1RDLGdCQUFnQkY7SUFDaEJHLG9CQUFvQkg7SUFDcEJJLGNBQWNKO0lBQ2RLLG9CQUFvQkw7SUFDcEJNLGNBQWNOO0lBQ2RPLDBCQUEwQlA7SUFDMUJRLHFCQUFxQlI7SUFDckJTLGlCQUFpQlQ7SUFDakJVLFdBQVdWO0lBQ1hXLEtBQUtYO0FBQ047QUFFQSxJQUFJWSxJQUFJO0FBQ1IsTUFBTUMsSUFBSTtJQUNUQyxlQUFlRjtJQUNmRyxlQUFlSCxLQUFLO0FBQ3JCO0FBRUEsTUFBTUksS0FBSztBQUNYLE1BQU1DLEtBQUs7QUFDWCxNQUFNQyxRQUFRO0FBQ2QsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxJQUFJO0FBQ1YsTUFBTUMsSUFBSTtBQUVWLE1BQU1DLFFBQVFDLENBQUFBLElBQUtBLElBQUk7QUFFdkIsTUFBTUMsT0FBTyxLQUFPO0FBRXBCLE1BQU1DO0lBQ0w7O0VBRUMsR0FDREMsWUFBWUMsUUFBUSxDQUFFO1FBQ3JCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFFYixJQUFJLENBQUNDLFdBQVcsR0FBR047UUFDbkIsSUFBSSxDQUFDTyxhQUFhLEdBQUdQO1FBQ3JCLElBQUksQ0FB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UUFBUTtRQUFJO0lBQ2xEO0lBRUFWLE9BQU9wRCxhQUFhLEdBQUcsU0FBVUssSUFBSTtRQUNwQ2dDLGVBQWV1QixRQUFRQyxNQUFNLENBQUN4RCxNQUFNO1lBQUN5RCxRQUFRO1FBQUk7SUFDbEQ7SUFFQVYsT0FBT3ZELFdBQVcsR0FBRztRQUNwQndDLGVBQWV1QixRQUFRQyxNQUFNO1FBQzdCUixjQUFjQSxZQUFZbUIsV0FBVztRQUVyQyxJQUFJbkIsZ0JBQWdCLHVCQUF1QjtZQUMxQyxzRUFBc0U7WUFDdEUsTUFBTWYsSUFBSUQsWUFBWUUsS0FBSyxDQUFDO1lBRTVCLElBQUlELEdBQUc7Z0JBQ05pQixZQUFZakIsQ0FBQyxDQUFDLEVBQUUsSUFBSUEsQ0FBQyxDQUFDLEVBQUUsSUFBSTtZQUM3QjtZQUVBRSxXQUFXSixVQUFVQztZQUVyQixJQUFJRyxVQUFVO2dCQUNiWSxPQUFPbEQsVUFBVSxHQUFHNkQ7Z0JBQ3BCWCxPQUFPakQsU0FBUyxHQUFHOEQ7WUFDcEI7UUFDRCxPQUFPLElBQUlaLGdCQUFnQixnQkFBZ0I7WUFDMUNHLGNBQWNuQjtRQUNmO1FBRUFBLGNBQWM7UUFDZGdCLGNBQWM7SUFDZjtJQUVBLFdBQVcsTUFBTW9CLFNBQVN6QixLQUFNO1FBQy9CSSxPQUFPeEMsS0FBSyxDQUFDNkQ7SUFDZDtJQUVBckIsT0FBTzFCLEdBQUc7SUFFVixPQUFPZ0M7QUFDUjtBQUVBZ0Isa0JBQWtCLEdBQUczQiIsInNvdXJjZXMiOlsid2VicGFjazovL21lcm5wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gtbmF0aXZlL2Rpc3QvY2h1bmtzL211bHRpcGFydC1wYXJzZXIuY2pzPzRhZmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCdub2RlOmZzJyk7XG5yZXF1aXJlKCdub2RlOnBhdGgnKTtcbmNvbnN0IGFib3J0Q29udHJvbGxlciA9IHJlcXVpcmUoJy4uL3NoYXJlZC9ub2RlLWZldGNoLW5hdGl2ZS44YWZkM2ZlYS5janMnKTtcbnJlcXVpcmUoJ25vZGU6aHR0cCcpO1xucmVxdWlyZSgnbm9kZTpodHRwcycpO1xucmVxdWlyZSgnbm9kZTp6bGliJyk7XG5yZXF1aXJlKCdub2RlOnN0cmVhbScpO1xucmVxdWlyZSgnbm9kZTpidWZmZXInKTtcbnJlcXVpcmUoJ25vZGU6dXRpbCcpO1xucmVxdWlyZSgnbm9kZTp1cmwnKTtcbnJlcXVpcmUoJ25vZGU6bmV0Jyk7XG5cbmxldCBzID0gMDtcbmNvbnN0IFMgPSB7XG5cdFNUQVJUX0JPVU5EQVJZOiBzKyssXG5cdEhFQURFUl9GSUVMRF9TVEFSVDogcysrLFxuXHRIRUFERVJfRklFTEQ6IHMrKyxcblx0SEVBREVSX1ZBTFVFX1NUQVJUOiBzKyssXG5cdEhFQURFUl9WQUxVRTogcysrLFxuXHRIRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU6IHMrKyxcblx0SEVBREVSU19BTE1PU1RfRE9ORTogcysrLFxuXHRQQVJUX0RBVEFfU1RBUlQ6IHMrKyxcblx0UEFSVF9EQVRBOiBzKyssXG5cdEVORDogcysrXG59O1xuXG5sZXQgZiA9IDE7XG5jb25zdCBGID0ge1xuXHRQQVJUX0JPVU5EQVJZOiBmLFxuXHRMQVNUX0JPVU5EQVJZOiBmICo9IDJcbn07XG5cbmNvbnN0IExGID0gMTA7XG5jb25zdCBDUiA9IDEzO1xuY29uc3QgU1BBQ0UgPSAzMjtcbmNvbnN0IEhZUEhFTiA9IDQ1O1xuY29uc3QgQ09MT04gPSA1ODtcbmNvbnN0IEEgPSA5NztcbmNvbnN0IFogPSAxMjI7XG5cbmNvbnN0IGxvd2VyID0gYyA9PiBjIHwgMHgyMDtcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5jbGFzcyBNdWx0aXBhcnRQYXJzZXIge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kYXJ5XG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihib3VuZGFyeSkge1xuXHRcdHRoaXMuaW5kZXggPSAwO1xuXHRcdHRoaXMuZmxhZ3MgPSAwO1xuXG5cdFx0dGhpcy5vbkhlYWRlckVuZCA9IG5vb3A7XG5cdFx0dGhpcy5vbkhlYWRlckZpZWxkID0gbm9vcDtcblx0XHR0aGlzLm9uSGVhZGVyc0VuZCA9IG5vb3A7XG5cdFx0dGhpcy5vbkhlYWRlclZhbHVlID0gbm9vcDtcblx0XHR0aGlzLm9uUGFydEJlZ2luID0gbm9vcDtcblx0XHR0aGlzLm9uUGFydERhdGEgPSBub29wO1xuXHRcdHRoaXMub25QYXJ0RW5kID0gbm9vcDtcblxuXHRcdHRoaXMuYm91bmRhcnlDaGFycyA9IHt9O1xuXG5cdFx0Ym91bmRhcnkgPSAnXFxyXFxuLS0nICsgYm91bmRhcnk7XG5cdFx0Y29uc3QgdWk4YSA9IG5ldyBVaW50OEFycmF5KGJvdW5kYXJ5Lmxlbmd0aCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZGFyeS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dWk4YVtpXSA9IGJvdW5kYXJ5LmNoYXJDb2RlQXQoaSk7XG5cdFx0XHR0aGlzLmJvdW5kYXJ5Q2hhcnNbdWk4YVtpXV0gPSB0cnVlO1xuXHRcdH1cblxuXHRcdHRoaXMuYm91bmRhcnkgPSB1aThhO1xuXHRcdHRoaXMubG9va2JlaGluZCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYm91bmRhcnkubGVuZ3RoICsgOCk7XG5cdFx0dGhpcy5zdGF0ZSA9IFMuU1RBUlRfQk9VTkRBUlk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG5cdCAqL1xuXHR3cml0ZShkYXRhKSB7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGNvbnN0IGxlbmd0aF8gPSBkYXRhLmxlbmd0aDtcblx0XHRsZXQgcHJldmlvdXNJbmRleCA9IHRoaXMuaW5kZXg7XG5cdFx0bGV0IHtsb29rYmVoaW5kLCBib3VuZGFyeSwgYm91bmRhcnlDaGFycywgaW5kZXgsIHN0YXRlLCBmbGFnc30gPSB0aGlzO1xuXHRcdGNvbnN0IGJvdW5kYXJ5TGVuZ3RoID0gdGhpcy5ib3VuZGFyeS5sZW5ndGg7XG5cdFx0Y29uc3QgYm91bmRhcnlFbmQgPSBib3VuZGFyeUxlbmd0aCAtIDE7XG5cdFx0Y29uc3QgYnVmZmVyTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cdFx0bGV0IGM7XG5cdFx0bGV0IGNsO1xuXG5cdFx0Y29uc3QgbWFyayA9IG5hbWUgPT4ge1xuXHRcdFx0dGhpc1tuYW1lICsgJ01hcmsnXSA9IGk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IGNsZWFyID0gbmFtZSA9PiB7XG5cdFx0XHRkZWxldGUgdGhpc1tuYW1lICsgJ01hcmsnXTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgY2FsbGJhY2sgPSAoY2FsbGJhY2tTeW1ib2wsIHN0YXJ0LCBlbmQsIHVpOGEpID0+IHtcblx0XHRcdGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0ICE9PSBlbmQpIHtcblx0XHRcdFx0dGhpc1tjYWxsYmFja1N5bWJvbF0odWk4YSAmJiB1aThhLnN1YmFycmF5KHN0YXJ0LCBlbmQpKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3QgZGF0YUNhbGxiYWNrID0gKG5hbWUsIGNsZWFyKSA9PiB7XG5cdFx0XHRjb25zdCBtYXJrU3ltYm9sID0gbmFtZSArICdNYXJrJztcblx0XHRcdGlmICghKG1hcmtTeW1ib2wgaW4gdGhpcykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xlYXIpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmFtZSwgdGhpc1ttYXJrU3ltYm9sXSwgaSwgZGF0YSk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzW21hcmtTeW1ib2xdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sobmFtZSwgdGhpc1ttYXJrU3ltYm9sXSwgZGF0YS5sZW5ndGgsIGRhdGEpO1xuXHRcdFx0XHR0aGlzW21hcmtTeW1ib2xdID0gMDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aF87IGkrKykge1xuXHRcdFx0YyA9IGRhdGFbaV07XG5cblx0XHRcdHN3aXRjaCAoc3RhdGUpIHtcblx0XHRcdFx0Y2FzZSBTLlNUQVJUX0JPVU5EQVJZOlxuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gYm91bmRhcnkubGVuZ3RoIC0gMikge1xuXHRcdFx0XHRcdFx0aWYgKGMgPT09IEhZUEhFTikge1xuXHRcdFx0XHRcdFx0XHRmbGFncyB8PSBGLkxBU1RfQk9VTkRBUlk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgIT09IENSKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggLSAxID09PSBib3VuZGFyeS5sZW5ndGggLSAyKSB7XG5cdFx0XHRcdFx0XHRpZiAoZmxhZ3MgJiBGLkxBU1RfQk9VTkRBUlkgJiYgYyA9PT0gSFlQSEVOKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gUy5FTkQ7XG5cdFx0XHRcdFx0XHRcdGZsYWdzID0gMDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIShmbGFncyAmIEYuTEFTVF9CT1VOREFSWSkgJiYgYyA9PT0gTEYpIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjaygnb25QYXJ0QmVnaW4nKTtcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRF9TVEFSVDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMgIT09IGJvdW5kYXJ5W2luZGV4ICsgMl0pIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gLTI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMgPT09IGJvdW5kYXJ5W2luZGV4ICsgMl0pIHtcblx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5IRUFERVJfRklFTERfU1RBUlQ6XG5cdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRDtcblx0XHRcdFx0XHRtYXJrKCdvbkhlYWRlckZpZWxkJyk7XG5cdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdC8vIGZhbGxzIHRocm91Z2hcblx0XHRcdFx0Y2FzZSBTLkhFQURFUl9GSUVMRDpcblx0XHRcdFx0XHRpZiAoYyA9PT0gQ1IpIHtcblx0XHRcdFx0XHRcdGNsZWFyKCdvbkhlYWRlckZpZWxkJyk7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFMuSEVBREVSU19BTE1PU1RfRE9ORTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0aWYgKGMgPT09IEhZUEhFTikge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMgPT09IENPTE9OKSB7XG5cdFx0XHRcdFx0XHRpZiAoaW5kZXggPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0Ly8gZW1wdHkgaGVhZGVyIGZpZWxkXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlckZpZWxkJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFMuSEVBREVSX1ZBTFVFX1NUQVJUO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2wgPSBsb3dlcihjKTtcblx0XHRcdFx0XHRpZiAoY2wgPCBBIHx8IGNsID4gWikge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFMuSEVBREVSX1ZBTFVFX1NUQVJUOlxuXHRcdFx0XHRcdGlmIChjID09PSBTUEFDRSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWFyaygnb25IZWFkZXJWYWx1ZScpO1xuXHRcdFx0XHRcdHN0YXRlID0gUy5IRUFERVJfVkFMVUU7XG5cdFx0XHRcdFx0Ly8gZmFsbHMgdGhyb3VnaFxuXHRcdFx0XHRjYXNlIFMuSEVBREVSX1ZBTFVFOlxuXHRcdFx0XHRcdGlmIChjID09PSBDUikge1xuXHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlclZhbHVlJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygnb25IZWFkZXJFbmQnKTtcblx0XHRcdFx0XHRcdHN0YXRlID0gUy5IRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5IRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU6XG5cdFx0XHRcdFx0aWYgKGMgIT09IExGKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRF9TVEFSVDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBTLkhFQURFUlNfQUxNT1NUX0RPTkU6XG5cdFx0XHRcdFx0aWYgKGMgIT09IExGKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FsbGJhY2soJ29uSGVhZGVyc0VuZCcpO1xuXHRcdFx0XHRcdHN0YXRlID0gUy5QQVJUX0RBVEFfU1RBUlQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5QQVJUX0RBVEFfU1RBUlQ6XG5cdFx0XHRcdFx0c3RhdGUgPSBTLlBBUlRfREFUQTtcblx0XHRcdFx0XHRtYXJrKCdvblBhcnREYXRhJyk7XG5cdFx0XHRcdFx0Ly8gZmFsbHMgdGhyb3VnaFxuXHRcdFx0XHRjYXNlIFMuUEFSVF9EQVRBOlxuXHRcdFx0XHRcdHByZXZpb3VzSW5kZXggPSBpbmRleDtcblxuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Ly8gYm95ZXItbW9vcmUgZGVycml2ZWQgYWxnb3JpdGhtIHRvIHNhZmVseSBza2lwIG5vbi1ib3VuZGFyeSBkYXRhXG5cdFx0XHRcdFx0XHRpICs9IGJvdW5kYXJ5RW5kO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBidWZmZXJMZW5ndGggJiYgIShkYXRhW2ldIGluIGJvdW5kYXJ5Q2hhcnMpKSB7XG5cdFx0XHRcdFx0XHRcdGkgKz0gYm91bmRhcnlMZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGkgLT0gYm91bmRhcnlFbmQ7XG5cdFx0XHRcdFx0XHRjID0gZGF0YVtpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaW5kZXggPCBib3VuZGFyeS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmIChib3VuZGFyeVtpbmRleF0gPT09IGMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGluZGV4ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKCdvblBhcnREYXRhJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IGJvdW5kYXJ5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdGlmIChjID09PSBDUikge1xuXHRcdFx0XHRcdFx0XHQvLyBDUiA9IHBhcnQgYm91bmRhcnlcblx0XHRcdFx0XHRcdFx0ZmxhZ3MgfD0gRi5QQVJUX0JPVU5EQVJZO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBIWVBIRU4pIHtcblx0XHRcdFx0XHRcdFx0Ly8gSFlQSEVOID0gZW5kIGJvdW5kYXJ5XG5cdFx0XHRcdFx0XHRcdGZsYWdzIHw9IEYuTEFTVF9CT1VOREFSWTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGluZGV4IC0gMSA9PT0gYm91bmRhcnkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoZmxhZ3MgJiBGLlBBUlRfQk9VTkRBUlkpIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHRpZiAoYyA9PT0gTEYpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB1bnNldCB0aGUgUEFSVF9CT1VOREFSWSBmbGFnXG5cdFx0XHRcdFx0XHRcdFx0ZmxhZ3MgJj0gfkYuUEFSVF9CT1VOREFSWTtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjaygnb25QYXJ0RW5kJyk7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soJ29uUGFydEJlZ2luJyk7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRF9TVEFSVDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChmbGFncyAmIEYuTEFTVF9CT1VOREFSWSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYyA9PT0gSFlQSEVOKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soJ29uUGFydEVuZCcpO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlID0gUy5FTkQ7XG5cdFx0XHRcdFx0XHRcdFx0ZmxhZ3MgPSAwO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpbmRleCA+IDApIHtcblx0XHRcdFx0XHRcdC8vIHdoZW4gbWF0Y2hpbmcgYSBwb3NzaWJsZSBib3VuZGFyeSwga2VlcCBhIGxvb2tiZWhpbmQgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHQvLyBpbiBjYXNlIGl0IHR1cm5zIG91dCB0byBiZSBhIGZhbHNlIGxlYWRcblx0XHRcdFx0XHRcdGxvb2tiZWhpbmRbaW5kZXggLSAxXSA9IGM7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwcmV2aW91c0luZGV4ID4gMCkge1xuXHRcdFx0XHRcdFx0Ly8gaWYgb3VyIGJvdW5kYXJ5IHR1cm5lZCBvdXQgdG8gYmUgcnViYmlzaCwgdGhlIGNhcHR1cmVkIGxvb2tiZWhpbmRcblx0XHRcdFx0XHRcdC8vIGJlbG9uZ3MgdG8gcGFydERhdGFcblx0XHRcdFx0XHRcdGNvbnN0IF9sb29rYmVoaW5kID0gbmV3IFVpbnQ4QXJyYXkobG9va2JlaGluZC5idWZmZXIsIGxvb2tiZWhpbmQuYnl0ZU9mZnNldCwgbG9va2JlaGluZC5ieXRlTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCdvblBhcnREYXRhJywgMCwgcHJldmlvdXNJbmRleCwgX2xvb2tiZWhpbmQpO1xuXHRcdFx0XHRcdFx0cHJldmlvdXNJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRtYXJrKCdvblBhcnREYXRhJyk7XG5cblx0XHRcdFx0XHRcdC8vIHJlY29uc2lkZXIgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGV2ZW4gc28gaXQgaW50ZXJydXB0ZWQgdGhlIHNlcXVlbmNlXG5cdFx0XHRcdFx0XHQvLyBpdCBjb3VsZCBiZSB0aGUgYmVnaW5uaW5nIG9mIGEgbmV3IHNlcXVlbmNlXG5cdFx0XHRcdFx0XHRpLS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5FTkQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHN0YXRlIGVudGVyZWQ6ICR7c3RhdGV9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlckZpZWxkJyk7XG5cdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlclZhbHVlJyk7XG5cdFx0ZGF0YUNhbGxiYWNrKCdvblBhcnREYXRhJyk7XG5cblx0XHQvLyBVcGRhdGUgcHJvcGVydGllcyBmb3IgdGhlIG5leHQgY2FsbFxuXHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XG5cdFx0dGhpcy5mbGFncyA9IGZsYWdzO1xuXHR9XG5cblx0ZW5kKCkge1xuXHRcdGlmICgodGhpcy5zdGF0ZSA9PT0gUy5IRUFERVJfRklFTERfU1RBUlQgJiYgdGhpcy5pbmRleCA9PT0gMCkgfHxcblx0XHRcdCh0aGlzLnN0YXRlID09PSBTLlBBUlRfREFUQSAmJiB0aGlzLmluZGV4ID09PSB0aGlzLmJvdW5kYXJ5Lmxlbmd0aCkpIHtcblx0XHRcdHRoaXMub25QYXJ0RW5kKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN0YXRlICE9PSBTLkVORCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdWx0aXBhcnRQYXJzZXIuZW5kKCk6IHN0cmVhbSBlbmRlZCB1bmV4cGVjdGVkbHknKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gX2ZpbGVOYW1lKGhlYWRlclZhbHVlKSB7XG5cdC8vIG1hdGNoZXMgZWl0aGVyIGEgcXVvdGVkLXN0cmluZyBvciBhIHRva2VuIChSRkMgMjYxNiBzZWN0aW9uIDE5LjUuMSlcblx0Y29uc3QgbSA9IGhlYWRlclZhbHVlLm1hdGNoKC9cXGJmaWxlbmFtZT0oXCIoLio/KVwifChbXigpPD5ALDs6XFxcXFwiL1tcXF0/PXt9XFxzXFx0XSspKSgkfDtcXHMpL2kpO1xuXHRpZiAoIW0pIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBtYXRjaCA9IG1bMl0gfHwgbVszXSB8fCAnJztcblx0bGV0IGZpbGVuYW1lID0gbWF0Y2guc2xpY2UobWF0Y2gubGFzdEluZGV4T2YoJ1xcXFwnKSArIDEpO1xuXHRmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoLyUyMi9nLCAnXCInKTtcblx0ZmlsZW5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKC8mIyhcXGR7NH0pOy9nLCAobSwgY29kZSkgPT4ge1xuXHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXHR9KTtcblx0cmV0dXJuIGZpbGVuYW1lO1xufVxuXG5hc3luYyBmdW5jdGlvbiB0b0Zvcm1EYXRhKEJvZHksIGN0KSB7XG5cdGlmICghL211bHRpcGFydC9pLnRlc3QoY3QpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGZldGNoJyk7XG5cdH1cblxuXHRjb25zdCBtID0gY3QubWF0Y2goL2JvdW5kYXJ5PSg/OlwiKFteXCJdKylcInwoW147XSspKS9pKTtcblxuXHRpZiAoIW0pIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBvciBiYWQgY29udGVudC10eXBlIGhlYWRlciwgbm8gbXVsdGlwYXJ0IGJvdW5kYXJ5Jyk7XG5cdH1cblxuXHRjb25zdCBwYXJzZXIgPSBuZXcgTXVsdGlwYXJ0UGFyc2VyKG1bMV0gfHwgbVsyXSk7XG5cblx0bGV0IGhlYWRlckZpZWxkO1xuXHRsZXQgaGVhZGVyVmFsdWU7XG5cdGxldCBlbnRyeVZhbHVlO1xuXHRsZXQgZW50cnlOYW1lO1xuXHRsZXQgY29udGVudFR5cGU7XG5cdGxldCBmaWxlbmFtZTtcblx0Y29uc3QgZW50cnlDaHVua3MgPSBbXTtcblx0Y29uc3QgZm9ybURhdGEgPSBuZXcgYWJvcnRDb250cm9sbGVyLkZvcm1EYXRhKCk7XG5cblx0Y29uc3Qgb25QYXJ0RGF0YSA9IHVpOGEgPT4ge1xuXHRcdGVudHJ5VmFsdWUgKz0gZGVjb2Rlci5kZWNvZGUodWk4YSwge3N0cmVhbTogdHJ1ZX0pO1xuXHR9O1xuXG5cdGNvbnN0IGFwcGVuZFRvRmlsZSA9IHVpOGEgPT4ge1xuXHRcdGVudHJ5Q2h1bmtzLnB1c2godWk4YSk7XG5cdH07XG5cblx0Y29uc3QgYXBwZW5kRmlsZVRvRm9ybURhdGEgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZmlsZSA9IG5ldyBhYm9ydENvbnRyb2xsZXIuRmlsZShlbnRyeUNodW5rcywgZmlsZW5hbWUsIHt0eXBlOiBjb250ZW50VHlwZX0pO1xuXHRcdGZvcm1EYXRhLmFwcGVuZChlbnRyeU5hbWUsIGZpbGUpO1xuXHR9O1xuXG5cdGNvbnN0IGFwcGVuZEVudHJ5VG9Gb3JtRGF0YSA9ICgpID0+IHtcblx0XHRmb3JtRGF0YS5hcHBlbmQoZW50cnlOYW1lLCBlbnRyeVZhbHVlKTtcblx0fTtcblxuXHRjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuXHRkZWNvZGVyLmRlY29kZSgpO1xuXG5cdHBhcnNlci5vblBhcnRCZWdpbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRwYXJzZXIub25QYXJ0RGF0YSA9IG9uUGFydERhdGE7XG5cdFx0cGFyc2VyLm9uUGFydEVuZCA9IGFwcGVuZEVudHJ5VG9Gb3JtRGF0YTtcblxuXHRcdGhlYWRlckZpZWxkID0gJyc7XG5cdFx0aGVhZGVyVmFsdWUgPSAnJztcblx0XHRlbnRyeVZhbHVlID0gJyc7XG5cdFx0ZW50cnlOYW1lID0gJyc7XG5cdFx0Y29udGVudFR5cGUgPSAnJztcblx0XHRmaWxlbmFtZSA9IG51bGw7XG5cdFx0ZW50cnlDaHVua3MubGVuZ3RoID0gMDtcblx0fTtcblxuXHRwYXJzZXIub25IZWFkZXJGaWVsZCA9IGZ1bmN0aW9uICh1aThhKSB7XG5cdFx0aGVhZGVyRmllbGQgKz0gZGVjb2Rlci5kZWNvZGUodWk4YSwge3N0cmVhbTogdHJ1ZX0pO1xuXHR9O1xuXG5cdHBhcnNlci5vbkhlYWRlclZhbHVlID0gZnVuY3Rpb24gKHVpOGEpIHtcblx0XHRoZWFkZXJWYWx1ZSArPSBkZWNvZGVyLmRlY29kZSh1aThhLCB7c3RyZWFtOiB0cnVlfSk7XG5cdH07XG5cblx0cGFyc2VyLm9uSGVhZGVyRW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdGhlYWRlclZhbHVlICs9IGRlY29kZXIuZGVjb2RlKCk7XG5cdFx0aGVhZGVyRmllbGQgPSBoZWFkZXJGaWVsZC50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKGhlYWRlckZpZWxkID09PSAnY29udGVudC1kaXNwb3NpdGlvbicpIHtcblx0XHRcdC8vIG1hdGNoZXMgZWl0aGVyIGEgcXVvdGVkLXN0cmluZyBvciBhIHRva2VuIChSRkMgMjYxNiBzZWN0aW9uIDE5LjUuMSlcblx0XHRcdGNvbnN0IG0gPSBoZWFkZXJWYWx1ZS5tYXRjaCgvXFxibmFtZT0oXCIoW15cIl0qKVwifChbXigpPD5ALDs6XFxcXFwiL1tcXF0/PXt9XFxzXFx0XSspKS9pKTtcblxuXHRcdFx0aWYgKG0pIHtcblx0XHRcdFx0ZW50cnlOYW1lID0gbVsyXSB8fCBtWzNdIHx8ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHRmaWxlbmFtZSA9IF9maWxlTmFtZShoZWFkZXJWYWx1ZSk7XG5cblx0XHRcdGlmIChmaWxlbmFtZSkge1xuXHRcdFx0XHRwYXJzZXIub25QYXJ0RGF0YSA9IGFwcGVuZFRvRmlsZTtcblx0XHRcdFx0cGFyc2VyLm9uUGFydEVuZCA9IGFwcGVuZEZpbGVUb0Zvcm1EYXRhO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoaGVhZGVyRmllbGQgPT09ICdjb250ZW50LXR5cGUnKSB7XG5cdFx0XHRjb250ZW50VHlwZSA9IGhlYWRlclZhbHVlO1xuXHRcdH1cblxuXHRcdGhlYWRlclZhbHVlID0gJyc7XG5cdFx0aGVhZGVyRmllbGQgPSAnJztcblx0fTtcblxuXHRmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIEJvZHkpIHtcblx0XHRwYXJzZXIud3JpdGUoY2h1bmspO1xuXHR9XG5cblx0cGFyc2VyLmVuZCgpO1xuXG5cdHJldHVybiBmb3JtRGF0YTtcbn1cblxuZXhwb3J0cy50b0Zvcm1EYXRhID0gdG9Gb3JtRGF0YTtcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiYWJvcnRDb250cm9sbGVyIiwicyIsIlMiLCJTVEFSVF9CT1VOREFSWSIsIkhFQURFUl9GSUVMRF9TVEFSVCIsIkhFQURFUl9GSUVMRCIsIkhFQURFUl9WQUxVRV9TVEFSVCIsIkhFQURFUl9WQUxVRSIsIkhFQURFUl9WQUxVRV9BTE1PU1RfRE9ORSIsIkhFQURFUlNfQUxNT1NUX0RPTkUiLCJQQVJUX0RBVEFfU1RBUlQiLCJQQVJUX0RBVEEiLCJFTkQiLCJmIiwiRiIsIlBBUlRfQk9VTkRBUlkiLCJMQVNUX0JPVU5EQVJZIiwiTEYiLCJDUiIsIlNQQUNFIiwiSFlQSEVOIiwiQ09MT04iLCJBIiwiWiIsImxvd2VyIiwiYyIsIm5vb3AiLCJNdWx0aXBhcnRQYXJzZXIiLCJjb25zdHJ1Y3RvciIsImJvdW5kYXJ5IiwiaW5kZXgiLCJmbGFncyIsIm9uSGVhZGVyRW5kIiwib25IZWFkZXJGaWVsZCIsIm9uSGVhZGVyc0VuZCIsIm9uSGVhZGVyVmFsdWUiLCJvblBhcnRCZWdpbiIsIm9uUGFydERhdGEiLCJvblBhcnRFbmQiLCJib3VuZGFyeUNoYXJzIiwidWk4YSIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJpIiwiY2hhckNvZGVBdCIsImxvb2tiZWhpbmQiLCJzdGF0ZSIsIndyaXRlIiwiZGF0YSIsImxlbmd0aF8iLCJwcmV2aW91c0luZGV4IiwiYm91bmRhcnlMZW5ndGgiLCJib3VuZGFyeUVuZCIsImJ1ZmZlckxlbmd0aCIsImNsIiwibWFyayIsIm5hbWUiLCJjbGVhciIsImNhbGxiYWNrIiwiY2FsbGJhY2tTeW1ib2wiLCJzdGFydCIsImVuZCIsInVuZGVmaW5lZCIsInN1YmFycmF5IiwiZGF0YUNhbGxiYWNrIiwibWFya1N5bWJvbCIsIl9sb29rYmVoaW5kIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJFcnJvciIsIl9maWxlTmFtZSIsImhlYWRlclZhbHVlIiwibSIsIm1hdGNoIiwiZmlsZW5hbWUiLCJzbGljZSIsImxhc3RJbmRleE9mIiwicmVwbGFjZSIsImNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ0b0Zvcm1EYXRhIiwiQm9keSIsImN0IiwidGVzdCIsIlR5cGVFcnJvciIsInBhcnNlciIsImhlYWRlckZpZWxkIiwiZW50cnlWYWx1ZSIsImVudHJ5TmFtZSIsImNvbnRlbnRUeXBlIiwiZW50cnlDaHVua3MiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiZGVjb2RlciIsImRlY29kZSIsInN0cmVhbSIsImFwcGVuZFRvRmlsZSIsInB1c2giLCJhcHBlbmRGaWxlVG9Gb3JtRGF0YSIsImZpbGUiLCJGaWxlIiwidHlwZSIsImFwcGVuZCIsImFwcGVuZEVudHJ5VG9Gb3JtRGF0YSIsIlRleHREZWNvZGVyIiwidG9Mb3dlckNhc2UiLCJjaHVuayIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-fetch-native/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst abortController = __webpack_require__(/*! ./shared/node-fetch-native.8afd3fea.cjs */ \"(ssr)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs\");\nconst node_fs = __webpack_require__(/*! node:fs */ \"node:fs\");\nconst node_path = __webpack_require__(/*! node:path */ \"node:path\");\n__webpack_require__(/*! node:http */ \"node:http\");\n__webpack_require__(/*! node:https */ \"node:https\");\n__webpack_require__(/*! node:zlib */ \"node:zlib\");\n__webpack_require__(/*! node:stream */ \"node:stream\");\n__webpack_require__(/*! node:buffer */ \"node:buffer\");\n__webpack_require__(/*! node:util */ \"node:util\");\n__webpack_require__(/*! node:url */ \"node:url\");\n__webpack_require__(/*! node:net */ \"node:net\");\nconst { stat } = node_fs.promises;\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */ const blobFromSync = (path, type)=>fromBlob(node_fs.statSync(path), path, type);\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */ const blobFrom = (path, type)=>stat(path).then((stat)=>fromBlob(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */ const fileFrom = (path, type)=>stat(path).then((stat)=>fromFile(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */ const fileFromSync = (path, type)=>fromFile(node_fs.statSync(path), path, type);\n// @ts-ignore\nconst fromBlob = (stat, path, type = \"\")=>new abortController._Blob([\n        new BlobDataItem({\n            path,\n            size: stat.size,\n            lastModified: stat.mtimeMs,\n            start: 0\n        })\n    ], {\n        type\n    });\n// @ts-ignore\nconst fromFile = (stat, path, type = \"\")=>new abortController.File([\n        new BlobDataItem({\n            path,\n            size: stat.size,\n            lastModified: stat.mtimeMs,\n            start: 0\n        })\n    ], node_path.basename(path), {\n        type,\n        lastModified: stat.mtimeMs\n    });\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */ class BlobDataItem {\n    #path;\n    #start;\n    constructor(options){\n        this.#path = options.path;\n        this.#start = options.start;\n        this.size = options.size;\n        this.lastModified = options.lastModified;\n        this.originalSize = options.originalSize === undefined ? options.size : options.originalSize;\n    }\n    /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */ slice(start, end) {\n        return new BlobDataItem({\n            path: this.#path,\n            lastModified: this.lastModified,\n            originalSize: this.originalSize,\n            size: end - start,\n            start: this.#start + start\n        });\n    }\n    async *stream() {\n        const { mtimeMs, size } = await stat(this.#path);\n        if (mtimeMs > this.lastModified || this.originalSize !== size) {\n            throw new abortController.nodeDomexception(\"The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.\", \"NotReadableError\");\n        }\n        yield* node_fs.createReadStream(this.#path, {\n            start: this.#start,\n            end: this.#start + this.size - 1\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n}\nconst fetch = globalThis.fetch || abortController.fetch;\nconst Blob = globalThis.Blob || abortController._Blob;\nconst File = globalThis.File || abortController.File;\nconst FormData = globalThis.FormData || abortController.FormData;\nconst Headers = globalThis.Headers || abortController.Headers;\nconst Request = globalThis.Request || abortController.Request;\nconst Response = globalThis.Response || abortController.Response;\nconst AbortController = globalThis.AbortController || abortController.AbortController;\nexports.AbortError = abortController.AbortError;\nexports.FetchError = abortController.FetchError;\nexports.isRedirect = abortController.isRedirect;\nexports.AbortController = AbortController;\nexports.Blob = Blob;\nexports.File = File;\nexports.FormData = FormData;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports.blobFrom = blobFrom;\nexports.blobFromSync = blobFromSync;\nexports[\"default\"] = fetch;\nexports.fetch = fetch;\nexports.fileFrom = fileFrom;\nexports.fileFromSync = fileFromSync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsTUFBTUMsa0JBQWtCQyxtQkFBT0EsQ0FBQztBQUNoQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNRSxZQUFZRixtQkFBT0EsQ0FBQztBQUMxQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixNQUFNLEVBQUVHLElBQUksRUFBRSxHQUFHRixRQUFRRyxRQUFRO0FBRWpDOzs7Q0FHQyxHQUNELE1BQU1DLGVBQWUsQ0FBQ0MsTUFBTUMsT0FBU0MsU0FBU1AsUUFBUVEsUUFBUSxDQUFDSCxPQUFPQSxNQUFNQztBQUU1RTs7OztDQUlDLEdBQ0QsTUFBTUcsV0FBVyxDQUFDSixNQUFNQyxPQUFTSixLQUFLRyxNQUFNSyxJQUFJLENBQUNSLENBQUFBLE9BQVFLLFNBQVNMLE1BQU1HLE1BQU1DO0FBRTlFOzs7O0NBSUMsR0FDRCxNQUFNSyxXQUFXLENBQUNOLE1BQU1DLE9BQVNKLEtBQUtHLE1BQU1LLElBQUksQ0FBQ1IsQ0FBQUEsT0FBUVUsU0FBU1YsTUFBTUcsTUFBTUM7QUFFOUU7OztDQUdDLEdBQ0QsTUFBTU8sZUFBZSxDQUFDUixNQUFNQyxPQUFTTSxTQUFTWixRQUFRUSxRQUFRLENBQUNILE9BQU9BLE1BQU1DO0FBRTVFLGFBQWE7QUFDYixNQUFNQyxXQUFXLENBQUNMLE1BQU1HLE1BQU1DLE9BQU8sRUFBRSxHQUFLLElBQUlSLGdCQUFnQmdCLEtBQUssQ0FBQztRQUFDLElBQUlDLGFBQWE7WUFDdEZWO1lBQ0FXLE1BQU1kLEtB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QyxVQUFVO0FBQy9DL0MsdUJBQXVCLEdBQUc0QztBQUMxQjVDLFlBQVksR0FBR3VDO0FBQ2Z2QyxZQUFZLEdBQUd3QjtBQUNmeEIsZ0JBQWdCLEdBQUd3QztBQUNuQnhDLGVBQWUsR0FBR3lDO0FBQ2xCekMsZUFBZSxHQUFHMEM7QUFDbEIxQyxnQkFBZ0IsR0FBRzJDO0FBQ25CM0MsZ0JBQWdCLEdBQUdhO0FBQ25CYixvQkFBb0IsR0FBR1E7QUFDdkJSLGtCQUFlLEdBQUdxQztBQUNsQnJDLGFBQWEsR0FBR3FDO0FBQ2hCckMsZ0JBQWdCLEdBQUdlO0FBQ25CZixvQkFBb0IsR0FBR2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVybnByb2plY3QvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9pbmRleC5janM/ZDE5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IGFib3J0Q29udHJvbGxlciA9IHJlcXVpcmUoJy4vc2hhcmVkL25vZGUtZmV0Y2gtbmF0aXZlLjhhZmQzZmVhLmNqcycpO1xuY29uc3Qgbm9kZV9mcyA9IHJlcXVpcmUoJ25vZGU6ZnMnKTtcbmNvbnN0IG5vZGVfcGF0aCA9IHJlcXVpcmUoJ25vZGU6cGF0aCcpO1xucmVxdWlyZSgnbm9kZTpodHRwJyk7XG5yZXF1aXJlKCdub2RlOmh0dHBzJyk7XG5yZXF1aXJlKCdub2RlOnpsaWInKTtcbnJlcXVpcmUoJ25vZGU6c3RyZWFtJyk7XG5yZXF1aXJlKCdub2RlOmJ1ZmZlcicpO1xucmVxdWlyZSgnbm9kZTp1dGlsJyk7XG5yZXF1aXJlKCdub2RlOnVybCcpO1xucmVxdWlyZSgnbm9kZTpuZXQnKTtcblxuY29uc3QgeyBzdGF0IH0gPSBub2RlX2ZzLnByb21pc2VzO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGVwYXRoIG9uIHRoZSBkaXNrXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG1pbWV0eXBlIHRvIHVzZVxuICovXG5jb25zdCBibG9iRnJvbVN5bmMgPSAocGF0aCwgdHlwZSkgPT4gZnJvbUJsb2Iobm9kZV9mcy5zdGF0U3luYyhwYXRoKSwgcGF0aCwgdHlwZSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZmlsZXBhdGggb24gdGhlIGRpc2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gbWltZXR5cGUgdG8gdXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCbG9iPn1cbiAqL1xuY29uc3QgYmxvYkZyb20gPSAocGF0aCwgdHlwZSkgPT4gc3RhdChwYXRoKS50aGVuKHN0YXQgPT4gZnJvbUJsb2Ioc3RhdCwgcGF0aCwgdHlwZSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGVwYXRoIG9uIHRoZSBkaXNrXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG1pbWV0eXBlIHRvIHVzZVxuICogQHJldHVybnMge1Byb21pc2U8RmlsZT59XG4gKi9cbmNvbnN0IGZpbGVGcm9tID0gKHBhdGgsIHR5cGUpID0+IHN0YXQocGF0aCkudGhlbihzdGF0ID0+IGZyb21GaWxlKHN0YXQsIHBhdGgsIHR5cGUpKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlcGF0aCBvbiB0aGUgZGlza1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBtaW1ldHlwZSB0byB1c2VcbiAqL1xuY29uc3QgZmlsZUZyb21TeW5jID0gKHBhdGgsIHR5cGUpID0+IGZyb21GaWxlKG5vZGVfZnMuc3RhdFN5bmMocGF0aCksIHBhdGgsIHR5cGUpO1xuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBmcm9tQmxvYiA9IChzdGF0LCBwYXRoLCB0eXBlID0gJycpID0+IG5ldyBhYm9ydENvbnRyb2xsZXIuX0Jsb2IoW25ldyBCbG9iRGF0YUl0ZW0oe1xuICBwYXRoLFxuICBzaXplOiBzdGF0LnNpemUsXG4gIGxhc3RNb2RpZmllZDogc3RhdC5tdGltZU1zLFxuICBzdGFydDogMFxufSldLCB7IHR5cGUgfSk7XG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGZyb21GaWxlID0gKHN0YXQsIHBhdGgsIHR5cGUgPSAnJykgPT4gbmV3IGFib3J0Q29udHJvbGxlci5GaWxlKFtuZXcgQmxvYkRhdGFJdGVtKHtcbiAgcGF0aCxcbiAgc2l6ZTogc3RhdC5zaXplLFxuICBsYXN0TW9kaWZpZWQ6IHN0YXQubXRpbWVNcyxcbiAgc3RhcnQ6IDBcbn0pXSwgbm9kZV9wYXRoLmJhc2VuYW1lKHBhdGgpLCB7IHR5cGUsIGxhc3RNb2RpZmllZDogc3RhdC5tdGltZU1zIH0pO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBibG9iIGJhY2tlZCB1cCBieSBhIGZpbGUgb24gdGhlIGRpc2tcbiAqIHdpdGggbWluaXVtIHJlcXVpcmVtZW50LiBJdHMgd3JhcHBlZCBhcm91bmQgYSBCbG9iIGFzIGEgYmxvYlBhcnRcbiAqIHNvIHlvdSBoYXZlIG5vIGRpcmVjdCBhY2Nlc3MgdG8gdGhpcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBCbG9iRGF0YUl0ZW0ge1xuICAjcGF0aFxuICAjc3RhcnRcblxuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMuI3BhdGggPSBvcHRpb25zLnBhdGg7XG4gICAgdGhpcy4jc3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xuICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcbiAgICB0aGlzLmxhc3RNb2RpZmllZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkO1xuICAgIHRoaXMub3JpZ2luYWxTaXplID0gb3B0aW9ucy5vcmlnaW5hbFNpemUgPT09IHVuZGVmaW5lZFxuICAgICAgPyBvcHRpb25zLnNpemVcbiAgICAgIDogb3B0aW9ucy5vcmlnaW5hbFNpemU7XG4gIH1cblxuICAvKipcbiAgICogU2xpY2luZyBhcmd1bWVudHMgaXMgZmlyc3QgdmFsaWRhdGVkIGFuZCBmb3JtYXR0ZWRcbiAgICogdG8gbm90IGJlIG91dCBvZiByYW5nZSBieSBCbG9iLnByb3RvdHlwZS5zbGljZVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gbmV3IEJsb2JEYXRhSXRlbSh7XG4gICAgICBwYXRoOiB0aGlzLiNwYXRoLFxuICAgICAgbGFzdE1vZGlmaWVkOiB0aGlzLmxhc3RNb2RpZmllZCxcbiAgICAgIG9yaWdpbmFsU2l6ZTogdGhpcy5vcmlnaW5hbFNpemUsXG4gICAgICBzaXplOiBlbmQgLSBzdGFydCxcbiAgICAgIHN0YXJ0OiB0aGlzLiNzdGFydCArIHN0YXJ0XG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jICogc3RyZWFtICgpIHtcbiAgICBjb25zdCB7IG10aW1lTXMsIHNpemUgfSA9IGF3YWl0IHN0YXQodGhpcy4jcGF0aCk7XG5cbiAgICBpZiAobXRpbWVNcyA+IHRoaXMubGFzdE1vZGlmaWVkIHx8IHRoaXMub3JpZ2luYWxTaXplICE9PSBzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgYWJvcnRDb250cm9sbGVyLm5vZGVEb21leGNlcHRpb24oJ1RoZSByZXF1ZXN0ZWQgZmlsZSBjb3VsZCBub3QgYmUgcmVhZCwgdHlwaWNhbGx5IGR1ZSB0byBwZXJtaXNzaW9uIHByb2JsZW1zIHRoYXQgaGF2ZSBvY2N1cnJlZCBhZnRlciBhIHJlZmVyZW5jZSB0byBhIGZpbGUgd2FzIGFjcXVpcmVkLicsICdOb3RSZWFkYWJsZUVycm9yJylcbiAgICB9XG5cbiAgICB5aWVsZCAqIG5vZGVfZnMuY3JlYXRlUmVhZFN0cmVhbSh0aGlzLiNwYXRoLCB7XG4gICAgICBzdGFydDogdGhpcy4jc3RhcnQsXG4gICAgICBlbmQ6IHRoaXMuI3N0YXJ0ICsgdGhpcy5zaXplIC0gMVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICByZXR1cm4gJ0Jsb2InXG4gIH1cbn1cblxuY29uc3QgZmV0Y2ggPSBnbG9iYWxUaGlzLmZldGNoIHx8IGFib3J0Q29udHJvbGxlci5mZXRjaDtcbmNvbnN0IEJsb2IgPSBnbG9iYWxUaGlzLkJsb2IgfHwgYWJvcnRDb250cm9sbGVyLl9CbG9iO1xuY29uc3QgRmlsZSA9IGdsb2JhbFRoaXMuRmlsZSB8fCBhYm9ydENvbnRyb2xsZXIuRmlsZTtcbmNvbnN0IEZvcm1EYXRhID0gZ2xvYmFsVGhpcy5Gb3JtRGF0YSB8fCBhYm9ydENvbnRyb2xsZXIuRm9ybURhdGE7XG5jb25zdCBIZWFkZXJzID0gZ2xvYmFsVGhpcy5IZWFkZXJzIHx8IGFib3J0Q29udHJvbGxlci5IZWFkZXJzO1xuY29uc3QgUmVxdWVzdCA9IGdsb2JhbFRoaXMuUmVxdWVzdCB8fCBhYm9ydENvbnRyb2xsZXIuUmVxdWVzdDtcbmNvbnN0IFJlc3BvbnNlID0gZ2xvYmFsVGhpcy5SZXNwb25zZSB8fCBhYm9ydENvbnRyb2xsZXIuUmVzcG9uc2U7XG5jb25zdCBBYm9ydENvbnRyb2xsZXIgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlciB8fCBhYm9ydENvbnRyb2xsZXIuQWJvcnRDb250cm9sbGVyO1xuXG5leHBvcnRzLkFib3J0RXJyb3IgPSBhYm9ydENvbnRyb2xsZXIuQWJvcnRFcnJvcjtcbmV4cG9ydHMuRmV0Y2hFcnJvciA9IGFib3J0Q29udHJvbGxlci5GZXRjaEVycm9yO1xuZXhwb3J0cy5pc1JlZGlyZWN0ID0gYWJvcnRDb250cm9sbGVyLmlzUmVkaXJlY3Q7XG5leHBvcnRzLkFib3J0Q29udHJvbGxlciA9IEFib3J0Q29udHJvbGxlcjtcbmV4cG9ydHMuQmxvYiA9IEJsb2I7XG5leHBvcnRzLkZpbGUgPSBGaWxlO1xuZXhwb3J0cy5Gb3JtRGF0YSA9IEZvcm1EYXRhO1xuZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gUmVzcG9uc2U7XG5leHBvcnRzLmJsb2JGcm9tID0gYmxvYkZyb207XG5leHBvcnRzLmJsb2JGcm9tU3luYyA9IGJsb2JGcm9tU3luYztcbmV4cG9ydHMuZGVmYXVsdCA9IGZldGNoO1xuZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuZXhwb3J0cy5maWxlRnJvbSA9IGZpbGVGcm9tO1xuZXhwb3J0cy5maWxlRnJvbVN5bmMgPSBmaWxlRnJvbVN5bmM7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhYm9ydENvbnRyb2xsZXIiLCJyZXF1aXJlIiwibm9kZV9mcyIsIm5vZGVfcGF0aCIsInN0YXQiLCJwcm9taXNlcyIsImJsb2JGcm9tU3luYyIsInBhdGgiLCJ0eXBlIiwiZnJvbUJsb2IiLCJzdGF0U3luYyIsImJsb2JGcm9tIiwidGhlbiIsImZpbGVGcm9tIiwiZnJvbUZpbGUiLCJmaWxlRnJvbVN5bmMiLCJfQmxvYiIsIkJsb2JEYXRhSXRlbSIsInNpemUiLCJsYXN0TW9kaWZpZWQiLCJtdGltZU1zIiwic3RhcnQiLCJGaWxlIiwiYmFzZW5hbWUiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJvcmlnaW5hbFNpemUiLCJ1bmRlZmluZWQiLCJzbGljZSIsImVuZCIsInN0cmVhbSIsIm5vZGVEb21leGNlcHRpb24iLCJjcmVhdGVSZWFkU3RyZWFtIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJmZXRjaCIsImdsb2JhbFRoaXMiLCJCbG9iIiwiRm9ybURhdGEiLCJIZWFkZXJzIiwiUmVxdWVzdCIsIlJlc3BvbnNlIiwiQWJvcnRDb250cm9sbGVyIiwiQWJvcnRFcnJvciIsIkZldGNoRXJyb3IiLCJpc1JlZGlyZWN0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch-native/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(ssr)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst http = __webpack_require__(/*! node:http */ \"node:http\");\nconst https = __webpack_require__(/*! node:https */ \"node:https\");\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\");\nconst Stream = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst node_buffer = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst node_util = __webpack_require__(/*! node:util */ \"node:util\");\nconst node_url = __webpack_require__(/*! node:url */ \"node:url\");\nconst node_net = __webpack_require__(/*! node:net */ \"node:net\");\n__webpack_require__(/*! node:fs */ \"node:fs\");\n__webpack_require__(/*! node:path */ \"node:path\");\n/**\n * Returns a `Buffer` instance from the given data URI `uri`.\n *\n * @param {String} uri Data URI to turn into a Buffer instance\n * @returns {Buffer} Buffer instance from Data URI\n * @api public\n */ function dataUriToBuffer(uri) {\n    if (!/^data:/i.test(uri)) {\n        throw new TypeError('`uri` does not appear to be a Data URI (must begin with \"data:\")');\n    }\n    // strip newlines\n    uri = uri.replace(/\\r?\\n/g, \"\");\n    // split the URI up into the \"metadata\" and the \"data\" portions\n    const firstComma = uri.indexOf(\",\");\n    if (firstComma === -1 || firstComma <= 4) {\n        throw new TypeError(\"malformed data: URI\");\n    }\n    // remove the \"data:\" scheme and parse the metadata\n    const meta = uri.substring(5, firstComma).split(\";\");\n    let charset = \"\";\n    let base64 = false;\n    const type = meta[0] || \"text/plain\";\n    let typeFull = type;\n    for(let i = 1; i < meta.length; i++){\n        if (meta[i] === \"base64\") {\n            base64 = true;\n        } else {\n            typeFull += `;${meta[i]}`;\n            if (meta[i].indexOf(\"charset=\") === 0) {\n                charset = meta[i].substring(8);\n            }\n        }\n    }\n    // defaults to US-ASCII only if type is not provided\n    if (!meta[0] && !charset.length) {\n        typeFull += \";charset=US-ASCII\";\n        charset = \"US-ASCII\";\n    }\n    // get the encoded data portion and decode URI-encoded chars\n    const encoding = base64 ? \"base64\" : \"ascii\";\n    const data = unescape(uri.substring(firstComma + 1));\n    const buffer = Buffer.from(data, encoding);\n    // set `.type` and `.typeFull` properties to MIME type\n    buffer.type = type;\n    buffer.typeFull = typeFull;\n    // set the `.charset` property\n    buffer.charset = charset;\n    return buffer;\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar ponyfill_es2018 = {\n    exports: {}\n};\n/**\n * web-streams-polyfill v3.2.1\n */ var hasRequiredPonyfill_es2018;\nfunction requirePonyfill_es2018() {\n    if (hasRequiredPonyfill_es2018) return ponyfill_es2018.exports;\n    hasRequiredPonyfill_es2018 = 1;\n    (function(module, exports1) {\n        (function(global1, factory) {\n            factory(exports1);\n        })(commonjsGlobal, function(exports1) {\n            /// <reference lib=\"es2015.symbol\" />\n            const SymbolPolyfill = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? Symbol : (description)=>`Symbol(${description})`;\n            /// <reference lib=\"dom\" />\n            function noop() {\n                return undefined;\n            }\n            function getGlobals() {\n                if (typeof self !== \"undefined\") {\n                    return self;\n                } else if (false) {} else if (typeof commonjsGlobal !== \"undefined\") {\n                    return commonjsGlobal;\n                }\n                return undefined;\n            }\n            const globals = getGlobals();\n            function typeIsObject(x) {\n                return typeof x === \"object\" && x !== null || typeof x === \"function\";\n            }\n            const rethrowAssertionErrorRejection = noop;\n            const originalPromise = Promise;\n            const originalPromiseThen = Promise.prototype.then;\n            const originalPromiseResolve = Promise.resolve.bind(originalPromise);\n            const originalPromiseReject = Promise.reject.bind(originalPromise);\n            function newPromise(executor) {\n                return new originalPromise(executor);\n            }\n            function promiseResolvedWith(value1) {\n                return originalPromiseResolve(value1);\n            }\n            function promiseRejectedWith(reason) {\n                return originalPromiseReject(reason);\n            }\n            function PerformPromiseThen(promise, onFulfilled, onRejected) {\n                // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n                // approximation.\n                return originalPromiseThen.call(promise, onFulfilled, onRejected);\n            }\n            function uponPromise(promise, onFulfilled, onRejected) {\n                PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n            }\n            function uponFulfillment(promise, onFulfilled) {\n                uponPromise(promise, onFulfilled);\n            }\n            function uponRejection(promise, onRejected) {\n                uponPromise(promise, undefined, onRejected);\n            }\n            function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n                return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n            }\n            function setPromiseIsHandledToTrue(promise) {\n                PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n            }\n            const queueMicrotask = (()=>{\n                const globalQueueMicrotask = globals && globals.queueMicrotask;\n                if (typeof globalQueueMicrotask === \"function\") {\n                    return globalQueueMicrotask;\n                }\n                const resolvedPromise = promiseResolvedWith(undefined);\n                return (fn)=>PerformPromiseThen(resolvedPromise, fn);\n            })();\n            function reflectCall(F, V, args) {\n                if (typeof F !== \"function\") {\n                    throw new TypeError(\"Argument is not a function\");\n                }\n                return Function.prototype.apply.call(F, V, args);\n            }\n            function promiseCall(F, V, args) {\n                try {\n                    return promiseResolvedWith(reflectCall(F, V, args));\n                } catch (value1) {\n                    return promiseRejectedWith(value1);\n                }\n            }\n            // Original from Chromium\n            // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n            const QUEUE_MAX_ARRAY_SIZE = 16384;\n            /**\n\t\t     * Simple queue structure.\n\t\t     *\n\t\t     * Avoids scalability issues with using a packed array directly by using\n\t\t     * multiple arrays in a linked list and keeping the array size bounded.\n\t\t     */ class SimpleQueue {\n                constructor(){\n                    this._cursor = 0;\n                    this._size = 0;\n                    // _front and _back are always defined.\n                    this._front = {\n                        _elements: [],\n                        _next: undefined\n                    };\n                    this._back = this._front;\n                    // The cursor is used to avoid calling Array.shift().\n                    // It contains the index of the front element of the array inside the\n                    // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n                    this._cursor = 0;\n                    // When there is only one node, size === elements.length - cursor.\n                    this._size = 0;\n                }\n                get length() {\n                    return this._size;\n                }\n                // For exception safety, this method is structured in order:\n                // 1. Read state\n                // 2. Calculate required state mutations\n                // 3. Perform state mutations\n                push(element) {\n                    const oldBack = this._back;\n                    let newBack = oldBack;\n                    if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n                        newBack = {\n                            _elements: [],\n                            _next: undefined\n                        };\n                    }\n                    // push() is the mutation most likely to throw an exception, so it\n                    // goes first.\n                    oldBack._elements.push(element);\n                    if (newBack !== oldBack) {\n                        this._back = newBack;\n                        oldBack._next = newBack;\n                    }\n                    ++this._size;\n                }\n                // Like push(), shift() follows the read -> calculate -> mutate pattern for\n                // exception safety.\n                shift() {\n                    const oldFront = this._front;\n                    let newFront = oldFront;\n                    const oldCursor = this._cursor;\n                    let newCursor = oldCursor + 1;\n                    const elements = oldFront._elements;\n                    const element = elements[oldCursor];\n                    if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n                        newFront = oldFront._next;\n                        newCursor = 0;\n                    }\n                    // No mutations before this point.\n                    --this._size;\n                    this._cursor = newCursor;\n                    if (oldFront !== newFront) {\n                        this._front = newFront;\n                    }\n                    // Permit shifted element to be garbage collected.\n                    elements[oldCursor] = undefined;\n                    return element;\n                }\n                // The tricky thing about forEach() is that it can be called\n                // re-entrantly. The queue may be mutated inside the callback. It is easy to\n                // see that push() within the callback has no negative effects since the end\n                // of the queue is checked for on every iteration. If shift() is called\n                // repeatedly within the callback then the next iteration may return an\n                // element that has been removed. In this case the callback will be called\n                // with undefined values until we either \"catch up\" with elements that still\n                // exist or reach the back of the queue.\n                forEach(callback) {\n                    let i = this._cursor;\n                    let node = this._front;\n                    let elements = node._elements;\n                    while(i !== elements.length || node._next !== undefined){\n                        if (i === elements.length) {\n                            node = node._next;\n                            elements = node._elements;\n                            i = 0;\n                            if (elements.length === 0) {\n                                break;\n                            }\n                        }\n                        callback(elements[i]);\n                        ++i;\n                    }\n                }\n                // Return the element that would be returned if shift() was called now,\n                // without modifying the queue.\n                peek() {\n                    const front = this._front;\n                    const cursor = this._cursor;\n                    return front._elements[cursor];\n                }\n            }\n            function ReadableStreamReaderGenericInitialize(reader, stream) {\n                reader._ownerReadableStream = stream;\n                stream._reader = reader;\n                if (stream._state === \"readable\") {\n                    defaultReaderClosedPromiseInitialize(reader);\n                } else if (stream._state === \"closed\") {\n                    defaultReaderClosedPromiseInitializeAsResolved(reader);\n                } else {\n                    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n                }\n            }\n            // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n            // check.\n            function ReadableStreamReaderGenericCancel(reader, reason) {\n                const stream = reader._ownerReadableStream;\n                return ReadableStreamCancel(stream, reason);\n            }\n            function ReadableStreamReaderGenericRelease(reader) {\n                if (reader._ownerReadableStream._state === \"readable\") {\n                    defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n                } else {\n                    defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n                }\n                reader._ownerReadableStream._reader = undefined;\n                reader._ownerReadableStream = undefined;\n            }\n            // Helper functions for the readers.\n            function readerLockException(name) {\n                return new TypeError(\"Cannot \" + name + \" a stream using a released reader\");\n            }\n            // Helper functions for the ReadableStreamDefaultReader.\n            function defaultReaderClosedPromiseInitialize(reader) {\n                reader._closedPromise = newPromise((resolve, reject)=>{\n                    reader._closedPromise_resolve = resolve;\n                    reader._closedPromise_reject = reject;\n                });\n            }\n            function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n                defaultReaderClosedPromiseInitialize(reader);\n                defaultReaderClosedPromiseReject(reader, reason);\n            }\n            function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n                defaultReaderClosedPromiseInitialize(reader);\n                defaultReaderClosedPromiseResolve(reader);\n            }\n            function defaultReaderClosedPromiseReject(reader, reason) {\n                if (reader._closedPromise_reject === undefined) {\n                    return;\n                }\n                setPromiseIsHandledToTrue(reader._closedPromise);\n                reader._closedPromise_reject(reason);\n                reader._closedPromise_resolve = undefined;\n                reader._closedPromise_reject = undefined;\n            }\n            function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n                defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n            }\n            function defaultReaderClosedPromiseResolve(reader) {\n                if (reader._closedPromise_resolve === undefined) {\n                    return;\n                }\n                reader._closedPromise_resolve(undefined);\n                reader._closedPromise_resolve = undefined;\n                reader._closedPromise_reject = undefined;\n            }\n            const AbortSteps = SymbolPolyfill(\"[[AbortSteps]]\");\n            const ErrorSteps = SymbolPolyfill(\"[[ErrorSteps]]\");\n            const CancelSteps = SymbolPolyfill(\"[[CancelSteps]]\");\n            const PullSteps = SymbolPolyfill(\"[[PullSteps]]\");\n            /// <reference lib=\"es2015.core\" />\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\n            const NumberIsFinite = Number.isFinite || function(x) {\n                return typeof x === \"number\" && isFinite(x);\n            };\n            /// <reference lib=\"es2015.core\" />\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\n            const MathTrunc = Math.trunc || function(v) {\n                return v < 0 ? Math.ceil(v) : Math.floor(v);\n            };\n            // https://heycam.github.io/webidl/#idl-dictionaries\n            function isDictionary(x) {\n                return typeof x === \"object\" || typeof x === \"function\";\n            }\n            function assertDictionary(obj, context) {\n                if (obj !== undefined && !isDictionary(obj)) {\n                    throw new TypeError(`${context} is not an object.`);\n                }\n            }\n            // https://heycam.github.io/webidl/#idl-callback-functions\n            function assertFunction(x, context) {\n                if (typeof x !== \"function\") {\n                    throw new TypeError(`${context} is not a function.`);\n                }\n            }\n            // https://heycam.github.io/webidl/#idl-object\n            function isObject(x) {\n                return typeof x === \"object\" && x !== null || typeof x === \"function\";\n            }\n            function assertObject(x, context) {\n                if (!isObject(x)) {\n                    throw new TypeError(`${context} is not an object.`);\n                }\n            }\n            function assertRequiredArgument(x, position, context) {\n                if (x === undefined) {\n                    throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n                }\n            }\n            function assertRequiredField(x, field, context) {\n                if (x === undefined) {\n                    throw new TypeError(`${field} is required in '${context}'.`);\n                }\n            }\n            // https://heycam.github.io/webidl/#idl-unrestricted-double\n            function convertUnrestrictedDouble(value1) {\n                return Number(value1);\n            }\n            function censorNegativeZero(x) {\n                return x === 0 ? 0 : x;\n            }\n            function integerPart(x) {\n                return censorNegativeZero(MathTrunc(x));\n            }\n            // https://heycam.github.io/webidl/#idl-unsigned-long-long\n            function convertUnsignedLongLongWithEnforceRange(value1, context) {\n                const lowerBound = 0;\n                const upperBound = Number.MAX_SAFE_INTEGER;\n                let x = Number(value1);\n                x = censorNegativeZero(x);\n                if (!NumberIsFinite(x)) {\n                    throw new TypeError(`${context} is not a finite number`);\n                }\n                x = integerPart(x);\n                if (x < lowerBound || x > upperBound) {\n                    throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n                }\n                if (!NumberIsFinite(x) || x === 0) {\n                    return 0;\n                }\n                // TODO Use BigInt if supported?\n                // let xBigInt = BigInt(integerPart(x));\n                // xBigInt = BigInt.asUintN(64, xBigInt);\n                // return Number(xBigInt);\n                return x;\n            }\n            function assertReadableStream(x, context) {\n                if (!IsReadableStream(x)) {\n                    throw new TypeError(`${context} is not a ReadableStream.`);\n                }\n            }\n            // Abstract operations for the ReadableStream.\n            function AcquireReadableStreamDefaultReader(stream) {\n                return new ReadableStreamDefaultReader(stream);\n            }\n            // ReadableStream API exposed for controllers.\n            function ReadableStreamAddReadRequest(stream, readRequest) {\n                stream._reader._readRequests.push(readRequest);\n            }\n            function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n                const reader = stream._reader;\n                const readRequest = reader._readRequests.shift();\n                if (done) {\n                    readRequest._closeSteps();\n                } else {\n                    readRequest._chunkSteps(chunk);\n                }\n            }\n            function ReadableStreamGetNumReadRequests(stream) {\n                return stream._reader._readRequests.length;\n            }\n            function ReadableStreamHasDefaultReader(stream) {\n                const reader = stream._reader;\n                if (reader === undefined) {\n                    return false;\n                }\n                if (!IsReadableStreamDefaultReader(reader)) {\n                    return false;\n                }\n                return true;\n            }\n            /**\n\t\t     * A default reader vended by a {@link ReadableStream}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStreamDefaultReader {\n                constructor(stream){\n                    assertRequiredArgument(stream, 1, \"ReadableStreamDefaultReader\");\n                    assertReadableStream(stream, \"First parameter\");\n                    if (IsReadableStreamLocked(stream)) {\n                        throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n                    }\n                    ReadableStreamReaderGenericInitialize(this, stream);\n                    this._readRequests = new SimpleQueue();\n                }\n                /**\n\t\t         * Returns a promise that will be fulfilled when the stream becomes closed,\n\t\t         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n\t\t         */ get closed() {\n                    if (!IsReadableStreamDefaultReader(this)) {\n                        return promiseRejectedWith(defaultReaderBrandCheckException(\"closed\"));\n                    }\n                    return this._closedPromise;\n                }\n                /**\n\t\t         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n\t\t         */ cancel(reason = undefined) {\n                    if (!IsReadableStreamDefaultReader(this)) {\n                        return promiseRejectedWith(defaultReaderBrandCheckException(\"cancel\"));\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"cancel\"));\n                    }\n                    return ReadableStreamReaderGenericCancel(this, reason);\n                }\n                /**\n\t\t         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n\t\t         *\n\t\t         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n\t\t         */ read() {\n                    if (!IsReadableStreamDefaultReader(this)) {\n                        return promiseRejectedWith(defaultReaderBrandCheckException(\"read\"));\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"read from\"));\n                    }\n                    let resolvePromise;\n                    let rejectPromise;\n                    const promise = newPromise((resolve, reject)=>{\n                        resolvePromise = resolve;\n                        rejectPromise = reject;\n                    });\n                    const readRequest = {\n                        _chunkSteps: (chunk)=>resolvePromise({\n                                value: chunk,\n                                done: false\n                            }),\n                        _closeSteps: ()=>resolvePromise({\n                                value: undefined,\n                                done: true\n                            }),\n                        _errorSteps: (e)=>rejectPromise(e)\n                    };\n                    ReadableStreamDefaultReaderRead(this, readRequest);\n                    return promise;\n                }\n                /**\n\t\t         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n\t\t         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n\t\t         * from now on; otherwise, the reader will appear closed.\n\t\t         *\n\t\t         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n\t\t         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n\t\t         * do so will throw a `TypeError` and leave the reader locked to the stream.\n\t\t         */ releaseLock() {\n                    if (!IsReadableStreamDefaultReader(this)) {\n                        throw defaultReaderBrandCheckException(\"releaseLock\");\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return;\n                    }\n                    if (this._readRequests.length > 0) {\n                        throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n                    }\n                    ReadableStreamReaderGenericRelease(this);\n                }\n            }\n            Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n                cancel: {\n                    enumerable: true\n                },\n                read: {\n                    enumerable: true\n                },\n                releaseLock: {\n                    enumerable: true\n                },\n                closed: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStreamDefaultReader\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the readers.\n            function IsReadableStreamDefaultReader(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_readRequests\")) {\n                    return false;\n                }\n                return x instanceof ReadableStreamDefaultReader;\n            }\n            function ReadableStreamDefaultReaderRead(reader, readRequest) {\n                const stream = reader._ownerReadableStream;\n                stream._disturbed = true;\n                if (stream._state === \"closed\") {\n                    readRequest._closeSteps();\n                } else if (stream._state === \"errored\") {\n                    readRequest._errorSteps(stream._storedError);\n                } else {\n                    stream._readableStreamController[PullSteps](readRequest);\n                }\n            }\n            // Helper functions for the ReadableStreamDefaultReader.\n            function defaultReaderBrandCheckException(name) {\n                return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n            }\n            /// <reference lib=\"es2018.asynciterable\" />\n            /* eslint-disable @typescript-eslint/no-empty-function */ const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);\n            /// <reference lib=\"es2018.asynciterable\" />\n            class ReadableStreamAsyncIteratorImpl {\n                constructor(reader, preventCancel){\n                    this._ongoingPromise = undefined;\n                    this._isFinished = false;\n                    this._reader = reader;\n                    this._preventCancel = preventCancel;\n                }\n                next() {\n                    const nextSteps = ()=>this._nextSteps();\n                    this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();\n                    return this._ongoingPromise;\n                }\n                return(value1) {\n                    const returnSteps = ()=>this._returnSteps(value1);\n                    return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();\n                }\n                _nextSteps() {\n                    if (this._isFinished) {\n                        return Promise.resolve({\n                            value: undefined,\n                            done: true\n                        });\n                    }\n                    const reader = this._reader;\n                    if (reader._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"iterate\"));\n                    }\n                    let resolvePromise;\n                    let rejectPromise;\n                    const promise = newPromise((resolve, reject)=>{\n                        resolvePromise = resolve;\n                        rejectPromise = reject;\n                    });\n                    const readRequest = {\n                        _chunkSteps: (chunk)=>{\n                            this._ongoingPromise = undefined;\n                            // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                            // FIXME Is this a bug in the specification, or in the test?\n                            queueMicrotask(()=>resolvePromise({\n                                    value: chunk,\n                                    done: false\n                                }));\n                        },\n                        _closeSteps: ()=>{\n                            this._ongoingPromise = undefined;\n                            this._isFinished = true;\n                            ReadableStreamReaderGenericRelease(reader);\n                            resolvePromise({\n                                value: undefined,\n                                done: true\n                            });\n                        },\n                        _errorSteps: (reason)=>{\n                            this._ongoingPromise = undefined;\n                            this._isFinished = true;\n                            ReadableStreamReaderGenericRelease(reader);\n                            rejectPromise(reason);\n                        }\n                    };\n                    ReadableStreamDefaultReaderRead(reader, readRequest);\n                    return promise;\n                }\n                _returnSteps(value1) {\n                    if (this._isFinished) {\n                        return Promise.resolve({\n                            value: value1,\n                            done: true\n                        });\n                    }\n                    this._isFinished = true;\n                    const reader = this._reader;\n                    if (reader._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"finish iterating\"));\n                    }\n                    if (!this._preventCancel) {\n                        const result = ReadableStreamReaderGenericCancel(reader, value1);\n                        ReadableStreamReaderGenericRelease(reader);\n                        return transformPromiseWith(result, ()=>({\n                                value: value1,\n                                done: true\n                            }));\n                    }\n                    ReadableStreamReaderGenericRelease(reader);\n                    return promiseResolvedWith({\n                        value: value1,\n                        done: true\n                    });\n                }\n            }\n            const ReadableStreamAsyncIteratorPrototype = {\n                next () {\n                    if (!IsReadableStreamAsyncIterator(this)) {\n                        return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"next\"));\n                    }\n                    return this._asyncIteratorImpl.next();\n                },\n                return (value1) {\n                    if (!IsReadableStreamAsyncIterator(this)) {\n                        return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"return\"));\n                    }\n                    return this._asyncIteratorImpl.return(value1);\n                }\n            };\n            if (AsyncIteratorPrototype !== undefined) {\n                Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n            }\n            // Abstract operations for the ReadableStream.\n            function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n                const reader = AcquireReadableStreamDefaultReader(stream);\n                const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n                const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n                iterator._asyncIteratorImpl = impl;\n                return iterator;\n            }\n            function IsReadableStreamAsyncIterator(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_asyncIteratorImpl\")) {\n                    return false;\n                }\n                try {\n                    // noinspection SuspiciousTypeOfGuard\n                    return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;\n                } catch (_a) {\n                    return false;\n                }\n            }\n            // Helper functions for the ReadableStream.\n            function streamAsyncIteratorBrandCheckException(name) {\n                return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n            }\n            /// <reference lib=\"es2015.core\" />\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\n            const NumberIsNaN = Number.isNaN || function(x) {\n                // eslint-disable-next-line no-self-compare\n                return x !== x;\n            };\n            function CreateArrayFromList(elements) {\n                // We use arrays to represent lists, so this is basically a no-op.\n                // Do a slice though just in case we happen to depend on the unique-ness.\n                return elements.slice();\n            }\n            function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n                new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n            }\n            // Not implemented correctly\n            function TransferArrayBuffer(O) {\n                return O;\n            }\n            // Not implemented correctly\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            function IsDetachedBuffer(O) {\n                return false;\n            }\n            function ArrayBufferSlice(buffer, begin, end) {\n                // ArrayBuffer.prototype.slice is not available on IE10\n                // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n                if (buffer.slice) {\n                    return buffer.slice(begin, end);\n                }\n                const length = end - begin;\n                const slice = new ArrayBuffer(length);\n                CopyDataBlockBytes(slice, 0, buffer, begin, length);\n                return slice;\n            }\n            function IsNonNegativeNumber(v) {\n                if (typeof v !== \"number\") {\n                    return false;\n                }\n                if (NumberIsNaN(v)) {\n                    return false;\n                }\n                if (v < 0) {\n                    return false;\n                }\n                return true;\n            }\n            function CloneAsUint8Array(O) {\n                const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n                return new Uint8Array(buffer);\n            }\n            function DequeueValue(container) {\n                const pair = container._queue.shift();\n                container._queueTotalSize -= pair.size;\n                if (container._queueTotalSize < 0) {\n                    container._queueTotalSize = 0;\n                }\n                return pair.value;\n            }\n            function EnqueueValueWithSize(container, value1, size) {\n                if (!IsNonNegativeNumber(size) || size === Infinity) {\n                    throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n                }\n                container._queue.push({\n                    value: value1,\n                    size\n                });\n                container._queueTotalSize += size;\n            }\n            function PeekQueueValue(container) {\n                const pair = container._queue.peek();\n                return pair.value;\n            }\n            function ResetQueue(container) {\n                container._queue = new SimpleQueue();\n                container._queueTotalSize = 0;\n            }\n            /**\n\t\t     * A pull-into request in a {@link ReadableByteStreamController}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStreamBYOBRequest {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n\t\t         */ get view() {\n                    if (!IsReadableStreamBYOBRequest(this)) {\n                        throw byobRequestBrandCheckException(\"view\");\n                    }\n                    return this._view;\n                }\n                respond(bytesWritten) {\n                    if (!IsReadableStreamBYOBRequest(this)) {\n                        throw byobRequestBrandCheckException(\"respond\");\n                    }\n                    assertRequiredArgument(bytesWritten, 1, \"respond\");\n                    bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, \"First parameter\");\n                    if (this._associatedReadableByteStreamController === undefined) {\n                        throw new TypeError(\"This BYOB request has been invalidated\");\n                    }\n                    if (IsDetachedBuffer(this._view.buffer)) ;\n                    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n                }\n                respondWithNewView(view) {\n                    if (!IsReadableStreamBYOBRequest(this)) {\n                        throw byobRequestBrandCheckException(\"respondWithNewView\");\n                    }\n                    assertRequiredArgument(view, 1, \"respondWithNewView\");\n                    if (!ArrayBuffer.isView(view)) {\n                        throw new TypeError(\"You can only respond with array buffer views\");\n                    }\n                    if (this._associatedReadableByteStreamController === undefined) {\n                        throw new TypeError(\"This BYOB request has been invalidated\");\n                    }\n                    if (IsDetachedBuffer(view.buffer)) ;\n                    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n                }\n            }\n            Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n                respond: {\n                    enumerable: true\n                },\n                respondWithNewView: {\n                    enumerable: true\n                },\n                view: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStreamBYOBRequest\",\n                    configurable: true\n                });\n            }\n            /**\n\t\t     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableByteStreamController {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * Returns the current BYOB pull request, or `null` if there isn't one.\n\t\t         */ get byobRequest() {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"byobRequest\");\n                    }\n                    return ReadableByteStreamControllerGetBYOBRequest(this);\n                }\n                /**\n\t\t         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n\t\t         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n\t\t         */ get desiredSize() {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"desiredSize\");\n                    }\n                    return ReadableByteStreamControllerGetDesiredSize(this);\n                }\n                /**\n\t\t         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n\t\t         * the stream, but once those are read, the stream will become closed.\n\t\t         */ close() {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"close\");\n                    }\n                    if (this._closeRequested) {\n                        throw new TypeError(\"The stream has already been closed; do not close it again!\");\n                    }\n                    const state = this._controlledReadableByteStream._state;\n                    if (state !== \"readable\") {\n                        throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n                    }\n                    ReadableByteStreamControllerClose(this);\n                }\n                enqueue(chunk) {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"enqueue\");\n                    }\n                    assertRequiredArgument(chunk, 1, \"enqueue\");\n                    if (!ArrayBuffer.isView(chunk)) {\n                        throw new TypeError(\"chunk must be an array buffer view\");\n                    }\n                    if (chunk.byteLength === 0) {\n                        throw new TypeError(\"chunk must have non-zero byteLength\");\n                    }\n                    if (chunk.buffer.byteLength === 0) {\n                        throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n                    }\n                    if (this._closeRequested) {\n                        throw new TypeError(\"stream is closed or draining\");\n                    }\n                    const state = this._controlledReadableByteStream._state;\n                    if (state !== \"readable\") {\n                        throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n                    }\n                    ReadableByteStreamControllerEnqueue(this, chunk);\n                }\n                /**\n\t\t         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n\t\t         */ error(e = undefined) {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"error\");\n                    }\n                    ReadableByteStreamControllerError(this, e);\n                }\n                /** @internal */ [CancelSteps](reason) {\n                    ReadableByteStreamControllerClearPendingPullIntos(this);\n                    ResetQueue(this);\n                    const result = this._cancelAlgorithm(reason);\n                    ReadableByteStreamControllerClearAlgorithms(this);\n                    return result;\n                }\n                /** @internal */ [PullSteps](readRequest) {\n                    const stream = this._controlledReadableByteStream;\n                    if (this._queueTotalSize > 0) {\n                        const entry = this._queue.shift();\n                        this._queueTotalSize -= entry.byteLength;\n                        ReadableByteStreamControllerHandleQueueDrain(this);\n                        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n                        readRequest._chunkSteps(view);\n                        return;\n                    }\n                    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n                    if (autoAllocateChunkSize !== undefined) {\n                        let buffer;\n                        try {\n                            buffer = new ArrayBuffer(autoAllocateChunkSize);\n                        } catch (bufferE) {\n                            readRequest._errorSteps(bufferE);\n                            return;\n                        }\n                        const pullIntoDescriptor = {\n                            buffer,\n                            bufferByteLength: autoAllocateChunkSize,\n                            byteOffset: 0,\n                            byteLength: autoAllocateChunkSize,\n                            bytesFilled: 0,\n                            elementSize: 1,\n                            viewConstructor: Uint8Array,\n                            readerType: \"default\"\n                        };\n                        this._pendingPullIntos.push(pullIntoDescriptor);\n                    }\n                    ReadableStreamAddReadRequest(stream, readRequest);\n                    ReadableByteStreamControllerCallPullIfNeeded(this);\n                }\n            }\n            Object.defineProperties(ReadableByteStreamController.prototype, {\n                close: {\n                    enumerable: true\n                },\n                enqueue: {\n                    enumerable: true\n                },\n                error: {\n                    enumerable: true\n                },\n                byobRequest: {\n                    enumerable: true\n                },\n                desiredSize: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableByteStreamController\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the ReadableByteStreamController.\n            function IsReadableByteStreamController(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableByteStream\")) {\n                    return false;\n                }\n                return x instanceof ReadableByteStreamController;\n            }\n            function IsReadableStreamBYOBRequest(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_associatedReadableByteStreamController\")) {\n                    return false;\n                }\n                return x instanceof ReadableStreamBYOBRequest;\n            }\n            function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n                const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n                if (!shouldPull) {\n                    return;\n                }\n                if (controller._pulling) {\n                    controller._pullAgain = true;\n                    return;\n                }\n                controller._pulling = true;\n                // TODO: Test controller argument\n                const pullPromise = controller._pullAlgorithm();\n                uponPromise(pullPromise, ()=>{\n                    controller._pulling = false;\n                    if (controller._pullAgain) {\n                        controller._pullAgain = false;\n                        ReadableByteStreamControllerCallPullIfNeeded(controller);\n                    }\n                }, (e)=>{\n                    ReadableByteStreamControllerError(controller, e);\n                });\n            }\n            function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n                ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n                controller._pendingPullIntos = new SimpleQueue();\n            }\n            function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n                let done = false;\n                if (stream._state === \"closed\") {\n                    done = true;\n                }\n                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                if (pullIntoDescriptor.readerType === \"default\") {\n                    ReadableStreamFulfillReadRequest(stream, filledView, done);\n                } else {\n                    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n                }\n            }\n            function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n                const bytesFilled = pullIntoDescriptor.bytesFilled;\n                const elementSize = pullIntoDescriptor.elementSize;\n                return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n            }\n            function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n                controller._queue.push({\n                    buffer,\n                    byteOffset,\n                    byteLength\n                });\n                controller._queueTotalSize += byteLength;\n            }\n            function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n                const elementSize = pullIntoDescriptor.elementSize;\n                const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n                const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n                const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n                const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n                let totalBytesToCopyRemaining = maxBytesToCopy;\n                let ready = false;\n                if (maxAlignedBytes > currentAlignedBytes) {\n                    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n                    ready = true;\n                }\n                const queue = controller._queue;\n                while(totalBytesToCopyRemaining > 0){\n                    const headOfQueue = queue.peek();\n                    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n                    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n                    CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n                    if (headOfQueue.byteLength === bytesToCopy) {\n                        queue.shift();\n                    } else {\n                        headOfQueue.byteOffset += bytesToCopy;\n                        headOfQueue.byteLength -= bytesToCopy;\n                    }\n                    controller._queueTotalSize -= bytesToCopy;\n                    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n                    totalBytesToCopyRemaining -= bytesToCopy;\n                }\n                return ready;\n            }\n            function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n                pullIntoDescriptor.bytesFilled += size;\n            }\n            function ReadableByteStreamControllerHandleQueueDrain(controller) {\n                if (controller._queueTotalSize === 0 && controller._closeRequested) {\n                    ReadableByteStreamControllerClearAlgorithms(controller);\n                    ReadableStreamClose(controller._controlledReadableByteStream);\n                } else {\n                    ReadableByteStreamControllerCallPullIfNeeded(controller);\n                }\n            }\n            function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n                if (controller._byobRequest === null) {\n                    return;\n                }\n                controller._byobRequest._associatedReadableByteStreamController = undefined;\n                controller._byobRequest._view = null;\n                controller._byobRequest = null;\n            }\n            function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n                while(controller._pendingPullIntos.length > 0){\n                    if (controller._queueTotalSize === 0) {\n                        return;\n                    }\n                    const pullIntoDescriptor = controller._pendingPullIntos.peek();\n                    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                        ReadableByteStreamControllerShiftPendingPullInto(controller);\n                        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n                    }\n                }\n            }\n            function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n                const stream = controller._controlledReadableByteStream;\n                let elementSize = 1;\n                if (view.constructor !== DataView) {\n                    elementSize = view.constructor.BYTES_PER_ELEMENT;\n                }\n                const ctor = view.constructor;\n                // try {\n                const buffer = TransferArrayBuffer(view.buffer);\n                // } catch (e) {\n                //   readIntoRequest._errorSteps(e);\n                //   return;\n                // }\n                const pullIntoDescriptor = {\n                    buffer,\n                    bufferByteLength: buffer.byteLength,\n                    byteOffset: view.byteOffset,\n                    byteLength: view.byteLength,\n                    bytesFilled: 0,\n                    elementSize,\n                    viewConstructor: ctor,\n                    readerType: \"byob\"\n                };\n                if (controller._pendingPullIntos.length > 0) {\n                    controller._pendingPullIntos.push(pullIntoDescriptor);\n                    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n                    // - No change happens on desiredSize\n                    // - The source has already been notified of that there's at least 1 pending read(view)\n                    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n                    return;\n                }\n                if (stream._state === \"closed\") {\n                    const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n                    readIntoRequest._closeSteps(emptyView);\n                    return;\n                }\n                if (controller._queueTotalSize > 0) {\n                    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                        ReadableByteStreamControllerHandleQueueDrain(controller);\n                        readIntoRequest._chunkSteps(filledView);\n                        return;\n                    }\n                    if (controller._closeRequested) {\n                        const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                        ReadableByteStreamControllerError(controller, e);\n                        readIntoRequest._errorSteps(e);\n                        return;\n                    }\n                }\n                controller._pendingPullIntos.push(pullIntoDescriptor);\n                ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n            function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n                const stream = controller._controlledReadableByteStream;\n                if (ReadableStreamHasBYOBReader(stream)) {\n                    while(ReadableStreamGetNumReadIntoRequests(stream) > 0){\n                        const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n                        ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n                    }\n                }\n            }\n            function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n                ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n                if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n                    return;\n                }\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\n                const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n                if (remainderSize > 0) {\n                    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n                    const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n                    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n                }\n                pullIntoDescriptor.bytesFilled -= remainderSize;\n                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n                ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n            }\n            function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n                const firstDescriptor = controller._pendingPullIntos.peek();\n                ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n                const state = controller._controlledReadableByteStream._state;\n                if (state === \"closed\") {\n                    ReadableByteStreamControllerRespondInClosedState(controller);\n                } else {\n                    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n                }\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n            function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n                const descriptor = controller._pendingPullIntos.shift();\n                return descriptor;\n            }\n            function ReadableByteStreamControllerShouldCallPull(controller) {\n                const stream = controller._controlledReadableByteStream;\n                if (stream._state !== \"readable\") {\n                    return false;\n                }\n                if (controller._closeRequested) {\n                    return false;\n                }\n                if (!controller._started) {\n                    return false;\n                }\n                if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n                    return true;\n                }\n                if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n                    return true;\n                }\n                const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n                if (desiredSize > 0) {\n                    return true;\n                }\n                return false;\n            }\n            function ReadableByteStreamControllerClearAlgorithms(controller) {\n                controller._pullAlgorithm = undefined;\n                controller._cancelAlgorithm = undefined;\n            }\n            // A client of ReadableByteStreamController may use these functions directly to bypass state check.\n            function ReadableByteStreamControllerClose(controller) {\n                const stream = controller._controlledReadableByteStream;\n                if (controller._closeRequested || stream._state !== \"readable\") {\n                    return;\n                }\n                if (controller._queueTotalSize > 0) {\n                    controller._closeRequested = true;\n                    return;\n                }\n                if (controller._pendingPullIntos.length > 0) {\n                    const firstPendingPullInto = controller._pendingPullIntos.peek();\n                    if (firstPendingPullInto.bytesFilled > 0) {\n                        const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                        ReadableByteStreamControllerError(controller, e);\n                        throw e;\n                    }\n                }\n                ReadableByteStreamControllerClearAlgorithms(controller);\n                ReadableStreamClose(stream);\n            }\n            function ReadableByteStreamControllerEnqueue(controller, chunk) {\n                const stream = controller._controlledReadableByteStream;\n                if (controller._closeRequested || stream._state !== \"readable\") {\n                    return;\n                }\n                const buffer = chunk.buffer;\n                const byteOffset = chunk.byteOffset;\n                const byteLength = chunk.byteLength;\n                const transferredBuffer = TransferArrayBuffer(buffer);\n                if (controller._pendingPullIntos.length > 0) {\n                    const firstPendingPullInto = controller._pendingPullIntos.peek();\n                    if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;\n                    firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n                }\n                ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n                if (ReadableStreamHasDefaultReader(stream)) {\n                    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n                        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n                    } else {\n                        if (controller._pendingPullIntos.length > 0) {\n                            ReadableByteStreamControllerShiftPendingPullInto(controller);\n                        }\n                        const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n                        ReadableStreamFulfillReadRequest(stream, transferredView, false);\n                    }\n                } else if (ReadableStreamHasBYOBReader(stream)) {\n                    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n                    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n                    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n                } else {\n                    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n                }\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n            function ReadableByteStreamControllerError(controller, e) {\n                const stream = controller._controlledReadableByteStream;\n                if (stream._state !== \"readable\") {\n                    return;\n                }\n                ReadableByteStreamControllerClearPendingPullIntos(controller);\n                ResetQueue(controller);\n                ReadableByteStreamControllerClearAlgorithms(controller);\n                ReadableStreamError(stream, e);\n            }\n            function ReadableByteStreamControllerGetBYOBRequest(controller) {\n                if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n                    const firstDescriptor = controller._pendingPullIntos.peek();\n                    const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n                    const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n                    SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n                    controller._byobRequest = byobRequest;\n                }\n                return controller._byobRequest;\n            }\n            function ReadableByteStreamControllerGetDesiredSize(controller) {\n                const state = controller._controlledReadableByteStream._state;\n                if (state === \"errored\") {\n                    return null;\n                }\n                if (state === \"closed\") {\n                    return 0;\n                }\n                return controller._strategyHWM - controller._queueTotalSize;\n            }\n            function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n                const firstDescriptor = controller._pendingPullIntos.peek();\n                const state = controller._controlledReadableByteStream._state;\n                if (state === \"closed\") {\n                    if (bytesWritten !== 0) {\n                        throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n                    }\n                } else {\n                    if (bytesWritten === 0) {\n                        throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n                    }\n                    if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n                        throw new RangeError(\"bytesWritten out of range\");\n                    }\n                }\n                firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n                ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n            }\n            function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n                const firstDescriptor = controller._pendingPullIntos.peek();\n                const state = controller._controlledReadableByteStream._state;\n                if (state === \"closed\") {\n                    if (view.byteLength !== 0) {\n                        throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n                    }\n                } else {\n                    if (view.byteLength === 0) {\n                        throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n                    }\n                }\n                if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n                    throw new RangeError(\"The region specified by view does not match byobRequest\");\n                }\n                if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n                    throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n                }\n                if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n                    throw new RangeError(\"The region specified by view is larger than byobRequest\");\n                }\n                const viewByteLength = view.byteLength;\n                firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n                ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n            }\n            function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n                controller._controlledReadableByteStream = stream;\n                controller._pullAgain = false;\n                controller._pulling = false;\n                controller._byobRequest = null;\n                // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n                controller._queue = controller._queueTotalSize = undefined;\n                ResetQueue(controller);\n                controller._closeRequested = false;\n                controller._started = false;\n                controller._strategyHWM = highWaterMark;\n                controller._pullAlgorithm = pullAlgorithm;\n                controller._cancelAlgorithm = cancelAlgorithm;\n                controller._autoAllocateChunkSize = autoAllocateChunkSize;\n                controller._pendingPullIntos = new SimpleQueue();\n                stream._readableStreamController = controller;\n                const startResult = startAlgorithm();\n                uponPromise(promiseResolvedWith(startResult), ()=>{\n                    controller._started = true;\n                    ReadableByteStreamControllerCallPullIfNeeded(controller);\n                }, (r)=>{\n                    ReadableByteStreamControllerError(controller, r);\n                });\n            }\n            function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n                const controller = Object.create(ReadableByteStreamController.prototype);\n                let startAlgorithm = ()=>undefined;\n                let pullAlgorithm = ()=>promiseResolvedWith(undefined);\n                let cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n                if (underlyingByteSource.start !== undefined) {\n                    startAlgorithm = ()=>underlyingByteSource.start(controller);\n                }\n                if (underlyingByteSource.pull !== undefined) {\n                    pullAlgorithm = ()=>underlyingByteSource.pull(controller);\n                }\n                if (underlyingByteSource.cancel !== undefined) {\n                    cancelAlgorithm = (reason)=>underlyingByteSource.cancel(reason);\n                }\n                const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n                if (autoAllocateChunkSize === 0) {\n                    throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n                }\n                SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n            }\n            function SetUpReadableStreamBYOBRequest(request, controller, view) {\n                request._associatedReadableByteStreamController = controller;\n                request._view = view;\n            }\n            // Helper functions for the ReadableStreamBYOBRequest.\n            function byobRequestBrandCheckException(name) {\n                return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n            }\n            // Helper functions for the ReadableByteStreamController.\n            function byteStreamControllerBrandCheckException(name) {\n                return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n            }\n            // Abstract operations for the ReadableStream.\n            function AcquireReadableStreamBYOBReader(stream) {\n                return new ReadableStreamBYOBReader(stream);\n            }\n            // ReadableStream API exposed for controllers.\n            function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n                stream._reader._readIntoRequests.push(readIntoRequest);\n            }\n            function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n                const reader = stream._reader;\n                const readIntoRequest = reader._readIntoRequests.shift();\n                if (done) {\n                    readIntoRequest._closeSteps(chunk);\n                } else {\n                    readIntoRequest._chunkSteps(chunk);\n                }\n            }\n            function ReadableStreamGetNumReadIntoRequests(stream) {\n                return stream._reader._readIntoRequests.length;\n            }\n            function ReadableStreamHasBYOBReader(stream) {\n                const reader = stream._reader;\n                if (reader === undefined) {\n                    return false;\n                }\n                if (!IsReadableStreamBYOBReader(reader)) {\n                    return false;\n                }\n                return true;\n            }\n            /**\n\t\t     * A BYOB reader vended by a {@link ReadableStream}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStreamBYOBReader {\n                constructor(stream){\n                    assertRequiredArgument(stream, 1, \"ReadableStreamBYOBReader\");\n                    assertReadableStream(stream, \"First parameter\");\n                    if (IsReadableStreamLocked(stream)) {\n                        throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n                    }\n                    if (!IsReadableByteStreamController(stream._readableStreamController)) {\n                        throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte \" + \"source\");\n                    }\n                    ReadableStreamReaderGenericInitialize(this, stream);\n                    this._readIntoRequests = new SimpleQueue();\n                }\n                /**\n\t\t         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n\t\t         * the reader's lock is released before the stream finishes closing.\n\t\t         */ get closed() {\n                    if (!IsReadableStreamBYOBReader(this)) {\n                        return promiseRejectedWith(byobReaderBrandCheckException(\"closed\"));\n                    }\n                    return this._closedPromise;\n                }\n                /**\n\t\t         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n\t\t         */ cancel(reason = undefined) {\n                    if (!IsReadableStreamBYOBReader(this)) {\n                        return promiseRejectedWith(byobReaderBrandCheckException(\"cancel\"));\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"cancel\"));\n                    }\n                    return ReadableStreamReaderGenericCancel(this, reason);\n                }\n                /**\n\t\t         * Attempts to reads bytes into view, and returns a promise resolved with the result.\n\t\t         *\n\t\t         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n\t\t         */ read(view) {\n                    if (!IsReadableStreamBYOBReader(this)) {\n                        return promiseRejectedWith(byobReaderBrandCheckException(\"read\"));\n                    }\n                    if (!ArrayBuffer.isView(view)) {\n                        return promiseRejectedWith(new TypeError(\"view must be an array buffer view\"));\n                    }\n                    if (view.byteLength === 0) {\n                        return promiseRejectedWith(new TypeError(\"view must have non-zero byteLength\"));\n                    }\n                    if (view.buffer.byteLength === 0) {\n                        return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n                    }\n                    if (IsDetachedBuffer(view.buffer)) ;\n                    if (this._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"read from\"));\n                    }\n                    let resolvePromise;\n                    let rejectPromise;\n                    const promise = newPromise((resolve, reject)=>{\n                        resolvePromise = resolve;\n                        rejectPromise = reject;\n                    });\n                    const readIntoRequest = {\n                        _chunkSteps: (chunk)=>resolvePromise({\n                                value: chunk,\n                                done: false\n                            }),\n                        _closeSteps: (chunk)=>resolvePromise({\n                                value: chunk,\n                                done: true\n                            }),\n                        _errorSteps: (e)=>rejectPromise(e)\n                    };\n                    ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n                    return promise;\n                }\n                /**\n\t\t         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n\t\t         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n\t\t         * from now on; otherwise, the reader will appear closed.\n\t\t         *\n\t\t         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n\t\t         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n\t\t         * do so will throw a `TypeError` and leave the reader locked to the stream.\n\t\t         */ releaseLock() {\n                    if (!IsReadableStreamBYOBReader(this)) {\n                        throw byobReaderBrandCheckException(\"releaseLock\");\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return;\n                    }\n                    if (this._readIntoRequests.length > 0) {\n                        throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n                    }\n                    ReadableStreamReaderGenericRelease(this);\n                }\n            }\n            Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n                cancel: {\n                    enumerable: true\n                },\n                read: {\n                    enumerable: true\n                },\n                releaseLock: {\n                    enumerable: true\n                },\n                closed: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStreamBYOBReader\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the readers.\n            function IsReadableStreamBYOBReader(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_readIntoRequests\")) {\n                    return false;\n                }\n                return x instanceof ReadableStreamBYOBReader;\n            }\n            function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n                const stream = reader._ownerReadableStream;\n                stream._disturbed = true;\n                if (stream._state === \"errored\") {\n                    readIntoRequest._errorSteps(stream._storedError);\n                } else {\n                    ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n                }\n            }\n            // Helper functions for the ReadableStreamBYOBReader.\n            function byobReaderBrandCheckException(name) {\n                return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n            }\n            function ExtractHighWaterMark(strategy, defaultHWM) {\n                const { highWaterMark } = strategy;\n                if (highWaterMark === undefined) {\n                    return defaultHWM;\n                }\n                if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n                    throw new RangeError(\"Invalid highWaterMark\");\n                }\n                return highWaterMark;\n            }\n            function ExtractSizeAlgorithm(strategy) {\n                const { size } = strategy;\n                if (!size) {\n                    return ()=>1;\n                }\n                return size;\n            }\n            function convertQueuingStrategy(init, context) {\n                assertDictionary(init, context);\n                const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n                const size = init === null || init === void 0 ? void 0 : init.size;\n                return {\n                    highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n                    size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n                };\n            }\n            function convertQueuingStrategySize(fn, context) {\n                assertFunction(fn, context);\n                return (chunk)=>convertUnrestrictedDouble(fn(chunk));\n            }\n            function convertUnderlyingSink(original, context) {\n                assertDictionary(original, context);\n                const abort = original === null || original === void 0 ? void 0 : original.abort;\n                const close = original === null || original === void 0 ? void 0 : original.close;\n                const start = original === null || original === void 0 ? void 0 : original.start;\n                const type = original === null || original === void 0 ? void 0 : original.type;\n                const write = original === null || original === void 0 ? void 0 : original.write;\n                return {\n                    abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n                    close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n                    start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n                    write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n                    type\n                };\n            }\n            function convertUnderlyingSinkAbortCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (reason)=>promiseCall(fn, original, [\n                        reason\n                    ]);\n            }\n            function convertUnderlyingSinkCloseCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return ()=>promiseCall(fn, original, []);\n            }\n            function convertUnderlyingSinkStartCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>reflectCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertUnderlyingSinkWriteCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (chunk, controller)=>promiseCall(fn, original, [\n                        chunk,\n                        controller\n                    ]);\n            }\n            function assertWritableStream(x, context) {\n                if (!IsWritableStream(x)) {\n                    throw new TypeError(`${context} is not a WritableStream.`);\n                }\n            }\n            function isAbortSignal(value1) {\n                if (typeof value1 !== \"object\" || value1 === null) {\n                    return false;\n                }\n                try {\n                    return typeof value1.aborted === \"boolean\";\n                } catch (_a) {\n                    // AbortSignal.prototype.aborted throws if its brand check fails\n                    return false;\n                }\n            }\n            const supportsAbortController = typeof AbortController === \"function\";\n            /**\n\t\t     * Construct a new AbortController, if supported by the platform.\n\t\t     *\n\t\t     * @internal\n\t\t     */ function createAbortController() {\n                if (supportsAbortController) {\n                    return new AbortController();\n                }\n                return undefined;\n            }\n            /**\n\t\t     * A writable stream represents a destination for data, into which you can write.\n\t\t     *\n\t\t     * @public\n\t\t     */ class WritableStream {\n                constructor(rawUnderlyingSink = {}, rawStrategy = {}){\n                    if (rawUnderlyingSink === undefined) {\n                        rawUnderlyingSink = null;\n                    } else {\n                        assertObject(rawUnderlyingSink, \"First parameter\");\n                    }\n                    const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n                    const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, \"First parameter\");\n                    InitializeWritableStream(this);\n                    const type = underlyingSink.type;\n                    if (type !== undefined) {\n                        throw new RangeError(\"Invalid type is specified\");\n                    }\n                    const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                    const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n                }\n                /**\n\t\t         * Returns whether or not the writable stream is locked to a writer.\n\t\t         */ get locked() {\n                    if (!IsWritableStream(this)) {\n                        throw streamBrandCheckException$2(\"locked\");\n                    }\n                    return IsWritableStreamLocked(this);\n                }\n                /**\n\t\t         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n\t\t         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n\t\t         * mechanism of the underlying sink.\n\t\t         *\n\t\t         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n\t\t         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n\t\t         * the stream) if the stream is currently locked.\n\t\t         */ abort(reason = undefined) {\n                    if (!IsWritableStream(this)) {\n                        return promiseRejectedWith(streamBrandCheckException$2(\"abort\"));\n                    }\n                    if (IsWritableStreamLocked(this)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot abort a stream that already has a writer\"));\n                    }\n                    return WritableStreamAbort(this, reason);\n                }\n                /**\n\t\t         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n\t\t         * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n\t\t         *\n\t\t         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n\t\t         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n\t\t         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n\t\t         */ close() {\n                    if (!IsWritableStream(this)) {\n                        return promiseRejectedWith(streamBrandCheckException$2(\"close\"));\n                    }\n                    if (IsWritableStreamLocked(this)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot close a stream that already has a writer\"));\n                    }\n                    if (WritableStreamCloseQueuedOrInFlight(this)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n                    }\n                    return WritableStreamClose(this);\n                }\n                /**\n\t\t         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n\t\t         * is locked, no other writer can be acquired until this one is released.\n\t\t         *\n\t\t         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n\t\t         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n\t\t         * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n\t\t         */ getWriter() {\n                    if (!IsWritableStream(this)) {\n                        throw streamBrandCheckException$2(\"getWriter\");\n                    }\n                    return AcquireWritableStreamDefaultWriter(this);\n                }\n            }\n            Object.defineProperties(WritableStream.prototype, {\n                abort: {\n                    enumerable: true\n                },\n                close: {\n                    enumerable: true\n                },\n                getWriter: {\n                    enumerable: true\n                },\n                locked: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"WritableStream\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the WritableStream.\n            function AcquireWritableStreamDefaultWriter(stream) {\n                return new WritableStreamDefaultWriter(stream);\n            }\n            // Throws if and only if startAlgorithm throws.\n            function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n                const stream = Object.create(WritableStream.prototype);\n                InitializeWritableStream(stream);\n                const controller = Object.create(WritableStreamDefaultController.prototype);\n                SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n                return stream;\n            }\n            function InitializeWritableStream(stream) {\n                stream._state = \"writable\";\n                // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n                // 'erroring' or 'errored'. May be set to an undefined value.\n                stream._storedError = undefined;\n                stream._writer = undefined;\n                // Initialize to undefined first because the constructor of the controller checks this\n                // variable to validate the caller.\n                stream._writableStreamController = undefined;\n                // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n                // producer without waiting for the queued writes to finish.\n                stream._writeRequests = new SimpleQueue();\n                // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n                // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n                stream._inFlightWriteRequest = undefined;\n                // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n                // has been detached.\n                stream._closeRequest = undefined;\n                // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n                // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n                stream._inFlightCloseRequest = undefined;\n                // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n                stream._pendingAbortRequest = undefined;\n                // The backpressure signal set by the controller.\n                stream._backpressure = false;\n            }\n            function IsWritableStream(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_writableStreamController\")) {\n                    return false;\n                }\n                return x instanceof WritableStream;\n            }\n            function IsWritableStreamLocked(stream) {\n                if (stream._writer === undefined) {\n                    return false;\n                }\n                return true;\n            }\n            function WritableStreamAbort(stream, reason) {\n                var _a;\n                if (stream._state === \"closed\" || stream._state === \"errored\") {\n                    return promiseResolvedWith(undefined);\n                }\n                stream._writableStreamController._abortReason = reason;\n                (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();\n                // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n                // but it doesn't know that signaling abort runs author code that might have changed the state.\n                // Widen the type again by casting to WritableStreamState.\n                const state = stream._state;\n                if (state === \"closed\" || state === \"errored\") {\n                    return promiseResolvedWith(undefined);\n                }\n                if (stream._pendingAbortRequest !== undefined) {\n                    return stream._pendingAbortRequest._promise;\n                }\n                let wasAlreadyErroring = false;\n                if (state === \"erroring\") {\n                    wasAlreadyErroring = true;\n                    // reason will not be used, so don't keep a reference to it.\n                    reason = undefined;\n                }\n                const promise = newPromise((resolve, reject)=>{\n                    stream._pendingAbortRequest = {\n                        _promise: undefined,\n                        _resolve: resolve,\n                        _reject: reject,\n                        _reason: reason,\n                        _wasAlreadyErroring: wasAlreadyErroring\n                    };\n                });\n                stream._pendingAbortRequest._promise = promise;\n                if (!wasAlreadyErroring) {\n                    WritableStreamStartErroring(stream, reason);\n                }\n                return promise;\n            }\n            function WritableStreamClose(stream) {\n                const state = stream._state;\n                if (state === \"closed\" || state === \"errored\") {\n                    return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n                }\n                const promise = newPromise((resolve, reject)=>{\n                    const closeRequest = {\n                        _resolve: resolve,\n                        _reject: reject\n                    };\n                    stream._closeRequest = closeRequest;\n                });\n                const writer = stream._writer;\n                if (writer !== undefined && stream._backpressure && state === \"writable\") {\n                    defaultWriterReadyPromiseResolve(writer);\n                }\n                WritableStreamDefaultControllerClose(stream._writableStreamController);\n                return promise;\n            }\n            // WritableStream API exposed for controllers.\n            function WritableStreamAddWriteRequest(stream) {\n                const promise = newPromise((resolve, reject)=>{\n                    const writeRequest = {\n                        _resolve: resolve,\n                        _reject: reject\n                    };\n                    stream._writeRequests.push(writeRequest);\n                });\n                return promise;\n            }\n            function WritableStreamDealWithRejection(stream, error) {\n                const state = stream._state;\n                if (state === \"writable\") {\n                    WritableStreamStartErroring(stream, error);\n                    return;\n                }\n                WritableStreamFinishErroring(stream);\n            }\n            function WritableStreamStartErroring(stream, reason) {\n                const controller = stream._writableStreamController;\n                stream._state = \"erroring\";\n                stream._storedError = reason;\n                const writer = stream._writer;\n                if (writer !== undefined) {\n                    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n                }\n                if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n                    WritableStreamFinishErroring(stream);\n                }\n            }\n            function WritableStreamFinishErroring(stream) {\n                stream._state = \"errored\";\n                stream._writableStreamController[ErrorSteps]();\n                const storedError = stream._storedError;\n                stream._writeRequests.forEach((writeRequest)=>{\n                    writeRequest._reject(storedError);\n                });\n                stream._writeRequests = new SimpleQueue();\n                if (stream._pendingAbortRequest === undefined) {\n                    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n                    return;\n                }\n                const abortRequest = stream._pendingAbortRequest;\n                stream._pendingAbortRequest = undefined;\n                if (abortRequest._wasAlreadyErroring) {\n                    abortRequest._reject(storedError);\n                    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n                    return;\n                }\n                const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n                uponPromise(promise, ()=>{\n                    abortRequest._resolve();\n                    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n                }, (reason)=>{\n                    abortRequest._reject(reason);\n                    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n                });\n            }\n            function WritableStreamFinishInFlightWrite(stream) {\n                stream._inFlightWriteRequest._resolve(undefined);\n                stream._inFlightWriteRequest = undefined;\n            }\n            function WritableStreamFinishInFlightWriteWithError(stream, error) {\n                stream._inFlightWriteRequest._reject(error);\n                stream._inFlightWriteRequest = undefined;\n                WritableStreamDealWithRejection(stream, error);\n            }\n            function WritableStreamFinishInFlightClose(stream) {\n                stream._inFlightCloseRequest._resolve(undefined);\n                stream._inFlightCloseRequest = undefined;\n                const state = stream._state;\n                if (state === \"erroring\") {\n                    // The error was too late to do anything, so it is ignored.\n                    stream._storedError = undefined;\n                    if (stream._pendingAbortRequest !== undefined) {\n                        stream._pendingAbortRequest._resolve();\n                        stream._pendingAbortRequest = undefined;\n                    }\n                }\n                stream._state = \"closed\";\n                const writer = stream._writer;\n                if (writer !== undefined) {\n                    defaultWriterClosedPromiseResolve(writer);\n                }\n            }\n            function WritableStreamFinishInFlightCloseWithError(stream, error) {\n                stream._inFlightCloseRequest._reject(error);\n                stream._inFlightCloseRequest = undefined;\n                // Never execute sink abort() after sink close().\n                if (stream._pendingAbortRequest !== undefined) {\n                    stream._pendingAbortRequest._reject(error);\n                    stream._pendingAbortRequest = undefined;\n                }\n                WritableStreamDealWithRejection(stream, error);\n            }\n            // TODO(ricea): Fix alphabetical order.\n            function WritableStreamCloseQueuedOrInFlight(stream) {\n                if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n                    return false;\n                }\n                return true;\n            }\n            function WritableStreamHasOperationMarkedInFlight(stream) {\n                if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n                    return false;\n                }\n                return true;\n            }\n            function WritableStreamMarkCloseRequestInFlight(stream) {\n                stream._inFlightCloseRequest = stream._closeRequest;\n                stream._closeRequest = undefined;\n            }\n            function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n                stream._inFlightWriteRequest = stream._writeRequests.shift();\n            }\n            function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n                if (stream._closeRequest !== undefined) {\n                    stream._closeRequest._reject(stream._storedError);\n                    stream._closeRequest = undefined;\n                }\n                const writer = stream._writer;\n                if (writer !== undefined) {\n                    defaultWriterClosedPromiseReject(writer, stream._storedError);\n                }\n            }\n            function WritableStreamUpdateBackpressure(stream, backpressure) {\n                const writer = stream._writer;\n                if (writer !== undefined && backpressure !== stream._backpressure) {\n                    if (backpressure) {\n                        defaultWriterReadyPromiseReset(writer);\n                    } else {\n                        defaultWriterReadyPromiseResolve(writer);\n                    }\n                }\n                stream._backpressure = backpressure;\n            }\n            /**\n\t\t     * A default writer vended by a {@link WritableStream}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class WritableStreamDefaultWriter {\n                constructor(stream){\n                    assertRequiredArgument(stream, 1, \"WritableStreamDefaultWriter\");\n                    assertWritableStream(stream, \"First parameter\");\n                    if (IsWritableStreamLocked(stream)) {\n                        throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n                    }\n                    this._ownerWritableStream = stream;\n                    stream._writer = this;\n                    const state = stream._state;\n                    if (state === \"writable\") {\n                        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                            defaultWriterReadyPromiseInitialize(this);\n                        } else {\n                            defaultWriterReadyPromiseInitializeAsResolved(this);\n                        }\n                        defaultWriterClosedPromiseInitialize(this);\n                    } else if (state === \"erroring\") {\n                        defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n                        defaultWriterClosedPromiseInitialize(this);\n                    } else if (state === \"closed\") {\n                        defaultWriterReadyPromiseInitializeAsResolved(this);\n                        defaultWriterClosedPromiseInitializeAsResolved(this);\n                    } else {\n                        const storedError = stream._storedError;\n                        defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n                        defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n                    }\n                }\n                /**\n\t\t         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n\t\t         * the writers lock is released before the stream finishes closing.\n\t\t         */ get closed() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"closed\"));\n                    }\n                    return this._closedPromise;\n                }\n                /**\n\t\t         * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n\t\t         * A producer can use this information to determine the right amount of data to write.\n\t\t         *\n\t\t         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n\t\t         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n\t\t         * the writers lock is released.\n\t\t         */ get desiredSize() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        throw defaultWriterBrandCheckException(\"desiredSize\");\n                    }\n                    if (this._ownerWritableStream === undefined) {\n                        throw defaultWriterLockException(\"desiredSize\");\n                    }\n                    return WritableStreamDefaultWriterGetDesiredSize(this);\n                }\n                /**\n\t\t         * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n\t\t         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n\t\t         * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n\t\t         *\n\t\t         * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n\t\t         * rejected.\n\t\t         */ get ready() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"ready\"));\n                    }\n                    return this._readyPromise;\n                }\n                /**\n\t\t         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n\t\t         */ abort(reason = undefined) {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"abort\"));\n                    }\n                    if (this._ownerWritableStream === undefined) {\n                        return promiseRejectedWith(defaultWriterLockException(\"abort\"));\n                    }\n                    return WritableStreamDefaultWriterAbort(this, reason);\n                }\n                /**\n\t\t         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n\t\t         */ close() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"close\"));\n                    }\n                    const stream = this._ownerWritableStream;\n                    if (stream === undefined) {\n                        return promiseRejectedWith(defaultWriterLockException(\"close\"));\n                    }\n                    if (WritableStreamCloseQueuedOrInFlight(stream)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n                    }\n                    return WritableStreamDefaultWriterClose(this);\n                }\n                /**\n\t\t         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n\t\t         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n\t\t         * now on; otherwise, the writer will appear closed.\n\t\t         *\n\t\t         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n\t\t         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n\t\t         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n\t\t         * other producers from writing in an interleaved manner.\n\t\t         */ releaseLock() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        throw defaultWriterBrandCheckException(\"releaseLock\");\n                    }\n                    const stream = this._ownerWritableStream;\n                    if (stream === undefined) {\n                        return;\n                    }\n                    WritableStreamDefaultWriterRelease(this);\n                }\n                write(chunk = undefined) {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"write\"));\n                    }\n                    if (this._ownerWritableStream === undefined) {\n                        return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n                    }\n                    return WritableStreamDefaultWriterWrite(this, chunk);\n                }\n            }\n            Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n                abort: {\n                    enumerable: true\n                },\n                close: {\n                    enumerable: true\n                },\n                releaseLock: {\n                    enumerable: true\n                },\n                write: {\n                    enumerable: true\n                },\n                closed: {\n                    enumerable: true\n                },\n                desiredSize: {\n                    enumerable: true\n                },\n                ready: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"WritableStreamDefaultWriter\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the WritableStreamDefaultWriter.\n            function IsWritableStreamDefaultWriter(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_ownerWritableStream\")) {\n                    return false;\n                }\n                return x instanceof WritableStreamDefaultWriter;\n            }\n            // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n            function WritableStreamDefaultWriterAbort(writer, reason) {\n                const stream = writer._ownerWritableStream;\n                return WritableStreamAbort(stream, reason);\n            }\n            function WritableStreamDefaultWriterClose(writer) {\n                const stream = writer._ownerWritableStream;\n                return WritableStreamClose(stream);\n            }\n            function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n                const stream = writer._ownerWritableStream;\n                const state = stream._state;\n                if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n                    return promiseResolvedWith(undefined);\n                }\n                if (state === \"errored\") {\n                    return promiseRejectedWith(stream._storedError);\n                }\n                return WritableStreamDefaultWriterClose(writer);\n            }\n            function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n                if (writer._closedPromiseState === \"pending\") {\n                    defaultWriterClosedPromiseReject(writer, error);\n                } else {\n                    defaultWriterClosedPromiseResetToRejected(writer, error);\n                }\n            }\n            function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n                if (writer._readyPromiseState === \"pending\") {\n                    defaultWriterReadyPromiseReject(writer, error);\n                } else {\n                    defaultWriterReadyPromiseResetToRejected(writer, error);\n                }\n            }\n            function WritableStreamDefaultWriterGetDesiredSize(writer) {\n                const stream = writer._ownerWritableStream;\n                const state = stream._state;\n                if (state === \"errored\" || state === \"erroring\") {\n                    return null;\n                }\n                if (state === \"closed\") {\n                    return 0;\n                }\n                return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n            }\n            function WritableStreamDefaultWriterRelease(writer) {\n                const stream = writer._ownerWritableStream;\n                const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n                WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n                // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n                // rejected until afterwards. This means that simply testing state will not work.\n                WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n                stream._writer = undefined;\n                writer._ownerWritableStream = undefined;\n            }\n            function WritableStreamDefaultWriterWrite(writer, chunk) {\n                const stream = writer._ownerWritableStream;\n                const controller = stream._writableStreamController;\n                const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n                if (stream !== writer._ownerWritableStream) {\n                    return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n                }\n                const state = stream._state;\n                if (state === \"errored\") {\n                    return promiseRejectedWith(stream._storedError);\n                }\n                if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n                    return promiseRejectedWith(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n                }\n                if (state === \"erroring\") {\n                    return promiseRejectedWith(stream._storedError);\n                }\n                const promise = WritableStreamAddWriteRequest(stream);\n                WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n                return promise;\n            }\n            const closeSentinel = {};\n            /**\n\t\t     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n\t\t     *\n\t\t     * @public\n\t\t     */ class WritableStreamDefaultController {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n\t\t         *\n\t\t         * @deprecated\n\t\t         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n\t\t         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n\t\t         */ get abortReason() {\n                    if (!IsWritableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$2(\"abortReason\");\n                    }\n                    return this._abortReason;\n                }\n                /**\n\t\t         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n\t\t         */ get signal() {\n                    if (!IsWritableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$2(\"signal\");\n                    }\n                    if (this._abortController === undefined) {\n                        // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n                        // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n                        // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n                        throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n                    }\n                    return this._abortController.signal;\n                }\n                /**\n\t\t         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n\t\t         *\n\t\t         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n\t\t         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n\t\t         * normal lifecycle of interactions with the underlying sink.\n\t\t         */ error(e = undefined) {\n                    if (!IsWritableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$2(\"error\");\n                    }\n                    const state = this._controlledWritableStream._state;\n                    if (state !== \"writable\") {\n                        // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n                        // just treat it as a no-op.\n                        return;\n                    }\n                    WritableStreamDefaultControllerError(this, e);\n                }\n                /** @internal */ [AbortSteps](reason) {\n                    const result = this._abortAlgorithm(reason);\n                    WritableStreamDefaultControllerClearAlgorithms(this);\n                    return result;\n                }\n                /** @internal */ [ErrorSteps]() {\n                    ResetQueue(this);\n                }\n            }\n            Object.defineProperties(WritableStreamDefaultController.prototype, {\n                abortReason: {\n                    enumerable: true\n                },\n                signal: {\n                    enumerable: true\n                },\n                error: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"WritableStreamDefaultController\",\n                    configurable: true\n                });\n            }\n            // Abstract operations implementing interface required by the WritableStream.\n            function IsWritableStreamDefaultController(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_controlledWritableStream\")) {\n                    return false;\n                }\n                return x instanceof WritableStreamDefaultController;\n            }\n            function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n                controller._controlledWritableStream = stream;\n                stream._writableStreamController = controller;\n                // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n                controller._queue = undefined;\n                controller._queueTotalSize = undefined;\n                ResetQueue(controller);\n                controller._abortReason = undefined;\n                controller._abortController = createAbortController();\n                controller._started = false;\n                controller._strategySizeAlgorithm = sizeAlgorithm;\n                controller._strategyHWM = highWaterMark;\n                controller._writeAlgorithm = writeAlgorithm;\n                controller._closeAlgorithm = closeAlgorithm;\n                controller._abortAlgorithm = abortAlgorithm;\n                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                WritableStreamUpdateBackpressure(stream, backpressure);\n                const startResult = startAlgorithm();\n                const startPromise = promiseResolvedWith(startResult);\n                uponPromise(startPromise, ()=>{\n                    controller._started = true;\n                    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n                }, (r)=>{\n                    controller._started = true;\n                    WritableStreamDealWithRejection(stream, r);\n                });\n            }\n            function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n                const controller = Object.create(WritableStreamDefaultController.prototype);\n                let startAlgorithm = ()=>undefined;\n                let writeAlgorithm = ()=>promiseResolvedWith(undefined);\n                let closeAlgorithm = ()=>promiseResolvedWith(undefined);\n                let abortAlgorithm = ()=>promiseResolvedWith(undefined);\n                if (underlyingSink.start !== undefined) {\n                    startAlgorithm = ()=>underlyingSink.start(controller);\n                }\n                if (underlyingSink.write !== undefined) {\n                    writeAlgorithm = (chunk)=>underlyingSink.write(chunk, controller);\n                }\n                if (underlyingSink.close !== undefined) {\n                    closeAlgorithm = ()=>underlyingSink.close();\n                }\n                if (underlyingSink.abort !== undefined) {\n                    abortAlgorithm = (reason)=>underlyingSink.abort(reason);\n                }\n                SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n            }\n            // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n            function WritableStreamDefaultControllerClearAlgorithms(controller) {\n                controller._writeAlgorithm = undefined;\n                controller._closeAlgorithm = undefined;\n                controller._abortAlgorithm = undefined;\n                controller._strategySizeAlgorithm = undefined;\n            }\n            function WritableStreamDefaultControllerClose(controller) {\n                EnqueueValueWithSize(controller, closeSentinel, 0);\n                WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n            }\n            function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n                try {\n                    return controller._strategySizeAlgorithm(chunk);\n                } catch (chunkSizeE) {\n                    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n                    return 1;\n                }\n            }\n            function WritableStreamDefaultControllerGetDesiredSize(controller) {\n                return controller._strategyHWM - controller._queueTotalSize;\n            }\n            function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n                try {\n                    EnqueueValueWithSize(controller, chunk, chunkSize);\n                } catch (enqueueE) {\n                    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n                    return;\n                }\n                const stream = controller._controlledWritableStream;\n                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === \"writable\") {\n                    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                    WritableStreamUpdateBackpressure(stream, backpressure);\n                }\n                WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n            }\n            // Abstract operations for the WritableStreamDefaultController.\n            function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n                const stream = controller._controlledWritableStream;\n                if (!controller._started) {\n                    return;\n                }\n                if (stream._inFlightWriteRequest !== undefined) {\n                    return;\n                }\n                const state = stream._state;\n                if (state === \"erroring\") {\n                    WritableStreamFinishErroring(stream);\n                    return;\n                }\n                if (controller._queue.length === 0) {\n                    return;\n                }\n                const value1 = PeekQueueValue(controller);\n                if (value1 === closeSentinel) {\n                    WritableStreamDefaultControllerProcessClose(controller);\n                } else {\n                    WritableStreamDefaultControllerProcessWrite(controller, value1);\n                }\n            }\n            function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n                if (controller._controlledWritableStream._state === \"writable\") {\n                    WritableStreamDefaultControllerError(controller, error);\n                }\n            }\n            function WritableStreamDefaultControllerProcessClose(controller) {\n                const stream = controller._controlledWritableStream;\n                WritableStreamMarkCloseRequestInFlight(stream);\n                DequeueValue(controller);\n                const sinkClosePromise = controller._closeAlgorithm();\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n                uponPromise(sinkClosePromise, ()=>{\n                    WritableStreamFinishInFlightClose(stream);\n                }, (reason)=>{\n                    WritableStreamFinishInFlightCloseWithError(stream, reason);\n                });\n            }\n            function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n                const stream = controller._controlledWritableStream;\n                WritableStreamMarkFirstWriteRequestInFlight(stream);\n                const sinkWritePromise = controller._writeAlgorithm(chunk);\n                uponPromise(sinkWritePromise, ()=>{\n                    WritableStreamFinishInFlightWrite(stream);\n                    const state = stream._state;\n                    DequeueValue(controller);\n                    if (!WritableStreamCloseQueuedOrInFlight(stream) && state === \"writable\") {\n                        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                        WritableStreamUpdateBackpressure(stream, backpressure);\n                    }\n                    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n                }, (reason)=>{\n                    if (stream._state === \"writable\") {\n                        WritableStreamDefaultControllerClearAlgorithms(controller);\n                    }\n                    WritableStreamFinishInFlightWriteWithError(stream, reason);\n                });\n            }\n            function WritableStreamDefaultControllerGetBackpressure(controller) {\n                const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n                return desiredSize <= 0;\n            }\n            // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n            function WritableStreamDefaultControllerError(controller, error) {\n                const stream = controller._controlledWritableStream;\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n                WritableStreamStartErroring(stream, error);\n            }\n            // Helper functions for the WritableStream.\n            function streamBrandCheckException$2(name) {\n                return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n            }\n            // Helper functions for the WritableStreamDefaultController.\n            function defaultControllerBrandCheckException$2(name) {\n                return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n            }\n            // Helper functions for the WritableStreamDefaultWriter.\n            function defaultWriterBrandCheckException(name) {\n                return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n            }\n            function defaultWriterLockException(name) {\n                return new TypeError(\"Cannot \" + name + \" a stream using a released writer\");\n            }\n            function defaultWriterClosedPromiseInitialize(writer) {\n                writer._closedPromise = newPromise((resolve, reject)=>{\n                    writer._closedPromise_resolve = resolve;\n                    writer._closedPromise_reject = reject;\n                    writer._closedPromiseState = \"pending\";\n                });\n            }\n            function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n                defaultWriterClosedPromiseInitialize(writer);\n                defaultWriterClosedPromiseReject(writer, reason);\n            }\n            function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n                defaultWriterClosedPromiseInitialize(writer);\n                defaultWriterClosedPromiseResolve(writer);\n            }\n            function defaultWriterClosedPromiseReject(writer, reason) {\n                if (writer._closedPromise_reject === undefined) {\n                    return;\n                }\n                setPromiseIsHandledToTrue(writer._closedPromise);\n                writer._closedPromise_reject(reason);\n                writer._closedPromise_resolve = undefined;\n                writer._closedPromise_reject = undefined;\n                writer._closedPromiseState = \"rejected\";\n            }\n            function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n                defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n            }\n            function defaultWriterClosedPromiseResolve(writer) {\n                if (writer._closedPromise_resolve === undefined) {\n                    return;\n                }\n                writer._closedPromise_resolve(undefined);\n                writer._closedPromise_resolve = undefined;\n                writer._closedPromise_reject = undefined;\n                writer._closedPromiseState = \"resolved\";\n            }\n            function defaultWriterReadyPromiseInitialize(writer) {\n                writer._readyPromise = newPromise((resolve, reject)=>{\n                    writer._readyPromise_resolve = resolve;\n                    writer._readyPromise_reject = reject;\n                });\n                writer._readyPromiseState = \"pending\";\n            }\n            function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n                defaultWriterReadyPromiseInitialize(writer);\n                defaultWriterReadyPromiseReject(writer, reason);\n            }\n            function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n                defaultWriterReadyPromiseInitialize(writer);\n                defaultWriterReadyPromiseResolve(writer);\n            }\n            function defaultWriterReadyPromiseReject(writer, reason) {\n                if (writer._readyPromise_reject === undefined) {\n                    return;\n                }\n                setPromiseIsHandledToTrue(writer._readyPromise);\n                writer._readyPromise_reject(reason);\n                writer._readyPromise_resolve = undefined;\n                writer._readyPromise_reject = undefined;\n                writer._readyPromiseState = \"rejected\";\n            }\n            function defaultWriterReadyPromiseReset(writer) {\n                defaultWriterReadyPromiseInitialize(writer);\n            }\n            function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n                defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n            }\n            function defaultWriterReadyPromiseResolve(writer) {\n                if (writer._readyPromise_resolve === undefined) {\n                    return;\n                }\n                writer._readyPromise_resolve(undefined);\n                writer._readyPromise_resolve = undefined;\n                writer._readyPromise_reject = undefined;\n                writer._readyPromiseState = \"fulfilled\";\n            }\n            /// <reference lib=\"dom\" />\n            const NativeDOMException = typeof DOMException !== \"undefined\" ? DOMException : undefined;\n            /// <reference types=\"node\" />\n            function isDOMExceptionConstructor(ctor) {\n                if (!(typeof ctor === \"function\" || typeof ctor === \"object\")) {\n                    return false;\n                }\n                try {\n                    new ctor();\n                    return true;\n                } catch (_a) {\n                    return false;\n                }\n            }\n            function createDOMExceptionPolyfill() {\n                // eslint-disable-next-line no-shadow\n                const ctor = function DOMException1(message, name) {\n                    this.message = message || \"\";\n                    this.name = name || \"Error\";\n                    if (Error.captureStackTrace) {\n                        Error.captureStackTrace(this, this.constructor);\n                    }\n                };\n                ctor.prototype = Object.create(Error.prototype);\n                Object.defineProperty(ctor.prototype, \"constructor\", {\n                    value: ctor,\n                    writable: true,\n                    configurable: true\n                });\n                return ctor;\n            }\n            // eslint-disable-next-line no-redeclare\n            const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n            function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n                const reader = AcquireReadableStreamDefaultReader(source);\n                const writer = AcquireWritableStreamDefaultWriter(dest);\n                source._disturbed = true;\n                let shuttingDown = false;\n                // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n                let currentWrite = promiseResolvedWith(undefined);\n                return newPromise((resolve, reject)=>{\n                    let abortAlgorithm;\n                    if (signal !== undefined) {\n                        abortAlgorithm = ()=>{\n                            const error = new DOMException$1(\"Aborted\", \"AbortError\");\n                            const actions = [];\n                            if (!preventAbort) {\n                                actions.push(()=>{\n                                    if (dest._state === \"writable\") {\n                                        return WritableStreamAbort(dest, error);\n                                    }\n                                    return promiseResolvedWith(undefined);\n                                });\n                            }\n                            if (!preventCancel) {\n                                actions.push(()=>{\n                                    if (source._state === \"readable\") {\n                                        return ReadableStreamCancel(source, error);\n                                    }\n                                    return promiseResolvedWith(undefined);\n                                });\n                            }\n                            shutdownWithAction(()=>Promise.all(actions.map((action)=>action())), true, error);\n                        };\n                        if (signal.aborted) {\n                            abortAlgorithm();\n                            return;\n                        }\n                        signal.addEventListener(\"abort\", abortAlgorithm);\n                    }\n                    // Using reader and writer, read all chunks from this and write them to dest\n                    // - Backpressure must be enforced\n                    // - Shutdown must stop all activity\n                    function pipeLoop() {\n                        return newPromise((resolveLoop, rejectLoop)=>{\n                            function next(done) {\n                                if (done) {\n                                    resolveLoop();\n                                } else {\n                                    // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                                    // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                                    PerformPromiseThen(pipeStep(), next, rejectLoop);\n                                }\n                            }\n                            next(false);\n                        });\n                    }\n                    function pipeStep() {\n                        if (shuttingDown) {\n                            return promiseResolvedWith(true);\n                        }\n                        return PerformPromiseThen(writer._readyPromise, ()=>{\n                            return newPromise((resolveRead, rejectRead)=>{\n                                ReadableStreamDefaultReaderRead(reader, {\n                                    _chunkSteps: (chunk)=>{\n                                        currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                                        resolveRead(false);\n                                    },\n                                    _closeSteps: ()=>resolveRead(true),\n                                    _errorSteps: rejectRead\n                                });\n                            });\n                        });\n                    }\n                    // Errors must be propagated forward\n                    isOrBecomesErrored(source, reader._closedPromise, (storedError)=>{\n                        if (!preventAbort) {\n                            shutdownWithAction(()=>WritableStreamAbort(dest, storedError), true, storedError);\n                        } else {\n                            shutdown(true, storedError);\n                        }\n                    });\n                    // Errors must be propagated backward\n                    isOrBecomesErrored(dest, writer._closedPromise, (storedError)=>{\n                        if (!preventCancel) {\n                            shutdownWithAction(()=>ReadableStreamCancel(source, storedError), true, storedError);\n                        } else {\n                            shutdown(true, storedError);\n                        }\n                    });\n                    // Closing must be propagated forward\n                    isOrBecomesClosed(source, reader._closedPromise, ()=>{\n                        if (!preventClose) {\n                            shutdownWithAction(()=>WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n                        } else {\n                            shutdown();\n                        }\n                    });\n                    // Closing must be propagated backward\n                    if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === \"closed\") {\n                        const destClosed = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n                        if (!preventCancel) {\n                            shutdownWithAction(()=>ReadableStreamCancel(source, destClosed), true, destClosed);\n                        } else {\n                            shutdown(true, destClosed);\n                        }\n                    }\n                    setPromiseIsHandledToTrue(pipeLoop());\n                    function waitForWritesToFinish() {\n                        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n                        // for that too.\n                        const oldCurrentWrite = currentWrite;\n                        return PerformPromiseThen(currentWrite, ()=>oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n                    }\n                    function isOrBecomesErrored(stream, promise, action) {\n                        if (stream._state === \"errored\") {\n                            action(stream._storedError);\n                        } else {\n                            uponRejection(promise, action);\n                        }\n                    }\n                    function isOrBecomesClosed(stream, promise, action) {\n                        if (stream._state === \"closed\") {\n                            action();\n                        } else {\n                            uponFulfillment(promise, action);\n                        }\n                    }\n                    function shutdownWithAction(action, originalIsError, originalError) {\n                        if (shuttingDown) {\n                            return;\n                        }\n                        shuttingDown = true;\n                        if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                            uponFulfillment(waitForWritesToFinish(), doTheRest);\n                        } else {\n                            doTheRest();\n                        }\n                        function doTheRest() {\n                            uponPromise(action(), ()=>finalize(originalIsError, originalError), (newError)=>finalize(true, newError));\n                        }\n                    }\n                    function shutdown(isError, error) {\n                        if (shuttingDown) {\n                            return;\n                        }\n                        shuttingDown = true;\n                        if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                            uponFulfillment(waitForWritesToFinish(), ()=>finalize(isError, error));\n                        } else {\n                            finalize(isError, error);\n                        }\n                    }\n                    function finalize(isError, error) {\n                        WritableStreamDefaultWriterRelease(writer);\n                        ReadableStreamReaderGenericRelease(reader);\n                        if (signal !== undefined) {\n                            signal.removeEventListener(\"abort\", abortAlgorithm);\n                        }\n                        if (isError) {\n                            reject(error);\n                        } else {\n                            resolve(undefined);\n                        }\n                    }\n                });\n            }\n            /**\n\t\t     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStreamDefaultController {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n\t\t         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n\t\t         */ get desiredSize() {\n                    if (!IsReadableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$1(\"desiredSize\");\n                    }\n                    return ReadableStreamDefaultControllerGetDesiredSize(this);\n                }\n                /**\n\t\t         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n\t\t         * the stream, but once those are read, the stream will become closed.\n\t\t         */ close() {\n                    if (!IsReadableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$1(\"close\");\n                    }\n                    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                        throw new TypeError(\"The stream is not in a state that permits close\");\n                    }\n                    ReadableStreamDefaultControllerClose(this);\n                }\n                enqueue(chunk = undefined) {\n                    if (!IsReadableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$1(\"enqueue\");\n                    }\n                    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                        throw new TypeError(\"The stream is not in a state that permits enqueue\");\n                    }\n                    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n                }\n                /**\n\t\t         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n\t\t         */ error(e = undefined) {\n                    if (!IsReadableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$1(\"error\");\n                    }\n                    ReadableStreamDefaultControllerError(this, e);\n                }\n                /** @internal */ [CancelSteps](reason) {\n                    ResetQueue(this);\n                    const result = this._cancelAlgorithm(reason);\n                    ReadableStreamDefaultControllerClearAlgorithms(this);\n                    return result;\n                }\n                /** @internal */ [PullSteps](readRequest) {\n                    const stream = this._controlledReadableStream;\n                    if (this._queue.length > 0) {\n                        const chunk = DequeueValue(this);\n                        if (this._closeRequested && this._queue.length === 0) {\n                            ReadableStreamDefaultControllerClearAlgorithms(this);\n                            ReadableStreamClose(stream);\n                        } else {\n                            ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                        }\n                        readRequest._chunkSteps(chunk);\n                    } else {\n                        ReadableStreamAddReadRequest(stream, readRequest);\n                        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                    }\n                }\n            }\n            Object.defineProperties(ReadableStreamDefaultController.prototype, {\n                close: {\n                    enumerable: true\n                },\n                enqueue: {\n                    enumerable: true\n                },\n                error: {\n                    enumerable: true\n                },\n                desiredSize: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStreamDefaultController\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the ReadableStreamDefaultController.\n            function IsReadableStreamDefaultController(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableStream\")) {\n                    return false;\n                }\n                return x instanceof ReadableStreamDefaultController;\n            }\n            function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n                const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n                if (!shouldPull) {\n                    return;\n                }\n                if (controller._pulling) {\n                    controller._pullAgain = true;\n                    return;\n                }\n                controller._pulling = true;\n                const pullPromise = controller._pullAlgorithm();\n                uponPromise(pullPromise, ()=>{\n                    controller._pulling = false;\n                    if (controller._pullAgain) {\n                        controller._pullAgain = false;\n                        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n                    }\n                }, (e)=>{\n                    ReadableStreamDefaultControllerError(controller, e);\n                });\n            }\n            function ReadableStreamDefaultControllerShouldCallPull(controller) {\n                const stream = controller._controlledReadableStream;\n                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n                    return false;\n                }\n                if (!controller._started) {\n                    return false;\n                }\n                if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n                    return true;\n                }\n                const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n                if (desiredSize > 0) {\n                    return true;\n                }\n                return false;\n            }\n            function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n                controller._pullAlgorithm = undefined;\n                controller._cancelAlgorithm = undefined;\n                controller._strategySizeAlgorithm = undefined;\n            }\n            // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n            function ReadableStreamDefaultControllerClose(controller) {\n                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n                    return;\n                }\n                const stream = controller._controlledReadableStream;\n                controller._closeRequested = true;\n                if (controller._queue.length === 0) {\n                    ReadableStreamDefaultControllerClearAlgorithms(controller);\n                    ReadableStreamClose(stream);\n                }\n            }\n            function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n                    return;\n                }\n                const stream = controller._controlledReadableStream;\n                if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n                    ReadableStreamFulfillReadRequest(stream, chunk, false);\n                } else {\n                    let chunkSize;\n                    try {\n                        chunkSize = controller._strategySizeAlgorithm(chunk);\n                    } catch (chunkSizeE) {\n                        ReadableStreamDefaultControllerError(controller, chunkSizeE);\n                        throw chunkSizeE;\n                    }\n                    try {\n                        EnqueueValueWithSize(controller, chunk, chunkSize);\n                    } catch (enqueueE) {\n                        ReadableStreamDefaultControllerError(controller, enqueueE);\n                        throw enqueueE;\n                    }\n                }\n                ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n            }\n            function ReadableStreamDefaultControllerError(controller, e) {\n                const stream = controller._controlledReadableStream;\n                if (stream._state !== \"readable\") {\n                    return;\n                }\n                ResetQueue(controller);\n                ReadableStreamDefaultControllerClearAlgorithms(controller);\n                ReadableStreamError(stream, e);\n            }\n            function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n                const state = controller._controlledReadableStream._state;\n                if (state === \"errored\") {\n                    return null;\n                }\n                if (state === \"closed\") {\n                    return 0;\n                }\n                return controller._strategyHWM - controller._queueTotalSize;\n            }\n            // This is used in the implementation of TransformStream.\n            function ReadableStreamDefaultControllerHasBackpressure(controller) {\n                if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n                    return false;\n                }\n                return true;\n            }\n            function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n                const state = controller._controlledReadableStream._state;\n                if (!controller._closeRequested && state === \"readable\") {\n                    return true;\n                }\n                return false;\n            }\n            function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n                controller._controlledReadableStream = stream;\n                controller._queue = undefined;\n                controller._queueTotalSize = undefined;\n                ResetQueue(controller);\n                controller._started = false;\n                controller._closeRequested = false;\n                controller._pullAgain = false;\n                controller._pulling = false;\n                controller._strategySizeAlgorithm = sizeAlgorithm;\n                controller._strategyHWM = highWaterMark;\n                controller._pullAlgorithm = pullAlgorithm;\n                controller._cancelAlgorithm = cancelAlgorithm;\n                stream._readableStreamController = controller;\n                const startResult = startAlgorithm();\n                uponPromise(promiseResolvedWith(startResult), ()=>{\n                    controller._started = true;\n                    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n                }, (r)=>{\n                    ReadableStreamDefaultControllerError(controller, r);\n                });\n            }\n            function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n                const controller = Object.create(ReadableStreamDefaultController.prototype);\n                let startAlgorithm = ()=>undefined;\n                let pullAlgorithm = ()=>promiseResolvedWith(undefined);\n                let cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n                if (underlyingSource.start !== undefined) {\n                    startAlgorithm = ()=>underlyingSource.start(controller);\n                }\n                if (underlyingSource.pull !== undefined) {\n                    pullAlgorithm = ()=>underlyingSource.pull(controller);\n                }\n                if (underlyingSource.cancel !== undefined) {\n                    cancelAlgorithm = (reason)=>underlyingSource.cancel(reason);\n                }\n                SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n            }\n            // Helper functions for the ReadableStreamDefaultController.\n            function defaultControllerBrandCheckException$1(name) {\n                return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n            }\n            function ReadableStreamTee(stream, cloneForBranch2) {\n                if (IsReadableByteStreamController(stream._readableStreamController)) {\n                    return ReadableByteStreamTee(stream);\n                }\n                return ReadableStreamDefaultTee(stream);\n            }\n            function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n                const reader = AcquireReadableStreamDefaultReader(stream);\n                let reading = false;\n                let readAgain = false;\n                let canceled1 = false;\n                let canceled2 = false;\n                let reason1;\n                let reason2;\n                let branch1;\n                let branch2;\n                let resolveCancelPromise;\n                const cancelPromise = newPromise((resolve)=>{\n                    resolveCancelPromise = resolve;\n                });\n                function pullAlgorithm() {\n                    if (reading) {\n                        readAgain = true;\n                        return promiseResolvedWith(undefined);\n                    }\n                    reading = true;\n                    const readRequest = {\n                        _chunkSteps: (chunk)=>{\n                            // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                            // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                            // successful synchronously-available reads get ahead of asynchronously-available errors.\n                            queueMicrotask(()=>{\n                                readAgain = false;\n                                const chunk1 = chunk;\n                                const chunk2 = chunk;\n                                // There is no way to access the cloning code right now in the reference implementation.\n                                // If we add one then we'll need an implementation for serializable objects.\n                                // if (!canceled2 && cloneForBranch2) {\n                                //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n                                // }\n                                if (!canceled1) {\n                                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                                }\n                                if (!canceled2) {\n                                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                                }\n                                reading = false;\n                                if (readAgain) {\n                                    pullAlgorithm();\n                                }\n                            });\n                        },\n                        _closeSteps: ()=>{\n                            reading = false;\n                            if (!canceled1) {\n                                ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                            }\n                            if (!canceled2) {\n                                ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                            }\n                            if (!canceled1 || !canceled2) {\n                                resolveCancelPromise(undefined);\n                            }\n                        },\n                        _errorSteps: ()=>{\n                            reading = false;\n                        }\n                    };\n                    ReadableStreamDefaultReaderRead(reader, readRequest);\n                    return promiseResolvedWith(undefined);\n                }\n                function cancel1Algorithm(reason) {\n                    canceled1 = true;\n                    reason1 = reason;\n                    if (canceled2) {\n                        const compositeReason = CreateArrayFromList([\n                            reason1,\n                            reason2\n                        ]);\n                        const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                        resolveCancelPromise(cancelResult);\n                    }\n                    return cancelPromise;\n                }\n                function cancel2Algorithm(reason) {\n                    canceled2 = true;\n                    reason2 = reason;\n                    if (canceled1) {\n                        const compositeReason = CreateArrayFromList([\n                            reason1,\n                            reason2\n                        ]);\n                        const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                        resolveCancelPromise(cancelResult);\n                    }\n                    return cancelPromise;\n                }\n                function startAlgorithm() {\n                // do nothing\n                }\n                branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n                branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n                uponRejection(reader._closedPromise, (r)=>{\n                    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n                    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                });\n                return [\n                    branch1,\n                    branch2\n                ];\n            }\n            function ReadableByteStreamTee(stream) {\n                let reader = AcquireReadableStreamDefaultReader(stream);\n                let reading = false;\n                let readAgainForBranch1 = false;\n                let readAgainForBranch2 = false;\n                let canceled1 = false;\n                let canceled2 = false;\n                let reason1;\n                let reason2;\n                let branch1;\n                let branch2;\n                let resolveCancelPromise;\n                const cancelPromise = newPromise((resolve)=>{\n                    resolveCancelPromise = resolve;\n                });\n                function forwardReaderError(thisReader) {\n                    uponRejection(thisReader._closedPromise, (r)=>{\n                        if (thisReader !== reader) {\n                            return;\n                        }\n                        ReadableByteStreamControllerError(branch1._readableStreamController, r);\n                        ReadableByteStreamControllerError(branch2._readableStreamController, r);\n                        if (!canceled1 || !canceled2) {\n                            resolveCancelPromise(undefined);\n                        }\n                    });\n                }\n                function pullWithDefaultReader() {\n                    if (IsReadableStreamBYOBReader(reader)) {\n                        ReadableStreamReaderGenericRelease(reader);\n                        reader = AcquireReadableStreamDefaultReader(stream);\n                        forwardReaderError(reader);\n                    }\n                    const readRequest = {\n                        _chunkSteps: (chunk)=>{\n                            // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                            // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                            // successful synchronously-available reads get ahead of asynchronously-available errors.\n                            queueMicrotask(()=>{\n                                readAgainForBranch1 = false;\n                                readAgainForBranch2 = false;\n                                const chunk1 = chunk;\n                                let chunk2 = chunk;\n                                if (!canceled1 && !canceled2) {\n                                    try {\n                                        chunk2 = CloneAsUint8Array(chunk);\n                                    } catch (cloneE) {\n                                        ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                                        ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                                        resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                        return;\n                                    }\n                                }\n                                if (!canceled1) {\n                                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                                }\n                                if (!canceled2) {\n                                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                                }\n                                reading = false;\n                                if (readAgainForBranch1) {\n                                    pull1Algorithm();\n                                } else if (readAgainForBranch2) {\n                                    pull2Algorithm();\n                                }\n                            });\n                        },\n                        _closeSteps: ()=>{\n                            reading = false;\n                            if (!canceled1) {\n                                ReadableByteStreamControllerClose(branch1._readableStreamController);\n                            }\n                            if (!canceled2) {\n                                ReadableByteStreamControllerClose(branch2._readableStreamController);\n                            }\n                            if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n                            }\n                            if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n                            }\n                            if (!canceled1 || !canceled2) {\n                                resolveCancelPromise(undefined);\n                            }\n                        },\n                        _errorSteps: ()=>{\n                            reading = false;\n                        }\n                    };\n                    ReadableStreamDefaultReaderRead(reader, readRequest);\n                }\n                function pullWithBYOBReader(view, forBranch2) {\n                    if (IsReadableStreamDefaultReader(reader)) {\n                        ReadableStreamReaderGenericRelease(reader);\n                        reader = AcquireReadableStreamBYOBReader(stream);\n                        forwardReaderError(reader);\n                    }\n                    const byobBranch = forBranch2 ? branch2 : branch1;\n                    const otherBranch = forBranch2 ? branch1 : branch2;\n                    const readIntoRequest = {\n                        _chunkSteps: (chunk)=>{\n                            // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                            // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                            // successful synchronously-available reads get ahead of asynchronously-available errors.\n                            queueMicrotask(()=>{\n                                readAgainForBranch1 = false;\n                                readAgainForBranch2 = false;\n                                const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                                const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                                if (!otherCanceled) {\n                                    let clonedChunk;\n                                    try {\n                                        clonedChunk = CloneAsUint8Array(chunk);\n                                    } catch (cloneE) {\n                                        ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                                        ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                                        resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                        return;\n                                    }\n                                    if (!byobCanceled) {\n                                        ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                                    }\n                                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                                } else if (!byobCanceled) {\n                                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                                }\n                                reading = false;\n                                if (readAgainForBranch1) {\n                                    pull1Algorithm();\n                                } else if (readAgainForBranch2) {\n                                    pull2Algorithm();\n                                }\n                            });\n                        },\n                        _closeSteps: (chunk)=>{\n                            reading = false;\n                            const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                            const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                            if (!byobCanceled) {\n                                ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n                            }\n                            if (!otherCanceled) {\n                                ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n                            }\n                            if (chunk !== undefined) {\n                                if (!byobCanceled) {\n                                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                                }\n                                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                                }\n                            }\n                            if (!byobCanceled || !otherCanceled) {\n                                resolveCancelPromise(undefined);\n                            }\n                        },\n                        _errorSteps: ()=>{\n                            reading = false;\n                        }\n                    };\n                    ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n                }\n                function pull1Algorithm() {\n                    if (reading) {\n                        readAgainForBranch1 = true;\n                        return promiseResolvedWith(undefined);\n                    }\n                    reading = true;\n                    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n                    if (byobRequest === null) {\n                        pullWithDefaultReader();\n                    } else {\n                        pullWithBYOBReader(byobRequest._view, false);\n                    }\n                    return promiseResolvedWith(undefined);\n                }\n                function pull2Algorithm() {\n                    if (reading) {\n                        readAgainForBranch2 = true;\n                        return promiseResolvedWith(undefined);\n                    }\n                    reading = true;\n                    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n                    if (byobRequest === null) {\n                        pullWithDefaultReader();\n                    } else {\n                        pullWithBYOBReader(byobRequest._view, true);\n                    }\n                    return promiseResolvedWith(undefined);\n                }\n                function cancel1Algorithm(reason) {\n                    canceled1 = true;\n                    reason1 = reason;\n                    if (canceled2) {\n                        const compositeReason = CreateArrayFromList([\n                            reason1,\n                            reason2\n                        ]);\n                        const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                        resolveCancelPromise(cancelResult);\n                    }\n                    return cancelPromise;\n                }\n                function cancel2Algorithm(reason) {\n                    canceled2 = true;\n                    reason2 = reason;\n                    if (canceled1) {\n                        const compositeReason = CreateArrayFromList([\n                            reason1,\n                            reason2\n                        ]);\n                        const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                        resolveCancelPromise(cancelResult);\n                    }\n                    return cancelPromise;\n                }\n                function startAlgorithm() {\n                    return;\n                }\n                branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n                branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n                forwardReaderError(reader);\n                return [\n                    branch1,\n                    branch2\n                ];\n            }\n            function convertUnderlyingDefaultOrByteSource(source, context) {\n                assertDictionary(source, context);\n                const original = source;\n                const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n                const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n                const pull = original === null || original === void 0 ? void 0 : original.pull;\n                const start = original === null || original === void 0 ? void 0 : original.start;\n                const type = original === null || original === void 0 ? void 0 : original.type;\n                return {\n                    autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n                    cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n                    pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n                    start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n                    type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n                };\n            }\n            function convertUnderlyingSourceCancelCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (reason)=>promiseCall(fn, original, [\n                        reason\n                    ]);\n            }\n            function convertUnderlyingSourcePullCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>promiseCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertUnderlyingSourceStartCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>reflectCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertReadableStreamType(type, context) {\n                type = `${type}`;\n                if (type !== \"bytes\") {\n                    throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n                }\n                return type;\n            }\n            function convertReaderOptions(options, context) {\n                assertDictionary(options, context);\n                const mode = options === null || options === void 0 ? void 0 : options.mode;\n                return {\n                    mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n                };\n            }\n            function convertReadableStreamReaderMode(mode, context) {\n                mode = `${mode}`;\n                if (mode !== \"byob\") {\n                    throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n                }\n                return mode;\n            }\n            function convertIteratorOptions(options, context) {\n                assertDictionary(options, context);\n                const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n                return {\n                    preventCancel: Boolean(preventCancel)\n                };\n            }\n            function convertPipeOptions(options, context) {\n                assertDictionary(options, context);\n                const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n                const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n                const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n                const signal = options === null || options === void 0 ? void 0 : options.signal;\n                if (signal !== undefined) {\n                    assertAbortSignal(signal, `${context} has member 'signal' that`);\n                }\n                return {\n                    preventAbort: Boolean(preventAbort),\n                    preventCancel: Boolean(preventCancel),\n                    preventClose: Boolean(preventClose),\n                    signal\n                };\n            }\n            function assertAbortSignal(signal, context) {\n                if (!isAbortSignal(signal)) {\n                    throw new TypeError(`${context} is not an AbortSignal.`);\n                }\n            }\n            function convertReadableWritablePair(pair, context) {\n                assertDictionary(pair, context);\n                const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n                assertRequiredField(readable, \"readable\", \"ReadableWritablePair\");\n                assertReadableStream(readable, `${context} has member 'readable' that`);\n                const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n                assertRequiredField(writable, \"writable\", \"ReadableWritablePair\");\n                assertWritableStream(writable, `${context} has member 'writable' that`);\n                return {\n                    readable,\n                    writable\n                };\n            }\n            /**\n\t\t     * A readable stream represents a source of data, from which you can read.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStream1 {\n                constructor(rawUnderlyingSource = {}, rawStrategy = {}){\n                    if (rawUnderlyingSource === undefined) {\n                        rawUnderlyingSource = null;\n                    } else {\n                        assertObject(rawUnderlyingSource, \"First parameter\");\n                    }\n                    const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n                    const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, \"First parameter\");\n                    InitializeReadableStream(this);\n                    if (underlyingSource.type === \"bytes\") {\n                        if (strategy.size !== undefined) {\n                            throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n                        }\n                        const highWaterMark = ExtractHighWaterMark(strategy, 0);\n                        SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n                    } else {\n                        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                        const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                        SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n                    }\n                }\n                /**\n\t\t         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n\t\t         */ get locked() {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"locked\");\n                    }\n                    return IsReadableStreamLocked(this);\n                }\n                /**\n\t\t         * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n\t\t         *\n\t\t         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n\t\t         * method, which might or might not use it.\n\t\t         */ cancel(reason = undefined) {\n                    if (!IsReadableStream(this)) {\n                        return promiseRejectedWith(streamBrandCheckException$1(\"cancel\"));\n                    }\n                    if (IsReadableStreamLocked(this)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot cancel a stream that already has a reader\"));\n                    }\n                    return ReadableStreamCancel(this, reason);\n                }\n                getReader(rawOptions = undefined) {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"getReader\");\n                    }\n                    const options = convertReaderOptions(rawOptions, \"First parameter\");\n                    if (options.mode === undefined) {\n                        return AcquireReadableStreamDefaultReader(this);\n                    }\n                    return AcquireReadableStreamBYOBReader(this);\n                }\n                pipeThrough(rawTransform, rawOptions = {}) {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"pipeThrough\");\n                    }\n                    assertRequiredArgument(rawTransform, 1, \"pipeThrough\");\n                    const transform = convertReadableWritablePair(rawTransform, \"First parameter\");\n                    const options = convertPipeOptions(rawOptions, \"Second parameter\");\n                    if (IsReadableStreamLocked(this)) {\n                        throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n                    }\n                    if (IsWritableStreamLocked(transform.writable)) {\n                        throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n                    }\n                    const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n                    setPromiseIsHandledToTrue(promise);\n                    return transform.readable;\n                }\n                pipeTo(destination, rawOptions = {}) {\n                    if (!IsReadableStream(this)) {\n                        return promiseRejectedWith(streamBrandCheckException$1(\"pipeTo\"));\n                    }\n                    if (destination === undefined) {\n                        return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n                    }\n                    if (!IsWritableStream(destination)) {\n                        return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n                    }\n                    let options;\n                    try {\n                        options = convertPipeOptions(rawOptions, \"Second parameter\");\n                    } catch (e) {\n                        return promiseRejectedWith(e);\n                    }\n                    if (IsReadableStreamLocked(this)) {\n                        return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\"));\n                    }\n                    if (IsWritableStreamLocked(destination)) {\n                        return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\"));\n                    }\n                    return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n                }\n                /**\n\t\t         * Tees this readable stream, returning a two-element array containing the two resulting branches as\n\t\t         * new {@link ReadableStream} instances.\n\t\t         *\n\t\t         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n\t\t         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n\t\t         * propagated to the stream's underlying source.\n\t\t         *\n\t\t         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n\t\t         * this could allow interference between the two branches.\n\t\t         */ tee() {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"tee\");\n                    }\n                    const branches = ReadableStreamTee(this);\n                    return CreateArrayFromList(branches);\n                }\n                values(rawOptions = undefined) {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"values\");\n                    }\n                    const options = convertIteratorOptions(rawOptions, \"First parameter\");\n                    return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n                }\n            }\n            Object.defineProperties(ReadableStream1.prototype, {\n                cancel: {\n                    enumerable: true\n                },\n                getReader: {\n                    enumerable: true\n                },\n                pipeThrough: {\n                    enumerable: true\n                },\n                pipeTo: {\n                    enumerable: true\n                },\n                tee: {\n                    enumerable: true\n                },\n                values: {\n                    enumerable: true\n                },\n                locked: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStream1.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStream\",\n                    configurable: true\n                });\n            }\n            if (typeof SymbolPolyfill.asyncIterator === \"symbol\") {\n                Object.defineProperty(ReadableStream1.prototype, SymbolPolyfill.asyncIterator, {\n                    value: ReadableStream1.prototype.values,\n                    writable: true,\n                    configurable: true\n                });\n            }\n            // Abstract operations for the ReadableStream.\n            // Throws if and only if startAlgorithm throws.\n            function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n                const stream = Object.create(ReadableStream1.prototype);\n                InitializeReadableStream(stream);\n                const controller = Object.create(ReadableStreamDefaultController.prototype);\n                SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n                return stream;\n            }\n            // Throws if and only if startAlgorithm throws.\n            function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n                const stream = Object.create(ReadableStream1.prototype);\n                InitializeReadableStream(stream);\n                const controller = Object.create(ReadableByteStreamController.prototype);\n                SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n                return stream;\n            }\n            function InitializeReadableStream(stream) {\n                stream._state = \"readable\";\n                stream._reader = undefined;\n                stream._storedError = undefined;\n                stream._disturbed = false;\n            }\n            function IsReadableStream(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_readableStreamController\")) {\n                    return false;\n                }\n                return x instanceof ReadableStream1;\n            }\n            function IsReadableStreamLocked(stream) {\n                if (stream._reader === undefined) {\n                    return false;\n                }\n                return true;\n            }\n            // ReadableStream API exposed for controllers.\n            function ReadableStreamCancel(stream, reason) {\n                stream._disturbed = true;\n                if (stream._state === \"closed\") {\n                    return promiseResolvedWith(undefined);\n                }\n                if (stream._state === \"errored\") {\n                    return promiseRejectedWith(stream._storedError);\n                }\n                ReadableStreamClose(stream);\n                const reader = stream._reader;\n                if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n                    reader._readIntoRequests.forEach((readIntoRequest)=>{\n                        readIntoRequest._closeSteps(undefined);\n                    });\n                    reader._readIntoRequests = new SimpleQueue();\n                }\n                const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n                return transformPromiseWith(sourceCancelPromise, noop);\n            }\n            function ReadableStreamClose(stream) {\n                stream._state = \"closed\";\n                const reader = stream._reader;\n                if (reader === undefined) {\n                    return;\n                }\n                defaultReaderClosedPromiseResolve(reader);\n                if (IsReadableStreamDefaultReader(reader)) {\n                    reader._readRequests.forEach((readRequest)=>{\n                        readRequest._closeSteps();\n                    });\n                    reader._readRequests = new SimpleQueue();\n                }\n            }\n            function ReadableStreamError(stream, e) {\n                stream._state = \"errored\";\n                stream._storedError = e;\n                const reader = stream._reader;\n                if (reader === undefined) {\n                    return;\n                }\n                defaultReaderClosedPromiseReject(reader, e);\n                if (IsReadableStreamDefaultReader(reader)) {\n                    reader._readRequests.forEach((readRequest)=>{\n                        readRequest._errorSteps(e);\n                    });\n                    reader._readRequests = new SimpleQueue();\n                } else {\n                    reader._readIntoRequests.forEach((readIntoRequest)=>{\n                        readIntoRequest._errorSteps(e);\n                    });\n                    reader._readIntoRequests = new SimpleQueue();\n                }\n            }\n            // Helper functions for the ReadableStream.\n            function streamBrandCheckException$1(name) {\n                return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n            }\n            function convertQueuingStrategyInit(init, context) {\n                assertDictionary(init, context);\n                const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n                assertRequiredField(highWaterMark, \"highWaterMark\", \"QueuingStrategyInit\");\n                return {\n                    highWaterMark: convertUnrestrictedDouble(highWaterMark)\n                };\n            }\n            // The size function must not have a prototype property nor be a constructor\n            const byteLengthSizeFunction = (chunk)=>{\n                return chunk.byteLength;\n            };\n            try {\n                Object.defineProperty(byteLengthSizeFunction, \"name\", {\n                    value: \"size\",\n                    configurable: true\n                });\n            } catch (_a) {\n            // This property is non-configurable in older browsers, so ignore if this throws.\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n            }\n            /**\n\t\t     * A queuing strategy that counts the number of bytes in each chunk.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ByteLengthQueuingStrategy {\n                constructor(options){\n                    assertRequiredArgument(options, 1, \"ByteLengthQueuingStrategy\");\n                    options = convertQueuingStrategyInit(options, \"First parameter\");\n                    this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n                }\n                /**\n\t\t         * Returns the high water mark provided to the constructor.\n\t\t         */ get highWaterMark() {\n                    if (!IsByteLengthQueuingStrategy(this)) {\n                        throw byteLengthBrandCheckException(\"highWaterMark\");\n                    }\n                    return this._byteLengthQueuingStrategyHighWaterMark;\n                }\n                /**\n\t\t         * Measures the size of `chunk` by returning the value of its `byteLength` property.\n\t\t         */ get size() {\n                    if (!IsByteLengthQueuingStrategy(this)) {\n                        throw byteLengthBrandCheckException(\"size\");\n                    }\n                    return byteLengthSizeFunction;\n                }\n            }\n            Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n                highWaterMark: {\n                    enumerable: true\n                },\n                size: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ByteLengthQueuingStrategy\",\n                    configurable: true\n                });\n            }\n            // Helper functions for the ByteLengthQueuingStrategy.\n            function byteLengthBrandCheckException(name) {\n                return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n            }\n            function IsByteLengthQueuingStrategy(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_byteLengthQueuingStrategyHighWaterMark\")) {\n                    return false;\n                }\n                return x instanceof ByteLengthQueuingStrategy;\n            }\n            // The size function must not have a prototype property nor be a constructor\n            const countSizeFunction = ()=>{\n                return 1;\n            };\n            try {\n                Object.defineProperty(countSizeFunction, \"name\", {\n                    value: \"size\",\n                    configurable: true\n                });\n            } catch (_a) {\n            // This property is non-configurable in older browsers, so ignore if this throws.\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n            }\n            /**\n\t\t     * A queuing strategy that counts the number of chunks.\n\t\t     *\n\t\t     * @public\n\t\t     */ class CountQueuingStrategy {\n                constructor(options){\n                    assertRequiredArgument(options, 1, \"CountQueuingStrategy\");\n                    options = convertQueuingStrategyInit(options, \"First parameter\");\n                    this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n                }\n                /**\n\t\t         * Returns the high water mark provided to the constructor.\n\t\t         */ get highWaterMark() {\n                    if (!IsCountQueuingStrategy(this)) {\n                        throw countBrandCheckException(\"highWaterMark\");\n                    }\n                    return this._countQueuingStrategyHighWaterMark;\n                }\n                /**\n\t\t         * Measures the size of `chunk` by always returning 1.\n\t\t         * This ensures that the total queue size is a count of the number of chunks in the queue.\n\t\t         */ get size() {\n                    if (!IsCountQueuingStrategy(this)) {\n                        throw countBrandCheckException(\"size\");\n                    }\n                    return countSizeFunction;\n                }\n            }\n            Object.defineProperties(CountQueuingStrategy.prototype, {\n                highWaterMark: {\n                    enumerable: true\n                },\n                size: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"CountQueuingStrategy\",\n                    configurable: true\n                });\n            }\n            // Helper functions for the CountQueuingStrategy.\n            function countBrandCheckException(name) {\n                return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n            }\n            function IsCountQueuingStrategy(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_countQueuingStrategyHighWaterMark\")) {\n                    return false;\n                }\n                return x instanceof CountQueuingStrategy;\n            }\n            function convertTransformer(original, context) {\n                assertDictionary(original, context);\n                const flush = original === null || original === void 0 ? void 0 : original.flush;\n                const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n                const start = original === null || original === void 0 ? void 0 : original.start;\n                const transform = original === null || original === void 0 ? void 0 : original.transform;\n                const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n                return {\n                    flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n                    readableType,\n                    start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n                    transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n                    writableType\n                };\n            }\n            function convertTransformerFlushCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>promiseCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertTransformerStartCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>reflectCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertTransformerTransformCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (chunk, controller)=>promiseCall(fn, original, [\n                        chunk,\n                        controller\n                    ]);\n            }\n            // Class TransformStream\n            /**\n\t\t     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n\t\t     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n\t\t     * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n\t\t     * made available for reading from the readable side.\n\t\t     *\n\t\t     * @public\n\t\t     */ class TransformStream {\n                constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}){\n                    if (rawTransformer === undefined) {\n                        rawTransformer = null;\n                    }\n                    const writableStrategy = convertQueuingStrategy(rawWritableStrategy, \"Second parameter\");\n                    const readableStrategy = convertQueuingStrategy(rawReadableStrategy, \"Third parameter\");\n                    const transformer = convertTransformer(rawTransformer, \"First parameter\");\n                    if (transformer.readableType !== undefined) {\n                        throw new RangeError(\"Invalid readableType specified\");\n                    }\n                    if (transformer.writableType !== undefined) {\n                        throw new RangeError(\"Invalid writableType specified\");\n                    }\n                    const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n                    const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n                    const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n                    const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n                    let startPromise_resolve;\n                    const startPromise = newPromise((resolve)=>{\n                        startPromise_resolve = resolve;\n                    });\n                    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n                    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n                    if (transformer.start !== undefined) {\n                        startPromise_resolve(transformer.start(this._transformStreamController));\n                    } else {\n                        startPromise_resolve(undefined);\n                    }\n                }\n                /**\n\t\t         * The readable side of the transform stream.\n\t\t         */ get readable() {\n                    if (!IsTransformStream(this)) {\n                        throw streamBrandCheckException(\"readable\");\n                    }\n                    return this._readable;\n                }\n                /**\n\t\t         * The writable side of the transform stream.\n\t\t         */ get writable() {\n                    if (!IsTransformStream(this)) {\n                        throw streamBrandCheckException(\"writable\");\n                    }\n                    return this._writable;\n                }\n            }\n            Object.defineProperties(TransformStream.prototype, {\n                readable: {\n                    enumerable: true\n                },\n                writable: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"TransformStream\",\n                    configurable: true\n                });\n            }\n            function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n                function startAlgorithm() {\n                    return startPromise;\n                }\n                function writeAlgorithm(chunk) {\n                    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n                }\n                function abortAlgorithm(reason) {\n                    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n                }\n                function closeAlgorithm() {\n                    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n                }\n                stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n                function pullAlgorithm() {\n                    return TransformStreamDefaultSourcePullAlgorithm(stream);\n                }\n                function cancelAlgorithm(reason) {\n                    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n                    return promiseResolvedWith(undefined);\n                }\n                stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n                // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n                stream._backpressure = undefined;\n                stream._backpressureChangePromise = undefined;\n                stream._backpressureChangePromise_resolve = undefined;\n                TransformStreamSetBackpressure(stream, true);\n                stream._transformStreamController = undefined;\n            }\n            function IsTransformStream(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_transformStreamController\")) {\n                    return false;\n                }\n                return x instanceof TransformStream;\n            }\n            // This is a no-op if both sides are already errored.\n            function TransformStreamError(stream, e) {\n                ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n                TransformStreamErrorWritableAndUnblockWrite(stream, e);\n            }\n            function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n                TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n                WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n                if (stream._backpressure) {\n                    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n                    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n                    // _backpressure is set.\n                    TransformStreamSetBackpressure(stream, false);\n                }\n            }\n            function TransformStreamSetBackpressure(stream, backpressure) {\n                // Passes also when called during construction.\n                if (stream._backpressureChangePromise !== undefined) {\n                    stream._backpressureChangePromise_resolve();\n                }\n                stream._backpressureChangePromise = newPromise((resolve)=>{\n                    stream._backpressureChangePromise_resolve = resolve;\n                });\n                stream._backpressure = backpressure;\n            }\n            // Class TransformStreamDefaultController\n            /**\n\t\t     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class TransformStreamDefaultController {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n\t\t         */ get desiredSize() {\n                    if (!IsTransformStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException(\"desiredSize\");\n                    }\n                    const readableController = this._controlledTransformStream._readable._readableStreamController;\n                    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n                }\n                enqueue(chunk = undefined) {\n                    if (!IsTransformStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException(\"enqueue\");\n                    }\n                    TransformStreamDefaultControllerEnqueue(this, chunk);\n                }\n                /**\n\t\t         * Errors both the readable side and the writable side of the controlled transform stream, making all future\n\t\t         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n\t\t         */ error(reason = undefined) {\n                    if (!IsTransformStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException(\"error\");\n                    }\n                    TransformStreamDefaultControllerError(this, reason);\n                }\n                /**\n\t\t         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n\t\t         * transformer only needs to consume a portion of the chunks written to the writable side.\n\t\t         */ terminate() {\n                    if (!IsTransformStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException(\"terminate\");\n                    }\n                    TransformStreamDefaultControllerTerminate(this);\n                }\n            }\n            Object.defineProperties(TransformStreamDefaultController.prototype, {\n                enqueue: {\n                    enumerable: true\n                },\n                error: {\n                    enumerable: true\n                },\n                terminate: {\n                    enumerable: true\n                },\n                desiredSize: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"TransformStreamDefaultController\",\n                    configurable: true\n                });\n            }\n            // Transform Stream Default Controller Abstract Operations\n            function IsTransformStreamDefaultController(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_controlledTransformStream\")) {\n                    return false;\n                }\n                return x instanceof TransformStreamDefaultController;\n            }\n            function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n                controller._controlledTransformStream = stream;\n                stream._transformStreamController = controller;\n                controller._transformAlgorithm = transformAlgorithm;\n                controller._flushAlgorithm = flushAlgorithm;\n            }\n            function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n                const controller = Object.create(TransformStreamDefaultController.prototype);\n                let transformAlgorithm = (chunk)=>{\n                    try {\n                        TransformStreamDefaultControllerEnqueue(controller, chunk);\n                        return promiseResolvedWith(undefined);\n                    } catch (transformResultE) {\n                        return promiseRejectedWith(transformResultE);\n                    }\n                };\n                let flushAlgorithm = ()=>promiseResolvedWith(undefined);\n                if (transformer.transform !== undefined) {\n                    transformAlgorithm = (chunk)=>transformer.transform(chunk, controller);\n                }\n                if (transformer.flush !== undefined) {\n                    flushAlgorithm = ()=>transformer.flush(controller);\n                }\n                SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n            }\n            function TransformStreamDefaultControllerClearAlgorithms(controller) {\n                controller._transformAlgorithm = undefined;\n                controller._flushAlgorithm = undefined;\n            }\n            function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n                const stream = controller._controlledTransformStream;\n                const readableController = stream._readable._readableStreamController;\n                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n                    throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n                }\n                // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n                // accept TransformStreamDefaultControllerEnqueue() calls.\n                try {\n                    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n                } catch (e) {\n                    // This happens when readableStrategy.size() throws.\n                    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n                    throw stream._readable._storedError;\n                }\n                const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n                if (backpressure !== stream._backpressure) {\n                    TransformStreamSetBackpressure(stream, true);\n                }\n            }\n            function TransformStreamDefaultControllerError(controller, e) {\n                TransformStreamError(controller._controlledTransformStream, e);\n            }\n            function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n                const transformPromise = controller._transformAlgorithm(chunk);\n                return transformPromiseWith(transformPromise, undefined, (r)=>{\n                    TransformStreamError(controller._controlledTransformStream, r);\n                    throw r;\n                });\n            }\n            function TransformStreamDefaultControllerTerminate(controller) {\n                const stream = controller._controlledTransformStream;\n                const readableController = stream._readable._readableStreamController;\n                ReadableStreamDefaultControllerClose(readableController);\n                const error = new TypeError(\"TransformStream terminated\");\n                TransformStreamErrorWritableAndUnblockWrite(stream, error);\n            }\n            // TransformStreamDefaultSink Algorithms\n            function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n                const controller = stream._transformStreamController;\n                if (stream._backpressure) {\n                    const backpressureChangePromise = stream._backpressureChangePromise;\n                    return transformPromiseWith(backpressureChangePromise, ()=>{\n                        const writable = stream._writable;\n                        const state = writable._state;\n                        if (state === \"erroring\") {\n                            throw writable._storedError;\n                        }\n                        return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n                    });\n                }\n                return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n            }\n            function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n                // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n                // errored.\n                TransformStreamError(stream, reason);\n                return promiseResolvedWith(undefined);\n            }\n            function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n                // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n                const readable = stream._readable;\n                const controller = stream._transformStreamController;\n                const flushPromise = controller._flushAlgorithm();\n                TransformStreamDefaultControllerClearAlgorithms(controller);\n                // Return a promise that is fulfilled with undefined on success.\n                return transformPromiseWith(flushPromise, ()=>{\n                    if (readable._state === \"errored\") {\n                        throw readable._storedError;\n                    }\n                    ReadableStreamDefaultControllerClose(readable._readableStreamController);\n                }, (r)=>{\n                    TransformStreamError(stream, r);\n                    throw readable._storedError;\n                });\n            }\n            // TransformStreamDefaultSource Algorithms\n            function TransformStreamDefaultSourcePullAlgorithm(stream) {\n                // Invariant. Enforced by the promises returned by start() and pull().\n                TransformStreamSetBackpressure(stream, false);\n                // Prevent the next pull() call until there is backpressure.\n                return stream._backpressureChangePromise;\n            }\n            // Helper functions for the TransformStreamDefaultController.\n            function defaultControllerBrandCheckException(name) {\n                return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n            }\n            // Helper functions for the TransformStream.\n            function streamBrandCheckException(name) {\n                return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n            }\n            exports1.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n            exports1.CountQueuingStrategy = CountQueuingStrategy;\n            exports1.ReadableByteStreamController = ReadableByteStreamController;\n            exports1.ReadableStream = ReadableStream1;\n            exports1.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n            exports1.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n            exports1.ReadableStreamDefaultController = ReadableStreamDefaultController;\n            exports1.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n            exports1.TransformStream = TransformStream;\n            exports1.TransformStreamDefaultController = TransformStreamDefaultController;\n            exports1.WritableStream = WritableStream;\n            exports1.WritableStreamDefaultController = WritableStreamDefaultController;\n            exports1.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        });\n    })(ponyfill_es2018, ponyfill_es2018.exports);\n    return ponyfill_es2018.exports;\n}\n/* c8 ignore start */ // 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE$1 = 65536;\nif (!globalThis.ReadableStream) {\n    // `node:stream/web` got introduced in v16.5.0 as experimental\n    // and it's preferred over the polyfilled version. So we also\n    // suppress the warning that gets emitted by NodeJS for using it.\n    try {\n        const process1 = __webpack_require__(/*! node:process */ \"node:process\");\n        const { emitWarning } = process1;\n        try {\n            process1.emitWarning = ()=>{};\n            Object.assign(globalThis, __webpack_require__(/*! node:stream/web */ \"node:stream/web\"));\n            process1.emitWarning = emitWarning;\n        } catch (error) {\n            process1.emitWarning = emitWarning;\n            throw error;\n        }\n    } catch (error) {\n        // fallback to polyfill implementation\n        Object.assign(globalThis, requirePonyfill_es2018());\n    }\n}\ntry {\n    // Don't use node: prefix for this, require+node: is not supported until node v14.14\n    // Only `import()` can use prefix in 12.20 and later\n    const { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\n    if (Blob && !Blob.prototype.stream) {\n        Blob.prototype.stream = function name(params) {\n            let position = 0;\n            const blob = this;\n            return new ReadableStream({\n                type: \"bytes\",\n                async pull (ctrl) {\n                    const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));\n                    const buffer = await chunk.arrayBuffer();\n                    position += buffer.byteLength;\n                    ctrl.enqueue(new Uint8Array(buffer));\n                    if (position === blob.size) {\n                        ctrl.close();\n                    }\n                }\n            });\n        };\n    }\n} catch (error) {}\n/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */ // 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536;\n/** @param {(Blob | Uint8Array)[]} parts */ async function* toIterator(parts, clone = true) {\n    for (const part of parts){\n        if (\"stream\" in part) {\n            yield* /** @type {AsyncIterableIterator<Uint8Array>} */ part.stream();\n        } else if (ArrayBuffer.isView(part)) {\n            if (clone) {\n                let position = part.byteOffset;\n                const end = part.byteOffset + part.byteLength;\n                while(position !== end){\n                    const size = Math.min(end - position, POOL_SIZE);\n                    const chunk = part.buffer.slice(position, position + size);\n                    position += chunk.byteLength;\n                    yield new Uint8Array(chunk);\n                }\n            } else {\n                yield part;\n            }\n        /* c8 ignore next 10 */ } else {\n            // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n            let position = 0, b = /** @type {Blob} */ part;\n            while(position !== b.size){\n                const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));\n                const buffer = await chunk.arrayBuffer();\n                position += buffer.byteLength;\n                yield new Uint8Array(buffer);\n            }\n        }\n    }\n}\nconst _Blob = class Blob {\n    /** @type {Array.<(Blob|Uint8Array)>} */ #parts;\n    #type;\n    #size;\n    #endings;\n    /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */ constructor(blobParts = [], options = {}){\n        this.#parts = [];\n        this.#type = \"\";\n        this.#size = 0;\n        this.#endings = \"transparent\";\n        if (typeof blobParts !== \"object\" || blobParts === null) {\n            throw new TypeError(\"Failed to construct 'Blob': The provided value cannot be converted to a sequence.\");\n        }\n        if (typeof blobParts[Symbol.iterator] !== \"function\") {\n            throw new TypeError(\"Failed to construct 'Blob': The object must have a callable @@iterator property.\");\n        }\n        if (typeof options !== \"object\" && typeof options !== \"function\") {\n            throw new TypeError(\"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\");\n        }\n        if (options === null) options = {};\n        const encoder = new TextEncoder();\n        for (const element of blobParts){\n            let part;\n            if (ArrayBuffer.isView(element)) {\n                part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n            } else if (element instanceof ArrayBuffer) {\n                part = new Uint8Array(element.slice(0));\n            } else if (element instanceof Blob) {\n                part = element;\n            } else {\n                part = encoder.encode(`${element}`);\n            }\n            const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n            // Avoid pushing empty parts into the array to better GC them\n            if (size) {\n                this.#size += size;\n                this.#parts.push(part);\n            }\n        }\n        this.#endings = `${options.endings === undefined ? \"transparent\" : options.endings}`;\n        const type = options.type === undefined ? \"\" : String(options.type);\n        this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : \"\";\n    }\n    /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */ get size() {\n        return this.#size;\n    }\n    /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */ get type() {\n        return this.#type;\n    }\n    /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */ async text() {\n        // More optimized than using this.arrayBuffer()\n        // that requires twice as much ram\n        const decoder = new TextDecoder();\n        let str = \"\";\n        for await (const part of toIterator(this.#parts, false)){\n            str += decoder.decode(part, {\n                stream: true\n            });\n        }\n        // Remaining\n        str += decoder.decode();\n        return str;\n    }\n    /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */ async arrayBuffer() {\n        // Easier way... Just a unnecessary overhead\n        // const view = new Uint8Array(this.size);\n        // await this.stream().getReader({mode: 'byob'}).read(view);\n        // return view.buffer;\n        const data = new Uint8Array(this.size);\n        let offset = 0;\n        for await (const chunk of toIterator(this.#parts, false)){\n            data.set(chunk, offset);\n            offset += chunk.length;\n        }\n        return data.buffer;\n    }\n    stream() {\n        const it = toIterator(this.#parts, true);\n        return new globalThis.ReadableStream({\n            // @ts-ignore\n            type: \"bytes\",\n            async pull (ctrl) {\n                const chunk = await it.next();\n                chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n            },\n            async cancel () {\n                await it.return();\n            }\n        });\n    }\n    /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */ slice(start = 0, end = this.size, type = \"\") {\n        const { size } = this;\n        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n        const span = Math.max(relativeEnd - relativeStart, 0);\n        const parts = this.#parts;\n        const blobParts = [];\n        let added = 0;\n        for (const part of parts){\n            // don't add the overflow to new blobParts\n            if (added >= span) {\n                break;\n            }\n            const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n            if (relativeStart && size <= relativeStart) {\n                // Skip the beginning and change the relative\n                // start & end position as we skip the unwanted parts\n                relativeStart -= size;\n                relativeEnd -= size;\n            } else {\n                let chunk;\n                if (ArrayBuffer.isView(part)) {\n                    chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));\n                    added += chunk.byteLength;\n                } else {\n                    chunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n                    added += chunk.size;\n                }\n                relativeEnd -= size;\n                blobParts.push(chunk);\n                relativeStart = 0; // All next sequential parts should start at 0\n            }\n        }\n        const blob = new Blob([], {\n            type: String(type).toLowerCase()\n        });\n        blob.#size = span;\n        blob.#parts = blobParts;\n        return blob;\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n    static [Symbol.hasInstance](object) {\n        return object && typeof object === \"object\" && typeof object.constructor === \"function\" && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n    }\n};\nObject.defineProperties(_Blob.prototype, {\n    size: {\n        enumerable: true\n    },\n    type: {\n        enumerable: true\n    },\n    slice: {\n        enumerable: true\n    }\n});\n/** @type {typeof globalThis.Blob} */ const Blob = _Blob;\nconst _Blob$1 = Blob;\nconst _File = class File extends _Blob$1 {\n    #lastModified;\n    #name;\n    /**\n   * @param {*[]} fileBits\n   * @param {string} fileName\n   * @param {{lastModified?: number, type?: string}} options\n   */ // @ts-ignore\n    constructor(fileBits, fileName, options = {}){\n        if (arguments.length < 2) {\n            throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);\n        }\n        super(fileBits, options);\n        this.#lastModified = 0;\n        this.#name = \"\";\n        if (options === null) options = {};\n        // Simulate WebIDL type casting for NaN value in lastModified option.\n        const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified);\n        if (!Number.isNaN(lastModified)) {\n            this.#lastModified = lastModified;\n        }\n        this.#name = String(fileName);\n    }\n    get name() {\n        return this.#name;\n    }\n    get lastModified() {\n        return this.#lastModified;\n    }\n    get [Symbol.toStringTag]() {\n        return \"File\";\n    }\n    static [Symbol.hasInstance](object) {\n        return !!object && object instanceof _Blob$1 && /^(File)$/.test(object[Symbol.toStringTag]);\n    }\n};\n/** @type {typeof globalThis.File} */ // @ts-ignore\nconst File = _File;\nconst File$1 = File;\n/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */ var { toStringTag: t, iterator: i, hasInstance: h } = Symbol, r = Math.random, m = \"append,set,get,getAll,delete,keys,values,entries,forEach,constructor\".split(\",\"), f = (a, b, c)=>(a += \"\", /^(Blob|File)$/.test(b && b[t]) ? [\n        (c = c !== void 0 ? c + \"\" : b[t] == \"File\" ? b.name : \"blob\", a),\n        b.name !== c || b[t] == \"blob\" ? new File$1([\n            b\n        ], c, b) : b\n    ] : [\n        a,\n        b + \"\"\n    ]), e = (c, f)=>(f ? c : c.replace(/\\r?\\n|\\r/g, \"\\r\\n\")).replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\"), x = (n, a, e)=>{\n    if (a.length < e) {\n        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`);\n    }\n};\n/** @type {typeof globalThis.FormData} */ const FormData = class FormData {\n    #d;\n    constructor(...a){\n        this.#d = [];\n        if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);\n    }\n    get [t]() {\n        return \"FormData\";\n    }\n    [i]() {\n        return this.entries();\n    }\n    static [h](o) {\n        return o && typeof o === \"object\" && o[t] === \"FormData\" && !m.some((m)=>typeof o[m] != \"function\");\n    }\n    append(...a) {\n        x(\"append\", arguments, 2);\n        this.#d.push(f(...a));\n    }\n    delete(a) {\n        x(\"delete\", arguments, 1);\n        a += \"\";\n        this.#d = this.#d.filter(([b])=>b !== a);\n    }\n    get(a) {\n        x(\"get\", arguments, 1);\n        a += \"\";\n        for(var b = this.#d, l = b.length, c = 0; c < l; c++)if (b[c][0] === a) return b[c][1];\n        return null;\n    }\n    getAll(a, b) {\n        x(\"getAll\", arguments, 1);\n        b = [];\n        a += \"\";\n        this.#d.forEach((c)=>c[0] === a && b.push(c[1]));\n        return b;\n    }\n    has(a) {\n        x(\"has\", arguments, 1);\n        a += \"\";\n        return this.#d.some((b)=>b[0] === a);\n    }\n    forEach(a, b) {\n        x(\"forEach\", arguments, 1);\n        for (var [c, d] of this)a.call(b, d, c, this);\n    }\n    set(...a) {\n        x(\"set\", arguments, 2);\n        var b = [], c = !0;\n        a = f(...a);\n        this.#d.forEach((d)=>{\n            d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);\n        });\n        c && b.push(a);\n        this.#d = b;\n    }\n    *entries() {\n        yield* this.#d;\n    }\n    *keys() {\n        for (var [a] of this)yield a;\n    }\n    *values() {\n        for (var [, a] of this)yield a;\n    }\n};\n/** @param {FormData} F */ function formDataToBlob(F, B = _Blob$1) {\n    var b = `${r()}${r()}`.replace(/\\./g, \"\").slice(-28).padStart(32, \"-\"), c = [], p = `--${b}\\r\\nContent-Disposition: form-data; name=\"`;\n    F.forEach((v, n)=>typeof v == \"string\" ? c.push(p + e(n) + `\"\\r\\n\\r\\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, \"\\r\\n\")}\\r\\n`) : c.push(p + e(n) + `\"; filename=\"${e(v.name, 1)}\"\\r\\nContent-Type: ${v.type || \"application/octet-stream\"}\\r\\n\\r\\n`, v, \"\\r\\n\"));\n    c.push(`--${b}--`);\n    return new B(c, {\n        type: \"multipart/form-data; boundary=\" + b\n    });\n}\nclass FetchBaseError extends Error {\n    constructor(message, type){\n        super(message);\n        // Hide custom error implementation details from end-users\n        Error.captureStackTrace(this, this.constructor);\n        this.type = type;\n    }\n    get name() {\n        return this.constructor.name;\n    }\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n/**\n * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError\n*/ /**\n * FetchError interface for operational errors\n */ class FetchError extends FetchBaseError {\n    /**\n\t * @param  {string} message -      Error message for human\n\t * @param  {string} [type] -        Error type for machine\n\t * @param  {SystemError} [systemError] - For Node.js system error\n\t */ constructor(message, type, systemError){\n        super(message, type);\n        // When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code\n        if (systemError) {\n            // eslint-disable-next-line no-multi-assign\n            this.code = this.errno = systemError.code;\n            this.erroredSysCall = systemError.syscall;\n        }\n    }\n}\n/**\n * Is.js\n *\n * Object type checks.\n */ const NAME = Symbol.toStringTag;\n/**\n * Check if `obj` is a URLSearchParams object\n * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143\n * @param {*} object - Object to check for\n * @return {boolean}\n */ const isURLSearchParameters = (object)=>{\n    return typeof object === \"object\" && typeof object.append === \"function\" && typeof object.delete === \"function\" && typeof object.get === \"function\" && typeof object.getAll === \"function\" && typeof object.has === \"function\" && typeof object.set === \"function\" && typeof object.sort === \"function\" && object[NAME] === \"URLSearchParams\";\n};\n/**\n * Check if `object` is a W3C `Blob` object (which `File` inherits from)\n * @param {*} object - Object to check for\n * @return {boolean}\n */ const isBlob = (object)=>{\n    return object && typeof object === \"object\" && typeof object.arrayBuffer === \"function\" && typeof object.type === \"string\" && typeof object.stream === \"function\" && typeof object.constructor === \"function\" && /^(Blob|File)$/.test(object[NAME]);\n};\n/**\n * Check if `obj` is an instance of AbortSignal.\n * @param {*} object - Object to check for\n * @return {boolean}\n */ const isAbortSignal = (object)=>{\n    return typeof object === \"object\" && (object[NAME] === \"AbortSignal\" || object[NAME] === \"EventTarget\");\n};\n/**\n * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of\n * the parent domain.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */ const isDomainOrSubdomain = (destination, original)=>{\n    const orig = new URL(original).hostname;\n    const dest = new URL(destination).hostname;\n    return orig === dest || orig.endsWith(`.${dest}`);\n};\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */ const isSameProtocol = (destination, original)=>{\n    const orig = new URL(original).protocol;\n    const dest = new URL(destination).protocol;\n    return orig === dest;\n};\nconst pipeline = node_util.promisify(Stream.pipeline);\nconst INTERNALS$2 = Symbol(\"Body internals\");\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ class Body {\n    constructor(body, { size = 0 } = {}){\n        let boundary = null;\n        if (body === null) {\n            // Body is undefined or null\n            body = null;\n        } else if (isURLSearchParameters(body)) {\n            // Body is a URLSearchParams\n            body = node_buffer.Buffer.from(body.toString());\n        } else if (isBlob(body)) ;\n        else if (node_buffer.Buffer.isBuffer(body)) ;\n        else if (node_util.types.isAnyArrayBuffer(body)) {\n            // Body is ArrayBuffer\n            body = node_buffer.Buffer.from(body);\n        } else if (ArrayBuffer.isView(body)) {\n            // Body is ArrayBufferView\n            body = node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n        } else if (body instanceof Stream) ;\n        else if (body instanceof FormData) {\n            // Body is FormData\n            body = formDataToBlob(body);\n            boundary = body.type.split(\"=\")[1];\n        } else {\n            // None of the above\n            // coerce to string then buffer\n            body = node_buffer.Buffer.from(String(body));\n        }\n        let stream = body;\n        if (node_buffer.Buffer.isBuffer(body)) {\n            stream = Stream.Readable.from(body);\n        } else if (isBlob(body)) {\n            stream = Stream.Readable.from(body.stream());\n        }\n        this[INTERNALS$2] = {\n            body,\n            stream,\n            boundary,\n            disturbed: false,\n            error: null\n        };\n        this.size = size;\n        if (body instanceof Stream) {\n            body.on(\"error\", (error_)=>{\n                const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, \"system\", error_);\n                this[INTERNALS$2].error = error;\n            });\n        }\n    }\n    get body() {\n        return this[INTERNALS$2].stream;\n    }\n    get bodyUsed() {\n        return this[INTERNALS$2].disturbed;\n    }\n    /**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */ async arrayBuffer() {\n        const { buffer, byteOffset, byteLength } = await consumeBody(this);\n        return buffer.slice(byteOffset, byteOffset + byteLength);\n    }\n    async formData() {\n        const ct = this.headers.get(\"content-type\");\n        if (ct.startsWith(\"application/x-www-form-urlencoded\")) {\n            const formData = new FormData();\n            const parameters = new URLSearchParams(await this.text());\n            for (const [name, value1] of parameters){\n                formData.append(name, value1);\n            }\n            return formData;\n        }\n        const { toFormData } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../chunks/multipart-parser.cjs */ \"(ssr)/./node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs\")));\n        return toFormData(this.body, ct);\n    }\n    /**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */ async blob() {\n        const ct = this.headers && this.headers.get(\"content-type\") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || \"\";\n        const buf = await this.arrayBuffer();\n        return new _Blob$1([\n            buf\n        ], {\n            type: ct\n        });\n    }\n    /**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */ async json() {\n        const text = await this.text();\n        return JSON.parse(text);\n    }\n    /**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */ async text() {\n        const buffer = await consumeBody(this);\n        return new TextDecoder().decode(buffer);\n    }\n    /**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */ buffer() {\n        return consumeBody(this);\n    }\n}\nBody.prototype.buffer = node_util.deprecate(Body.prototype.buffer, \"Please use 'response.arrayBuffer()' instead of 'response.buffer()'\", \"node-fetch#buffer\");\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n    body: {\n        enumerable: true\n    },\n    bodyUsed: {\n        enumerable: true\n    },\n    arrayBuffer: {\n        enumerable: true\n    },\n    blob: {\n        enumerable: true\n    },\n    json: {\n        enumerable: true\n    },\n    text: {\n        enumerable: true\n    },\n    data: {\n        get: node_util.deprecate(()=>{}, \"data doesn't exist, use json(), text(), arrayBuffer(), or body instead\", \"https://github.com/node-fetch/node-fetch/issues/1000 (response)\")\n    }\n});\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */ async function consumeBody(data) {\n    if (data[INTERNALS$2].disturbed) {\n        throw new TypeError(`body used already for: ${data.url}`);\n    }\n    data[INTERNALS$2].disturbed = true;\n    if (data[INTERNALS$2].error) {\n        throw data[INTERNALS$2].error;\n    }\n    const { body } = data;\n    // Body is null\n    if (body === null) {\n        return node_buffer.Buffer.alloc(0);\n    }\n    /* c8 ignore next 3 */ if (!(body instanceof Stream)) {\n        return node_buffer.Buffer.alloc(0);\n    }\n    // Body is stream\n    // get ready to actually consume the body\n    const accum = [];\n    let accumBytes = 0;\n    try {\n        for await (const chunk of body){\n            if (data.size > 0 && accumBytes + chunk.length > data.size) {\n                const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, \"max-size\");\n                body.destroy(error);\n                throw error;\n            }\n            accumBytes += chunk.length;\n            accum.push(chunk);\n        }\n    } catch (error) {\n        const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, \"system\", error);\n        throw error_;\n    }\n    if (body.readableEnded === true || body._readableState.ended === true) {\n        try {\n            if (accum.every((c)=>typeof c === \"string\")) {\n                return node_buffer.Buffer.from(accum.join(\"\"));\n            }\n            return node_buffer.Buffer.concat(accum, accumBytes);\n        } catch (error) {\n            throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, \"system\", error);\n        }\n    } else {\n        throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n    }\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */ const clone = (instance, highWaterMark)=>{\n    let p1;\n    let p2;\n    let { body } = instance[INTERNALS$2];\n    // Don't allow cloning a used body\n    if (instance.bodyUsed) {\n        throw new Error(\"cannot clone body after it is used\");\n    }\n    // Check that body is a stream and not form-data object\n    // note: we can't clone the form-data object without having it as a dependency\n    if (body instanceof Stream && typeof body.getBoundary !== \"function\") {\n        // Tee instance body\n        p1 = new Stream.PassThrough({\n            highWaterMark\n        });\n        p2 = new Stream.PassThrough({\n            highWaterMark\n        });\n        body.pipe(p1);\n        body.pipe(p2);\n        // Set instance body to teed body and return the other teed body\n        instance[INTERNALS$2].stream = p1;\n        body = p2;\n    }\n    return body;\n};\nconst getNonSpecFormDataBoundary = node_util.deprecate((body)=>body.getBoundary(), \"form-data doesn't follow the spec and requires special treatment. Use alternative package\", \"https://github.com/node-fetch/node-fetch/issues/1167\");\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */ const extractContentType = (body, request)=>{\n    // Body is null or undefined\n    if (body === null) {\n        return null;\n    }\n    // Body is string\n    if (typeof body === \"string\") {\n        return \"text/plain;charset=UTF-8\";\n    }\n    // Body is a URLSearchParams\n    if (isURLSearchParameters(body)) {\n        return \"application/x-www-form-urlencoded;charset=UTF-8\";\n    }\n    // Body is blob\n    if (isBlob(body)) {\n        return body.type || null;\n    }\n    // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n    if (node_buffer.Buffer.isBuffer(body) || node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n        return null;\n    }\n    if (body instanceof FormData) {\n        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;\n    }\n    // Detect form data input from form-data module\n    if (body && typeof body.getBoundary === \"function\") {\n        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n    }\n    // Body is stream - can't really do much about this\n    if (body instanceof Stream) {\n        return null;\n    }\n    // Body constructor defaults other things to string\n    return \"text/plain;charset=UTF-8\";\n};\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */ const getTotalBytes = (request)=>{\n    const { body } = request[INTERNALS$2];\n    // Body is null or undefined\n    if (body === null) {\n        return 0;\n    }\n    // Body is Blob\n    if (isBlob(body)) {\n        return body.size;\n    }\n    // Body is Buffer\n    if (node_buffer.Buffer.isBuffer(body)) {\n        return body.length;\n    }\n    // Detect form data input from form-data module\n    if (body && typeof body.getLengthSync === \"function\") {\n        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n    }\n    // Body is stream\n    return null;\n};\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */ const writeToStream = async (dest, { body })=>{\n    if (body === null) {\n        // Body is null\n        dest.end();\n    } else {\n        // Body is stream\n        await pipeline(body, dest);\n    }\n};\n/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */ /* c8 ignore next 9 */ const validateHeaderName = typeof http.validateHeaderName === \"function\" ? http.validateHeaderName : (name)=>{\n    if (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n        const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n        Object.defineProperty(error, \"code\", {\n            value: \"ERR_INVALID_HTTP_TOKEN\"\n        });\n        throw error;\n    }\n};\n/* c8 ignore next 9 */ const validateHeaderValue = typeof http.validateHeaderValue === \"function\" ? http.validateHeaderValue : (name, value1)=>{\n    if (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value1)) {\n        const error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n        Object.defineProperty(error, \"code\", {\n            value: \"ERR_INVALID_CHAR\"\n        });\n        throw error;\n    }\n};\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */ /**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */ class Headers extends URLSearchParams {\n    /**\n\t * Headers class\n\t *\n\t * @constructor\n\t * @param {HeadersInit} [init] - Response headers\n\t */ constructor(init){\n        // Validate and normalize init object in [name, value(s)][]\n        /** @type {string[][]} */ let result = [];\n        if (init instanceof Headers) {\n            const raw = init.raw();\n            for (const [name, values] of Object.entries(raw)){\n                result.push(...values.map((value1)=>[\n                        name,\n                        value1\n                    ]));\n            }\n        } else if (init == null) ;\n        else if (typeof init === \"object\" && !node_util.types.isBoxedPrimitive(init)) {\n            const method = init[Symbol.iterator];\n            // eslint-disable-next-line no-eq-null, eqeqeq\n            if (method == null) {\n                // Record<ByteString, ByteString>\n                result.push(...Object.entries(init));\n            } else {\n                if (typeof method !== \"function\") {\n                    throw new TypeError(\"Header pairs must be iterable\");\n                }\n                // Sequence<sequence<ByteString>>\n                // Note: per spec we have to first exhaust the lists then process them\n                result = [\n                    ...init\n                ].map((pair)=>{\n                    if (typeof pair !== \"object\" || node_util.types.isBoxedPrimitive(pair)) {\n                        throw new TypeError(\"Each header pair must be an iterable object\");\n                    }\n                    return [\n                        ...pair\n                    ];\n                }).map((pair)=>{\n                    if (pair.length !== 2) {\n                        throw new TypeError(\"Each header pair must be a name/value tuple\");\n                    }\n                    return [\n                        ...pair\n                    ];\n                });\n            }\n        } else {\n            throw new TypeError(\"Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)\");\n        }\n        // Validate and lowercase\n        result = result.length > 0 ? result.map(([name, value1])=>{\n            validateHeaderName(name);\n            validateHeaderValue(name, String(value1));\n            return [\n                String(name).toLowerCase(),\n                String(value1)\n            ];\n        }) : undefined;\n        super(result);\n        // Returning a Proxy that will lowercase key names, validate parameters and sort keys\n        // eslint-disable-next-line no-constructor-return\n        return new Proxy(this, {\n            get (target, p, receiver) {\n                switch(p){\n                    case \"append\":\n                    case \"set\":\n                        return (name, value1)=>{\n                            validateHeaderName(name);\n                            validateHeaderValue(name, String(value1));\n                            return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value1));\n                        };\n                    case \"delete\":\n                    case \"has\":\n                    case \"getAll\":\n                        return (name)=>{\n                            validateHeaderName(name);\n                            return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());\n                        };\n                    case \"keys\":\n                        return ()=>{\n                            target.sort();\n                            return new Set(URLSearchParams.prototype.keys.call(target)).keys();\n                        };\n                    default:\n                        return Reflect.get(target, p, receiver);\n                }\n            }\n        });\n    /* c8 ignore next */ }\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n    toString() {\n        return Object.prototype.toString.call(this);\n    }\n    get(name) {\n        const values = this.getAll(name);\n        if (values.length === 0) {\n            return null;\n        }\n        let value1 = values.join(\", \");\n        if (/^content-encoding$/i.test(name)) {\n            value1 = value1.toLowerCase();\n        }\n        return value1;\n    }\n    forEach(callback, thisArg = undefined) {\n        for (const name of this.keys()){\n            Reflect.apply(callback, thisArg, [\n                this.get(name),\n                name,\n                this\n            ]);\n        }\n    }\n    *values() {\n        for (const name of this.keys()){\n            yield this.get(name);\n        }\n    }\n    /**\n\t * @type {() => IterableIterator<[string, string]>}\n\t */ *entries() {\n        for (const name of this.keys()){\n            yield [\n                name,\n                this.get(name)\n            ];\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n\t * Node-fetch non-spec method\n\t * returning all headers and their values as array\n\t * @returns {Record<string, string[]>}\n\t */ raw() {\n        return [\n            ...this.keys()\n        ].reduce((result, key)=>{\n            result[key] = this.getAll(key);\n            return result;\n        }, {});\n    }\n    /**\n\t * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n\t */ [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return [\n            ...this.keys()\n        ].reduce((result, key)=>{\n            const values = this.getAll(key);\n            // Http.request() only supports string as Host header.\n            // This hack makes specifying custom Host header possible.\n            if (key === \"host\") {\n                result[key] = values[0];\n            } else {\n                result[key] = values.length > 1 ? values : values[0];\n            }\n            return result;\n        }, {});\n    }\n}\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */ Object.defineProperties(Headers.prototype, [\n    \"get\",\n    \"entries\",\n    \"forEach\",\n    \"values\"\n].reduce((result, property)=>{\n    result[property] = {\n        enumerable: true\n    };\n    return result;\n}, {}));\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */ function fromRawHeaders(headers = []) {\n    return new Headers(headers// Split into pairs\n    .reduce((result, value1, index, array)=>{\n        if (index % 2 === 0) {\n            result.push(array.slice(index, index + 2));\n        }\n        return result;\n    }, []).filter(([name, value1])=>{\n        try {\n            validateHeaderName(name);\n            validateHeaderValue(name, String(value1));\n            return true;\n        } catch  {\n            return false;\n        }\n    }));\n}\nconst redirectStatus = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\n/**\n * Redirect code matching\n *\n * @param {number} code - Status code\n * @return {boolean}\n */ const isRedirect = (code)=>{\n    return redirectStatus.has(code);\n};\n/**\n * Response.js\n *\n * Response class provides content decoding\n */ const INTERNALS$1 = Symbol(\"Response internals\");\n/**\n * Response class\n *\n * Ref: https://fetch.spec.whatwg.org/#response-class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ class Response extends Body {\n    constructor(body = null, options = {}){\n        super(body, options);\n        // eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition\n        const status = options.status != null ? options.status : 200;\n        const headers = new Headers(options.headers);\n        if (body !== null && !headers.has(\"Content-Type\")) {\n            const contentType = extractContentType(body, this);\n            if (contentType) {\n                headers.append(\"Content-Type\", contentType);\n            }\n        }\n        this[INTERNALS$1] = {\n            type: \"default\",\n            url: options.url,\n            status,\n            statusText: options.statusText || \"\",\n            headers,\n            counter: options.counter,\n            highWaterMark: options.highWaterMark\n        };\n    }\n    get type() {\n        return this[INTERNALS$1].type;\n    }\n    get url() {\n        return this[INTERNALS$1].url || \"\";\n    }\n    get status() {\n        return this[INTERNALS$1].status;\n    }\n    /**\n\t * Convenience property representing if the request ended normally\n\t */ get ok() {\n        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n    }\n    get redirected() {\n        return this[INTERNALS$1].counter > 0;\n    }\n    get statusText() {\n        return this[INTERNALS$1].statusText;\n    }\n    get headers() {\n        return this[INTERNALS$1].headers;\n    }\n    get highWaterMark() {\n        return this[INTERNALS$1].highWaterMark;\n    }\n    /**\n\t * Clone this response\n\t *\n\t * @return  Response\n\t */ clone() {\n        return new Response(clone(this, this.highWaterMark), {\n            type: this.type,\n            url: this.url,\n            status: this.status,\n            statusText: this.statusText,\n            headers: this.headers,\n            ok: this.ok,\n            redirected: this.redirected,\n            size: this.size,\n            highWaterMark: this.highWaterMark\n        });\n    }\n    /**\n\t * @param {string} url    The URL that the new response is to originate from.\n\t * @param {number} status An optional status code for the response (e.g., 302.)\n\t * @returns {Response}    A Response object.\n\t */ static redirect(url, status = 302) {\n        if (!isRedirect(status)) {\n            throw new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n        }\n        return new Response(null, {\n            headers: {\n                location: new URL(url).toString()\n            },\n            status\n        });\n    }\n    static error() {\n        const response = new Response(null, {\n            status: 0,\n            statusText: \"\"\n        });\n        response[INTERNALS$1].type = \"error\";\n        return response;\n    }\n    static json(data = undefined, init = {}) {\n        const body = JSON.stringify(data);\n        if (body === undefined) {\n            throw new TypeError(\"data is not JSON serializable\");\n        }\n        const headers = new Headers(init && init.headers);\n        if (!headers.has(\"content-type\")) {\n            headers.set(\"content-type\", \"application/json\");\n        }\n        return new Response(body, {\n            ...init,\n            headers\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Response\";\n    }\n}\nObject.defineProperties(Response.prototype, {\n    type: {\n        enumerable: true\n    },\n    url: {\n        enumerable: true\n    },\n    status: {\n        enumerable: true\n    },\n    ok: {\n        enumerable: true\n    },\n    redirected: {\n        enumerable: true\n    },\n    statusText: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    }\n});\nconst getSearch = (parsedURL)=>{\n    if (parsedURL.search) {\n        return parsedURL.search;\n    }\n    const lastOffset = parsedURL.href.length - 1;\n    const hash = parsedURL.hash || (parsedURL.href[lastOffset] === \"#\" ? \"#\" : \"\");\n    return parsedURL.href[lastOffset - hash.length] === \"?\" ? \"?\" : \"\";\n};\n/**\n * @external URL\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}\n */ /**\n * @module utils/referrer\n * @private\n */ /**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy 8.4. Strip url for use as a referrer}\n * @param {string} URL\n * @param {boolean} [originOnly=false]\n */ function stripURLForUseAsAReferrer(url, originOnly = false) {\n    // 1. If url is null, return no referrer.\n    if (url == null) {\n        return \"no-referrer\";\n    }\n    url = new URL(url);\n    // 2. If url's scheme is a local scheme, then return no referrer.\n    if (/^(about|blob|data):$/.test(url.protocol)) {\n        return \"no-referrer\";\n    }\n    // 3. Set url's username to the empty string.\n    url.username = \"\";\n    // 4. Set url's password to null.\n    // Note: `null` appears to be a mistake as this actually results in the password being `\"null\"`.\n    url.password = \"\";\n    // 5. Set url's fragment to null.\n    // Note: `null` appears to be a mistake as this actually results in the fragment being `\"#null\"`.\n    url.hash = \"\";\n    // 6. If the origin-only flag is true, then:\n    if (originOnly) {\n        // 6.1. Set url's path to null.\n        // Note: `null` appears to be a mistake as this actually results in the path being `\"/null\"`.\n        url.pathname = \"\";\n        // 6.2. Set url's query to null.\n        // Note: `null` appears to be a mistake as this actually results in the query being `\"?null\"`.\n        url.search = \"\";\n    }\n    // 7. Return url.\n    return url;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}\n */ const ReferrerPolicy = new Set([\n    \"\",\n    \"no-referrer\",\n    \"no-referrer-when-downgrade\",\n    \"same-origin\",\n    \"origin\",\n    \"strict-origin\",\n    \"origin-when-cross-origin\",\n    \"strict-origin-when-cross-origin\",\n    \"unsafe-url\"\n]);\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}\n */ const DEFAULT_REFERRER_POLICY = \"strict-origin-when-cross-origin\";\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy 3. Referrer Policies}\n * @param {string} referrerPolicy\n * @returns {string} referrerPolicy\n */ function validateReferrerPolicy(referrerPolicy) {\n    if (!ReferrerPolicy.has(referrerPolicy)) {\n        throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n    }\n    return referrerPolicy;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy 3.2. Is origin potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */ function isOriginPotentiallyTrustworthy(url) {\n    // 1. If origin is an opaque origin, return \"Not Trustworthy\".\n    // Not applicable\n    // 2. Assert: origin is a tuple origin.\n    // Not for implementations\n    // 3. If origin's scheme is either \"https\" or \"wss\", return \"Potentially Trustworthy\".\n    if (/^(http|ws)s:$/.test(url.protocol)) {\n        return true;\n    }\n    // 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n    const hostIp = url.host.replace(/(^\\[)|(]$)/g, \"\");\n    const hostIPVersion = node_net.isIP(hostIp);\n    if (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n        return true;\n    }\n    if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n        return true;\n    }\n    // 5. If origin's host component is \"localhost\" or falls within \".localhost\", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return \"Potentially Trustworthy\".\n    // We are returning FALSE here because we cannot ensure conformance to\n    // let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)\n    if (url.host === \"localhost\" || url.host.endsWith(\".localhost\")) {\n        return false;\n    }\n    // 6. If origin's scheme component is file, return \"Potentially Trustworthy\".\n    if (url.protocol === \"file:\") {\n        return true;\n    }\n    // 7. If origin's scheme component is one which the user agent considers to be authenticated, return \"Potentially Trustworthy\".\n    // Not supported\n    // 8. If origin has been configured as a trustworthy origin, return \"Potentially Trustworthy\".\n    // Not supported\n    // 9. Return \"Not Trustworthy\".\n    return false;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy 3.3. Is url potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */ function isUrlPotentiallyTrustworthy(url) {\n    // 1. If url is \"about:blank\" or \"about:srcdoc\", return \"Potentially Trustworthy\".\n    if (/^about:(blank|srcdoc)$/.test(url)) {\n        return true;\n    }\n    // 2. If url's scheme is \"data\", return \"Potentially Trustworthy\".\n    if (url.protocol === \"data:\") {\n        return true;\n    }\n    // Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were\n    // created. Therefore, blobs created in a trustworthy origin will themselves be potentially\n    // trustworthy.\n    if (/^(blob|filesystem):$/.test(url.protocol)) {\n        return true;\n    }\n    // 3. Return the result of executing 3.2 Is origin potentially trustworthy? on url's origin.\n    return isOriginPotentiallyTrustworthy(url);\n}\n/**\n * Modifies the referrerURL to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerURLCallback\n * @param {external:URL} referrerURL\n * @returns {external:URL} modified referrerURL\n */ /**\n * Modifies the referrerOrigin to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerOriginCallback\n * @param {external:URL} referrerOrigin\n * @returns {external:URL} modified referrerOrigin\n */ /**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}\n * @param {Request} request\n * @param {object} o\n * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback\n * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback\n * @returns {external:URL} Request's referrer\n */ function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {\n    // There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for\n    // these cases:\n    // > Note: If request's referrer is \"no-referrer\", Fetch will not call into this algorithm.\n    // > Note: If request's referrer policy is the empty string, Fetch will not call into this\n    // > algorithm.\n    if (request.referrer === \"no-referrer\" || request.referrerPolicy === \"\") {\n        return null;\n    }\n    // 1. Let policy be request's associated referrer policy.\n    const policy = request.referrerPolicy;\n    // 2. Let environment be request's client.\n    // not applicable to node.js\n    // 3. Switch on request's referrer:\n    if (request.referrer === \"about:client\") {\n        return \"no-referrer\";\n    }\n    // \"a URL\": Let referrerSource be request's referrer.\n    const referrerSource = request.referrer;\n    // 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.\n    let referrerURL = stripURLForUseAsAReferrer(referrerSource);\n    // 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the\n    //    origin-only flag set to true.\n    let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);\n    // 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set\n    //    referrerURL to referrerOrigin.\n    if (referrerURL.toString().length > 4096) {\n        referrerURL = referrerOrigin;\n    }\n    // 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary\n    //    policy considerations in the interests of minimizing data leakage. For example, the user\n    //    agent could strip the URL down to an origin, modify its host, replace it with an empty\n    //    string, etc.\n    if (referrerURLCallback) {\n        referrerURL = referrerURLCallback(referrerURL);\n    }\n    if (referrerOriginCallback) {\n        referrerOrigin = referrerOriginCallback(referrerOrigin);\n    }\n    // 8.Execute the statements corresponding to the value of policy:\n    const currentURL = new URL(request.url);\n    switch(policy){\n        case \"no-referrer\":\n            return \"no-referrer\";\n        case \"origin\":\n            return referrerOrigin;\n        case \"unsafe-url\":\n            return referrerURL;\n        case \"strict-origin\":\n            // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n            //    potentially trustworthy URL, then return no referrer.\n            if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n                return \"no-referrer\";\n            }\n            // 2. Return referrerOrigin.\n            return referrerOrigin.toString();\n        case \"strict-origin-when-cross-origin\":\n            // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n            //    return referrerURL.\n            if (referrerURL.origin === currentURL.origin) {\n                return referrerURL;\n            }\n            // 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n            //    potentially trustworthy URL, then return no referrer.\n            if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n                return \"no-referrer\";\n            }\n            // 3. Return referrerOrigin.\n            return referrerOrigin;\n        case \"same-origin\":\n            // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n            //    return referrerURL.\n            if (referrerURL.origin === currentURL.origin) {\n                return referrerURL;\n            }\n            // 2. Return no referrer.\n            return \"no-referrer\";\n        case \"origin-when-cross-origin\":\n            // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n            //    return referrerURL.\n            if (referrerURL.origin === currentURL.origin) {\n                return referrerURL;\n            }\n            // Return referrerOrigin.\n            return referrerOrigin;\n        case \"no-referrer-when-downgrade\":\n            // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n            //    potentially trustworthy URL, then return no referrer.\n            if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n                return \"no-referrer\";\n            }\n            // 2. Return referrerURL.\n            return referrerURL;\n        default:\n            throw new TypeError(`Invalid referrerPolicy: ${policy}`);\n    }\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy 8.1. Parse a referrer policy from a Referrer-Policy header}\n * @param {Headers} headers Response headers\n * @returns {string} policy\n */ function parseReferrerPolicyFromHeader(headers) {\n    // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`\n    //    and responses header list.\n    const policyTokens = (headers.get(\"referrer-policy\") || \"\").split(/[,\\s]+/);\n    // 2. Let policy be the empty string.\n    let policy = \"\";\n    // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty\n    //    string, then set policy to token.\n    // Note: This algorithm loops over multiple policy values to allow deployment of new policy\n    // values with fallbacks for older user agents, as described in  11.1 Unknown Policy Values.\n    for (const token of policyTokens){\n        if (token && ReferrerPolicy.has(token)) {\n            policy = token;\n        }\n    }\n    // 4. Return policy.\n    return policy;\n}\n/**\n * Request.js\n *\n * Request class contains server only options\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */ const INTERNALS = Symbol(\"Request internals\");\n/**\n * Check if `obj` is an instance of Request.\n *\n * @param  {*} object\n * @return {boolean}\n */ const isRequest = (object)=>{\n    return typeof object === \"object\" && typeof object[INTERNALS] === \"object\";\n};\nconst doBadDataWarn = node_util.deprecate(()=>{}, \".data is not a valid RequestInit property, use .body instead\", \"https://github.com/node-fetch/node-fetch/issues/1000 (request)\");\n/**\n * Request class\n *\n * Ref: https://fetch.spec.whatwg.org/#request-class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */ class Request extends Body {\n    constructor(input, init = {}){\n        let parsedURL;\n        // Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)\n        if (isRequest(input)) {\n            parsedURL = new URL(input.url);\n        } else {\n            parsedURL = new URL(input);\n            input = {};\n        }\n        if (parsedURL.username !== \"\" || parsedURL.password !== \"\") {\n            throw new TypeError(`${parsedURL} is an url with embedded credentials.`);\n        }\n        let method = init.method || input.method || \"GET\";\n        if (/^(delete|get|head|options|post|put)$/i.test(method)) {\n            method = method.toUpperCase();\n        }\n        if (!isRequest(init) && \"data\" in init) {\n            doBadDataWarn();\n        }\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if ((init.body != null || isRequest(input) && input.body !== null) && (method === \"GET\" || method === \"HEAD\")) {\n            throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n        }\n        const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n        super(inputBody, {\n            size: init.size || input.size || 0\n        });\n        const headers = new Headers(init.headers || input.headers || {});\n        if (inputBody !== null && !headers.has(\"Content-Type\")) {\n            const contentType = extractContentType(inputBody, this);\n            if (contentType) {\n                headers.set(\"Content-Type\", contentType);\n            }\n        }\n        let signal = isRequest(input) ? input.signal : null;\n        if (\"signal\" in init) {\n            signal = init.signal;\n        }\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (signal != null && !isAbortSignal(signal)) {\n            throw new TypeError(\"Expected signal to be an instanceof AbortSignal or EventTarget\");\n        }\n        // 5.4, Request constructor steps, step 15.1\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        let referrer = init.referrer == null ? input.referrer : init.referrer;\n        if (referrer === \"\") {\n            // 5.4, Request constructor steps, step 15.2\n            referrer = \"no-referrer\";\n        } else if (referrer) {\n            // 5.4, Request constructor steps, step 15.3.1, 15.3.2\n            const parsedReferrer = new URL(referrer);\n            // 5.4, Request constructor steps, step 15.3.3, 15.3.4\n            referrer = /^about:(\\/\\/)?client$/.test(parsedReferrer) ? \"client\" : parsedReferrer;\n        } else {\n            referrer = undefined;\n        }\n        this[INTERNALS] = {\n            method,\n            redirect: init.redirect || input.redirect || \"follow\",\n            headers,\n            parsedURL,\n            signal,\n            referrer\n        };\n        // Node-fetch-only options\n        this.follow = init.follow === undefined ? input.follow === undefined ? 20 : input.follow : init.follow;\n        this.compress = init.compress === undefined ? input.compress === undefined ? true : input.compress : init.compress;\n        this.counter = init.counter || input.counter || 0;\n        this.agent = init.agent || input.agent;\n        this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;\n        this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;\n        // 5.4, Request constructor steps, step 16.\n        // Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy\n        this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || \"\";\n    }\n    /** @returns {string} */ get method() {\n        return this[INTERNALS].method;\n    }\n    /** @returns {string} */ get url() {\n        return node_url.format(this[INTERNALS].parsedURL);\n    }\n    /** @returns {Headers} */ get headers() {\n        return this[INTERNALS].headers;\n    }\n    get redirect() {\n        return this[INTERNALS].redirect;\n    }\n    /** @returns {AbortSignal} */ get signal() {\n        return this[INTERNALS].signal;\n    }\n    // https://fetch.spec.whatwg.org/#dom-request-referrer\n    get referrer() {\n        if (this[INTERNALS].referrer === \"no-referrer\") {\n            return \"\";\n        }\n        if (this[INTERNALS].referrer === \"client\") {\n            return \"about:client\";\n        }\n        if (this[INTERNALS].referrer) {\n            return this[INTERNALS].referrer.toString();\n        }\n        return undefined;\n    }\n    get referrerPolicy() {\n        return this[INTERNALS].referrerPolicy;\n    }\n    set referrerPolicy(referrerPolicy) {\n        this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);\n    }\n    /**\n\t * Clone this request\n\t *\n\t * @return  Request\n\t */ clone() {\n        return new Request(this);\n    }\n    get [Symbol.toStringTag]() {\n        return \"Request\";\n    }\n}\nObject.defineProperties(Request.prototype, {\n    method: {\n        enumerable: true\n    },\n    url: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    redirect: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    },\n    signal: {\n        enumerable: true\n    },\n    referrer: {\n        enumerable: true\n    },\n    referrerPolicy: {\n        enumerable: true\n    }\n});\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param {Request} request - A Request instance\n * @return The options object to be passed to http.request\n */ const getNodeRequestOptions = (request)=>{\n    const { parsedURL } = request[INTERNALS];\n    const headers = new Headers(request[INTERNALS].headers);\n    // Fetch step 1.3\n    if (!headers.has(\"Accept\")) {\n        headers.set(\"Accept\", \"*/*\");\n    }\n    // HTTP-network-or-cache fetch steps 2.4-2.7\n    let contentLengthValue = null;\n    if (request.body === null && /^(post|put)$/i.test(request.method)) {\n        contentLengthValue = \"0\";\n    }\n    if (request.body !== null) {\n        const totalBytes = getTotalBytes(request);\n        // Set Content-Length if totalBytes is a number (that is not NaN)\n        if (typeof totalBytes === \"number\" && !Number.isNaN(totalBytes)) {\n            contentLengthValue = String(totalBytes);\n        }\n    }\n    if (contentLengthValue) {\n        headers.set(\"Content-Length\", contentLengthValue);\n    }\n    // 4.1. Main fetch, step 2.6\n    // > If request's referrer policy is the empty string, then set request's referrer policy to the\n    // > default referrer policy.\n    if (request.referrerPolicy === \"\") {\n        request.referrerPolicy = DEFAULT_REFERRER_POLICY;\n    }\n    // 4.1. Main fetch, step 2.7\n    // > If request's referrer is not \"no-referrer\", set request's referrer to the result of invoking\n    // > determine request's referrer.\n    if (request.referrer && request.referrer !== \"no-referrer\") {\n        request[INTERNALS].referrer = determineRequestsReferrer(request);\n    } else {\n        request[INTERNALS].referrer = \"no-referrer\";\n    }\n    // 4.5. HTTP-network-or-cache fetch, step 6.9\n    // > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized\n    // >  and isomorphic encoded, to httpRequest's header list.\n    if (request[INTERNALS].referrer instanceof URL) {\n        headers.set(\"Referer\", request.referrer);\n    }\n    // HTTP-network-or-cache fetch step 2.11\n    if (!headers.has(\"User-Agent\")) {\n        headers.set(\"User-Agent\", \"node-fetch\");\n    }\n    // HTTP-network-or-cache fetch step 2.15\n    if (request.compress && !headers.has(\"Accept-Encoding\")) {\n        headers.set(\"Accept-Encoding\", \"gzip, deflate, br\");\n    }\n    let { agent } = request;\n    if (typeof agent === \"function\") {\n        agent = agent(parsedURL);\n    }\n    if (!headers.has(\"Connection\") && !agent) {\n        headers.set(\"Connection\", \"close\");\n    }\n    // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n    const search = getSearch(parsedURL);\n    // Pass the full URL directly to request(), but overwrite the following\n    // options:\n    const options = {\n        // Overwrite search to retain trailing ? (issue #776)\n        path: parsedURL.pathname + search,\n        // The following options are not expressed in the URL\n        method: request.method,\n        headers: headers[Symbol.for(\"nodejs.util.inspect.custom\")](),\n        insecureHTTPParser: request.insecureHTTPParser,\n        agent\n    };\n    return {\n        /** @type {URL} */ parsedURL,\n        options\n    };\n};\n/**\n * AbortError interface for cancelled requests\n */ class AbortError extends FetchBaseError {\n    constructor(message, type = \"aborted\"){\n        super(message, type);\n    }\n}\n/*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */ if (!globalThis.DOMException) {\n    try {\n        const { MessageChannel } = __webpack_require__(/*! worker_threads */ \"worker_threads\"), port = new MessageChannel().port1, ab = new ArrayBuffer();\n        port.postMessage(ab, [\n            ab,\n            ab\n        ]);\n    } catch (err) {\n        err.constructor.name === \"DOMException\" && (globalThis.DOMException = err.constructor);\n    }\n}\nvar nodeDomexception = globalThis.DOMException;\n/**\n * Index.js\n *\n * a request API compatible with window.fetch\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */ const supportedSchemas = new Set([\n    \"data:\",\n    \"http:\",\n    \"https:\"\n]);\n/**\n * Fetch function\n *\n * @param   {string | URL | import('./request').default} url - Absolute url or Request instance\n * @param   {*} [options_] - Fetch options\n * @return  {Promise<import('./response').default>}\n */ async function fetch(url, options_) {\n    return new Promise((resolve, reject)=>{\n        // Build request object\n        const request = new Request(url, options_);\n        const { parsedURL, options } = getNodeRequestOptions(request);\n        if (!supportedSchemas.has(parsedURL.protocol)) {\n            throw new TypeError(`node-fetch cannot load ${url}. URL scheme \"${parsedURL.protocol.replace(/:$/, \"\")}\" is not supported.`);\n        }\n        if (parsedURL.protocol === \"data:\") {\n            const data = dataUriToBuffer(request.url);\n            const response = new Response(data, {\n                headers: {\n                    \"Content-Type\": data.typeFull\n                }\n            });\n            resolve(response);\n            return;\n        }\n        // Wrap http.request into fetch\n        const send = (parsedURL.protocol === \"https:\" ? https : http).request;\n        const { signal } = request;\n        let response = null;\n        const abort = ()=>{\n            const error = new AbortError(\"The operation was aborted.\");\n            reject(error);\n            if (request.body && request.body instanceof Stream.Readable) {\n                request.body.destroy(error);\n            }\n            if (!response || !response.body) {\n                return;\n            }\n            response.body.emit(\"error\", error);\n        };\n        if (signal && signal.aborted) {\n            abort();\n            return;\n        }\n        const abortAndFinalize = ()=>{\n            abort();\n            finalize();\n        };\n        // Send request\n        const request_ = send(parsedURL.toString(), options);\n        if (signal) {\n            signal.addEventListener(\"abort\", abortAndFinalize);\n        }\n        const finalize = ()=>{\n            request_.abort();\n            if (signal) {\n                signal.removeEventListener(\"abort\", abortAndFinalize);\n            }\n        };\n        request_.on(\"error\", (error)=>{\n            reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, \"system\", error));\n            finalize();\n        });\n        fixResponseChunkedTransferBadEnding(request_, (error)=>{\n            if (response && response.body) {\n                response.body.destroy(error);\n            }\n        });\n        /* c8 ignore next 18 */ if (process.version < \"v14\") {\n            // Before Node.js 14, pipeline() does not fully support async iterators and does not always\n            // properly handle when the socket close/end events are out of order.\n            request_.on(\"socket\", (s)=>{\n                let endedWithEventsCount;\n                s.prependListener(\"end\", ()=>{\n                    endedWithEventsCount = s._eventsCount;\n                });\n                s.prependListener(\"close\", (hadError)=>{\n                    // if end happened before close but the socket didn't emit an error, do it now\n                    if (response && endedWithEventsCount < s._eventsCount && !hadError) {\n                        const error = new Error(\"Premature close\");\n                        error.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                        response.body.emit(\"error\", error);\n                    }\n                });\n            });\n        }\n        request_.on(\"response\", (response_)=>{\n            request_.setTimeout(0);\n            const headers = fromRawHeaders(response_.rawHeaders);\n            // HTTP fetch step 5\n            if (isRedirect(response_.statusCode)) {\n                // HTTP fetch step 5.2\n                const location = headers.get(\"Location\");\n                // HTTP fetch step 5.3\n                let locationURL = null;\n                try {\n                    locationURL = location === null ? null : new URL(location, request.url);\n                } catch  {\n                    // error here can only be invalid URL in Location: header\n                    // do not throw when options.redirect == manual\n                    // let the user extract the errorneous redirect URL\n                    if (request.redirect !== \"manual\") {\n                        reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, \"invalid-redirect\"));\n                        finalize();\n                        return;\n                    }\n                }\n                // HTTP fetch step 5.5\n                switch(request.redirect){\n                    case \"error\":\n                        reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, \"no-redirect\"));\n                        finalize();\n                        return;\n                    case \"manual\":\n                        break;\n                    case \"follow\":\n                        {\n                            // HTTP-redirect fetch step 2\n                            if (locationURL === null) {\n                                break;\n                            }\n                            // HTTP-redirect fetch step 5\n                            if (request.counter >= request.follow) {\n                                reject(new FetchError(`maximum redirect reached at: ${request.url}`, \"max-redirect\"));\n                                finalize();\n                                return;\n                            }\n                            // HTTP-redirect fetch step 6 (counter increment)\n                            // Create a new Request object.\n                            const requestOptions = {\n                                headers: new Headers(request.headers),\n                                follow: request.follow,\n                                counter: request.counter + 1,\n                                agent: request.agent,\n                                compress: request.compress,\n                                method: request.method,\n                                body: clone(request),\n                                signal: request.signal,\n                                size: request.size,\n                                referrer: request.referrer,\n                                referrerPolicy: request.referrerPolicy\n                            };\n                            // when forwarding sensitive headers like \"Authorization\",\n                            // \"WWW-Authenticate\", and \"Cookie\" to untrusted targets,\n                            // headers will be ignored when following a redirect to a domain\n                            // that is not a subdomain match or exact match of the initial domain.\n                            // For example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\"\n                            // will forward the sensitive headers, but a redirect to \"bar.com\" will not.\n                            // headers will also be ignored when following a redirect to a domain using\n                            // a different protocol. For example, a redirect from \"https://foo.com\" to \"http://foo.com\"\n                            // will not forward the sensitive headers\n                            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n                                for (const name of [\n                                    \"authorization\",\n                                    \"www-authenticate\",\n                                    \"cookie\",\n                                    \"cookie2\"\n                                ]){\n                                    requestOptions.headers.delete(name);\n                                }\n                            }\n                            // HTTP-redirect fetch step 9\n                            if (response_.statusCode !== 303 && request.body && options_.body instanceof Stream.Readable) {\n                                reject(new FetchError(\"Cannot follow redirect with body being a readable stream\", \"unsupported-redirect\"));\n                                finalize();\n                                return;\n                            }\n                            // HTTP-redirect fetch step 11\n                            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === \"POST\") {\n                                requestOptions.method = \"GET\";\n                                requestOptions.body = undefined;\n                                requestOptions.headers.delete(\"content-length\");\n                            }\n                            // HTTP-redirect fetch step 14\n                            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);\n                            if (responseReferrerPolicy) {\n                                requestOptions.referrerPolicy = responseReferrerPolicy;\n                            }\n                            // HTTP-redirect fetch step 15\n                            resolve(fetch(new Request(locationURL, requestOptions)));\n                            finalize();\n                            return;\n                        }\n                    default:\n                        return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));\n                }\n            }\n            // Prepare response\n            if (signal) {\n                response_.once(\"end\", ()=>{\n                    signal.removeEventListener(\"abort\", abortAndFinalize);\n                });\n            }\n            let body = Stream.pipeline(response_, new Stream.PassThrough(), (error)=>{\n                if (error) {\n                    reject(error);\n                }\n            });\n            // see https://github.com/nodejs/node/pull/29376\n            /* c8 ignore next 3 */ if (process.version < \"v12.10\") {\n                response_.on(\"aborted\", abortAndFinalize);\n            }\n            const responseOptions = {\n                url: request.url,\n                status: response_.statusCode,\n                statusText: response_.statusMessage,\n                headers,\n                size: request.size,\n                counter: request.counter,\n                highWaterMark: request.highWaterMark\n            };\n            // HTTP-network fetch step 12.1.1.3\n            const codings = headers.get(\"Content-Encoding\");\n            // HTTP-network fetch step 12.1.1.4: handle content codings\n            // in following scenarios we ignore compression support\n            // 1. compression support is disabled\n            // 2. HEAD request\n            // 3. no Content-Encoding header\n            // 4. no content response (204)\n            // 5. content not modified response (304)\n            if (!request.compress || request.method === \"HEAD\" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {\n                response = new Response(body, responseOptions);\n                resolve(response);\n                return;\n            }\n            // For Node v6+\n            // Be less strict when decoding compressed responses, since sometimes\n            // servers send slightly invalid responses that are still accepted\n            // by common browsers.\n            // Always using Z_SYNC_FLUSH is what cURL does.\n            const zlibOptions = {\n                flush: zlib.Z_SYNC_FLUSH,\n                finishFlush: zlib.Z_SYNC_FLUSH\n            };\n            // For gzip\n            if (codings === \"gzip\" || codings === \"x-gzip\") {\n                body = Stream.pipeline(body, zlib.createGunzip(zlibOptions), (error)=>{\n                    if (error) {\n                        reject(error);\n                    }\n                });\n                response = new Response(body, responseOptions);\n                resolve(response);\n                return;\n            }\n            // For deflate\n            if (codings === \"deflate\" || codings === \"x-deflate\") {\n                // Handle the infamous raw deflate response from old servers\n                // a hack for old IIS and Apache servers\n                const raw = Stream.pipeline(response_, new Stream.PassThrough(), (error)=>{\n                    if (error) {\n                        reject(error);\n                    }\n                });\n                raw.once(\"data\", (chunk)=>{\n                    // See http://stackoverflow.com/questions/37519828\n                    if ((chunk[0] & 0x0F) === 0x08) {\n                        body = Stream.pipeline(body, zlib.createInflate(), (error)=>{\n                            if (error) {\n                                reject(error);\n                            }\n                        });\n                    } else {\n                        body = Stream.pipeline(body, zlib.createInflateRaw(), (error)=>{\n                            if (error) {\n                                reject(error);\n                            }\n                        });\n                    }\n                    response = new Response(body, responseOptions);\n                    resolve(response);\n                });\n                raw.once(\"end\", ()=>{\n                    // Some old IIS servers return zero-length OK deflate responses, so\n                    // 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903\n                    if (!response) {\n                        response = new Response(body, responseOptions);\n                        resolve(response);\n                    }\n                });\n                return;\n            }\n            // For br\n            if (codings === \"br\") {\n                body = Stream.pipeline(body, zlib.createBrotliDecompress(), (error)=>{\n                    if (error) {\n                        reject(error);\n                    }\n                });\n                response = new Response(body, responseOptions);\n                resolve(response);\n                return;\n            }\n            // Otherwise, use response as-is\n            response = new Response(body, responseOptions);\n            resolve(response);\n        });\n        // eslint-disable-next-line promise/prefer-await-to-then\n        writeToStream(request_, request).catch(reject);\n    });\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n    const LAST_CHUNK = node_buffer.Buffer.from(\"0\\r\\n\\r\\n\");\n    let isChunkedTransfer = false;\n    let properLastChunkReceived = false;\n    let previousChunk;\n    request.on(\"response\", (response)=>{\n        const { headers } = response;\n        isChunkedTransfer = headers[\"transfer-encoding\"] === \"chunked\" && !headers[\"content-length\"];\n    });\n    request.on(\"socket\", (socket)=>{\n        const onSocketClose = ()=>{\n            if (isChunkedTransfer && !properLastChunkReceived) {\n                const error = new Error(\"Premature close\");\n                error.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                errorCallback(error);\n            }\n        };\n        const onData = (buf)=>{\n            properLastChunkReceived = node_buffer.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;\n            // Sometimes final 0-length chunk and end of message code are in separate packets\n            if (!properLastChunkReceived && previousChunk) {\n                properLastChunkReceived = node_buffer.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && node_buffer.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;\n            }\n            previousChunk = buf;\n        };\n        socket.prependListener(\"close\", onSocketClose);\n        socket.on(\"data\", onData);\n        request.on(\"close\", ()=>{\n            socket.removeListener(\"close\", onSocketClose);\n            socket.removeListener(\"data\", onData);\n        });\n    });\n}\n/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */ /**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */ /**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */ const privateData = new WeakMap();\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */ const wrappers = new WeakMap();\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */ function pd(event) {\n    const retv = privateData.get(event);\n    console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n    return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */ function setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n            console.error(\"Unable to preventDefault inside passive event listener invocation.\", data.passiveListener);\n        }\n        return;\n    }\n    if (!data.event.cancelable) {\n        return;\n    }\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */ /**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */ function Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now()\n    });\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", {\n        value: false,\n        enumerable: true\n    });\n    // Define accessors\n    const keys = Object.keys(event);\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */ get type () {\n        return pd(this).event.type;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */ get target () {\n        return pd(this).eventTarget;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */ get currentTarget () {\n        return pd(this).currentTarget;\n    },\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */ composedPath () {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return [];\n        }\n        return [\n            currentTarget\n        ];\n    },\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */ get NONE () {\n        return 0;\n    },\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */ get CAPTURING_PHASE () {\n        return 1;\n    },\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */ get AT_TARGET () {\n        return 2;\n    },\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */ get BUBBLING_PHASE () {\n        return 3;\n    },\n    /**\n     * The target of this event.\n     * @type {number}\n     */ get eventPhase () {\n        return pd(this).eventPhase;\n    },\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */ stopPropagation () {\n        const data = pd(this);\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */ stopImmediatePropagation () {\n        const data = pd(this);\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */ get bubbles () {\n        return Boolean(pd(this).event.bubbles);\n    },\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */ get cancelable () {\n        return Boolean(pd(this).event.cancelable);\n    },\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */ preventDefault () {\n        setCancelFlag(pd(this));\n    },\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */ get defaultPrevented () {\n        return pd(this).canceled;\n    },\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */ get composed () {\n        return Boolean(pd(this).event.composed);\n    },\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */ get timeStamp () {\n        return pd(this).timeStamp;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */ get srcElement () {\n        return pd(this).eventTarget;\n    },\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */ get cancelBubble () {\n        return pd(this).stopped;\n    },\n    set cancelBubble (value){\n        if (!value) {\n            return;\n        }\n        const data = pd(this);\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */ get returnValue () {\n        return !pd(this).canceled;\n    },\n    set returnValue (value){\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */ initEvent () {\n    // Do nothing.\n    }\n};\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true\n});\n// Ensure `event instanceof window.Event` is `true`.\nif (false) {}\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */ function defineRedirectDescriptor(key) {\n    return {\n        get () {\n            return pd(this).event[key];\n        },\n        set (value1) {\n            pd(this).event[key] = value1;\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */ function defineCallDescriptor(key) {\n    return {\n        value () {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments);\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */ function defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent;\n    }\n    /** CustomEvent */ function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: {\n            value: CustomEvent,\n            configurable: true,\n            writable: true\n        }\n    });\n    // Define accessors.\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));\n        }\n    }\n    return CustomEvent;\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */ function getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event;\n    }\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper;\n}\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */ function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event);\n}\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */ function isStopped(event) {\n    return pd(event).immediateStopped;\n}\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */ function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */ function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */ function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */ /**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */ const listenersMap = new WeakMap();\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */ function isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n    ;\n}\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */ function getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n    }\n    return listeners;\n}\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */ function defineEventAttributeDescriptor(eventName) {\n    return {\n        get () {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while(node != null){\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener;\n                }\n                node = node.next;\n            }\n            return null;\n        },\n        set (listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while(node != null){\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n                node = node.next;\n            }\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */ function defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));\n}\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */ function defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */ function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true\n        }\n    });\n    for(let i = 0; i < eventNames.length; ++i){\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n    return CustomEventTarget;\n}\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */ function EventTarget() {\n    /*eslint-disable consistent-return */ if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return;\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0]);\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for(let i = 0; i < arguments.length; ++i){\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types);\n    }\n    throw new TypeError(\"Cannot call a class as a function\");\n/*eslint-enable consistent-return */ }\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */ addEventListener (eventName, listener, options) {\n        if (listener == null) {\n            return;\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\");\n        }\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null\n        };\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return;\n        }\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while(node != null){\n            if (node.listener === listener && node.listenerType === listenerType) {\n                // Should ignore duplication.\n                return;\n            }\n            prev = node;\n            node = node.next;\n        }\n        // Add it.\n        prev.next = newNode;\n    },\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */ removeEventListener (eventName, listener, options) {\n        if (listener == null) {\n            return;\n        }\n        const listeners = getListeners(this);\n        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        let prev = null;\n        let node = listeners.get(eventName);\n        while(node != null){\n            if (node.listener === listener && node.listenerType === listenerType) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return;\n            }\n            prev = node;\n            node = node.next;\n        }\n    },\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */ dispatchEvent (event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.');\n        }\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true;\n        }\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while(node != null){\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n            // Call this listener\n            setPassiveListener(wrappedEvent, node.passive ? node.listener : null);\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n                        console.error(err);\n                    }\n                }\n            } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n                node.listener.handleEvent(wrappedEvent);\n            }\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break;\n            }\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n        return !wrappedEvent.defaultPrevented;\n    }\n};\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true\n});\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (false) {}\n/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * See LICENSE file in root directory for full license.\n */ /**\n * The signal class.\n * @see https://dom.spec.whatwg.org/#abortsignal\n */ class AbortSignal extends EventTarget {\n    /**\n     * AbortSignal cannot be constructed directly.\n     */ constructor(){\n        super();\n        throw new TypeError(\"AbortSignal cannot be constructed directly\");\n    }\n    /**\n     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.\n     */ get aborted() {\n        const aborted = abortedFlags.get(this);\n        if (typeof aborted !== \"boolean\") {\n            throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? \"null\" : typeof this}`);\n        }\n        return aborted;\n    }\n}\ndefineEventAttribute(AbortSignal.prototype, \"abort\");\n/**\n * Create an AbortSignal object.\n */ function createAbortSignal() {\n    const signal = Object.create(AbortSignal.prototype);\n    EventTarget.call(signal);\n    abortedFlags.set(signal, false);\n    return signal;\n}\n/**\n * Abort a given signal.\n */ function abortSignal(signal) {\n    if (abortedFlags.get(signal) !== false) {\n        return;\n    }\n    abortedFlags.set(signal, true);\n    signal.dispatchEvent({\n        type: \"abort\"\n    });\n}\n/**\n * Aborted flag for each instances.\n */ const abortedFlags = new WeakMap();\n// Properties should be enumerable.\nObject.defineProperties(AbortSignal.prototype, {\n    aborted: {\n        enumerable: true\n    }\n});\n// `toString()` should return `\"[object AbortSignal]\"`\nif (typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\") {\n    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \"AbortSignal\"\n    });\n}\n/**\n * The AbortController.\n * @see https://dom.spec.whatwg.org/#abortcontroller\n */ class AbortController$1 {\n    /**\n     * Initialize this controller.\n     */ constructor(){\n        signals.set(this, createAbortSignal());\n    }\n    /**\n     * Returns the `AbortSignal` object associated with this object.\n     */ get signal() {\n        return getSignal(this);\n    }\n    /**\n     * Abort and signal to any observers that the associated activity is to be aborted.\n     */ abort() {\n        abortSignal(getSignal(this));\n    }\n}\n/**\n * Associated signals.\n */ const signals = new WeakMap();\n/**\n * Get the associated signal of a given controller.\n */ function getSignal(controller) {\n    const signal = signals.get(controller);\n    if (signal == null) {\n        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? \"null\" : typeof controller}`);\n    }\n    return signal;\n}\n// Properties should be enumerable.\nObject.defineProperties(AbortController$1.prototype, {\n    signal: {\n        enumerable: true\n    },\n    abort: {\n        enumerable: true\n    }\n});\nif (typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\") {\n    Object.defineProperty(AbortController$1.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \"AbortController\"\n    });\n}\nexports.AbortController = AbortController$1;\nexports.AbortError = AbortError;\nexports.FetchError = FetchError;\nexports.File = File$1;\nexports.FormData = FormData;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports._Blob = _Blob$1;\nexports.fetch = fetch;\nexports.isRedirect = isRedirect;\nexports.nodeDomexception = nodeDomexception;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9zaGFyZWQvbm9kZS1mZXRjaC1uYXRpdmUuOGFmZDNmZWEuY2pzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUVBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1JLGNBQWNKLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1LLFlBQVlMLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1NLFdBQVdOLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1PLFdBQVdQLG1CQUFPQSxDQUFDO0FBQ3pCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSOzs7Ozs7Q0FNQyxHQUNELFNBQVNRLGdCQUFnQkMsR0FBRztJQUN4QixJQUFJLENBQUMsVUFBVUMsSUFBSSxDQUFDRCxNQUFNO1FBQ3RCLE1BQU0sSUFBSUUsVUFBVTtJQUN4QjtJQUNBLGlCQUFpQjtJQUNqQkYsTUFBTUEsSUFBSUcsT0FBTyxDQUFDLFVBQVU7SUFDNUIsK0RBQStEO0lBQy9ELE1BQU1DLGFBQWFKLElBQUlLLE9BQU8sQ0FBQztJQUMvQixJQUFJRCxlQUFlLENBQUMsS0FBS0EsY0FBYyxHQUFHO1FBQ3RDLE1BQU0sSUFBSUYsVUFBVTtJQUN4QjtJQUNBLG1EQUFtRDtJQUNuRCxNQUFNSSxPQUFPTixJQUFJTyxTQUFTLENBQUMsR0FBR0gsWUFBWUksS0FBSyxDQUFDO0lBQ2hELElBQUlDLFVBQVU7SUFDZCxJQUFJQyxTQUFTO0lBQ2IsTUFBTUMsT0FBT0wsSUFBSSxDQUFDLEVBQUUsSUFBSTtJQUN4QixJQUFJTSxXQUFXRDtJQUNmLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJUCxLQUFLUSxNQUFNLEVBQUVELElBQUs7UUFDbEMsSUFBSVAsSUFBSSxDQUFDTyxF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YnBhY2s6Ly9tZXJucHJvamVjdC8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoLW5hdGl2ZS9kaXN0L3NoYXJlZC9ub2RlLWZldGNoLW5hdGl2ZS44YWZkM2ZlYS5janM/ZTdiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdub2RlOmh0dHAnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnbm9kZTpodHRwcycpO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoJ25vZGU6emxpYicpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKTtcbmNvbnN0IG5vZGVfYnVmZmVyID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKTtcbmNvbnN0IG5vZGVfdXRpbCA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpO1xuY29uc3Qgbm9kZV91cmwgPSByZXF1aXJlKCdub2RlOnVybCcpO1xuY29uc3Qgbm9kZV9uZXQgPSByZXF1aXJlKCdub2RlOm5ldCcpO1xucmVxdWlyZSgnbm9kZTpmcycpO1xucmVxdWlyZSgnbm9kZTpwYXRoJyk7XG5cbi8qKlxuICogUmV0dXJucyBhIGBCdWZmZXJgIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIGRhdGEgVVJJIGB1cmlgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmkgRGF0YSBVUkkgdG8gdHVybiBpbnRvIGEgQnVmZmVyIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXIgaW5zdGFuY2UgZnJvbSBEYXRhIFVSSVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGF0YVVyaVRvQnVmZmVyKHVyaSkge1xuICAgIGlmICghL15kYXRhOi9pLnRlc3QodXJpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgdXJpYCBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSBEYXRhIFVSSSAobXVzdCBiZWdpbiB3aXRoIFwiZGF0YTpcIiknKTtcbiAgICB9XG4gICAgLy8gc3RyaXAgbmV3bGluZXNcbiAgICB1cmkgPSB1cmkucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyk7XG4gICAgLy8gc3BsaXQgdGhlIFVSSSB1cCBpbnRvIHRoZSBcIm1ldGFkYXRhXCIgYW5kIHRoZSBcImRhdGFcIiBwb3J0aW9uc1xuICAgIGNvbnN0IGZpcnN0Q29tbWEgPSB1cmkuaW5kZXhPZignLCcpO1xuICAgIGlmIChmaXJzdENvbW1hID09PSAtMSB8fCBmaXJzdENvbW1hIDw9IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWFsZm9ybWVkIGRhdGE6IFVSSScpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgdGhlIFwiZGF0YTpcIiBzY2hlbWUgYW5kIHBhcnNlIHRoZSBtZXRhZGF0YVxuICAgIGNvbnN0IG1ldGEgPSB1cmkuc3Vic3RyaW5nKDUsIGZpcnN0Q29tbWEpLnNwbGl0KCc7Jyk7XG4gICAgbGV0IGNoYXJzZXQgPSAnJztcbiAgICBsZXQgYmFzZTY0ID0gZmFsc2U7XG4gICAgY29uc3QgdHlwZSA9IG1ldGFbMF0gfHwgJ3RleHQvcGxhaW4nO1xuICAgIGxldCB0eXBlRnVsbCA9IHR5cGU7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtZXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtZXRhW2ldID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgYmFzZTY0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVGdWxsICs9IGA7JHttZXRhW2ldfWA7XG4gICAgICAgICAgICBpZiAobWV0YVtpXS5pbmRleE9mKCdjaGFyc2V0PScpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldCA9IG1ldGFbaV0uc3Vic3RyaW5nKDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRlZmF1bHRzIHRvIFVTLUFTQ0lJIG9ubHkgaWYgdHlwZSBpcyBub3QgcHJvdmlkZWRcbiAgICBpZiAoIW1ldGFbMF0gJiYgIWNoYXJzZXQubGVuZ3RoKSB7XG4gICAgICAgIHR5cGVGdWxsICs9ICc7Y2hhcnNldD1VUy1BU0NJSSc7XG4gICAgICAgIGNoYXJzZXQgPSAnVVMtQVNDSUknO1xuICAgIH1cbiAgICAvLyBnZXQgdGhlIGVuY29kZWQgZGF0YSBwb3J0aW9uIGFuZCBkZWNvZGUgVVJJLWVuY29kZWQgY2hhcnNcbiAgICBjb25zdCBlbmNvZGluZyA9IGJhc2U2NCA/ICdiYXNlNjQnIDogJ2FzY2lpJztcbiAgICBjb25zdCBkYXRhID0gdW5lc2NhcGUodXJpLnN1YnN0cmluZyhmaXJzdENvbW1hICsgMSkpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKTtcbiAgICAvLyBzZXQgYC50eXBlYCBhbmQgYC50eXBlRnVsbGAgcHJvcGVydGllcyB0byBNSU1FIHR5cGVcbiAgICBidWZmZXIudHlwZSA9IHR5cGU7XG4gICAgYnVmZmVyLnR5cGVGdWxsID0gdHlwZUZ1bGw7XG4gICAgLy8gc2V0IHRoZSBgLmNoYXJzZXRgIHByb3BlcnR5XG4gICAgYnVmZmVyLmNoYXJzZXQgPSBjaGFyc2V0O1xuICAgIHJldHVybiBidWZmZXI7XG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgcG9ueWZpbGxfZXMyMDE4ID0ge2V4cG9ydHM6IHt9fTtcblxuLyoqXG4gKiB3ZWItc3RyZWFtcy1wb2x5ZmlsbCB2My4yLjFcbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRQb255ZmlsbF9lczIwMTg7XG5cbmZ1bmN0aW9uIHJlcXVpcmVQb255ZmlsbF9lczIwMTggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRQb255ZmlsbF9lczIwMTgpIHJldHVybiBwb255ZmlsbF9lczIwMTguZXhwb3J0cztcblx0aGFzUmVxdWlyZWRQb255ZmlsbF9lczIwMTggPSAxO1xuXHQoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdChmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdFx0ICAgIGZhY3RvcnkoZXhwb3J0cykgO1xuXHRcdH0oY29tbW9uanNHbG9iYWwsIChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdCAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuc3ltYm9sXCIgLz5cblx0XHQgICAgY29uc3QgU3ltYm9sUG9seWZpbGwgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnID9cblx0XHQgICAgICAgIFN5bWJvbCA6XG5cdFx0ICAgICAgICBkZXNjcmlwdGlvbiA9PiBgU3ltYm9sKCR7ZGVzY3JpcHRpb259KWA7XG5cblx0XHQgICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cblx0XHQgICAgZnVuY3Rpb24gbm9vcCgpIHtcblx0XHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZ2V0R2xvYmFscygpIHtcblx0XHQgICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gc2VsZjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb21tb25qc0dsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gY29tbW9uanNHbG9iYWw7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IGdsb2JhbHMgPSBnZXRHbG9iYWxzKCk7XG5cblx0XHQgICAgZnVuY3Rpb24gdHlwZUlzT2JqZWN0KHgpIHtcblx0XHQgICAgICAgIHJldHVybiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbiA9IG5vb3A7XG5cblx0XHQgICAgY29uc3Qgb3JpZ2luYWxQcm9taXNlID0gUHJvbWlzZTtcblx0XHQgICAgY29uc3Qgb3JpZ2luYWxQcm9taXNlVGhlbiA9IFByb21pc2UucHJvdG90eXBlLnRoZW47XG5cdFx0ICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZVJlc29sdmUgPSBQcm9taXNlLnJlc29sdmUuYmluZChvcmlnaW5hbFByb21pc2UpO1xuXHRcdCAgICBjb25zdCBvcmlnaW5hbFByb21pc2VSZWplY3QgPSBQcm9taXNlLnJlamVjdC5iaW5kKG9yaWdpbmFsUHJvbWlzZSk7XG5cdFx0ICAgIGZ1bmN0aW9uIG5ld1Byb21pc2UoZXhlY3V0b3IpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgb3JpZ2luYWxQcm9taXNlKGV4ZWN1dG9yKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBwcm9taXNlUmVzb2x2ZWRXaXRoKHZhbHVlKSB7XG5cdFx0ICAgICAgICByZXR1cm4gb3JpZ2luYWxQcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFzb24pIHtcblx0XHQgICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2VSZWplY3QocmVhc29uKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcblx0XHQgICAgICAgIC8vIFRoZXJlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGFueSB3YXkgdG8gY29ycmVjdGx5IGVtdWxhdGUgdGhlIGJlaGF2aW91ciBmcm9tIEphdmFTY3JpcHQsIHNvIHRoaXMgaXMganVzdCBhblxuXHRcdCAgICAgICAgLy8gYXBwcm94aW1hdGlvbi5cblx0XHQgICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2VUaGVuLmNhbGwocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIHVwb25Qcm9taXNlKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG5cdFx0ICAgICAgICBQZXJmb3JtUHJvbWlzZVRoZW4oUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSwgdW5kZWZpbmVkLCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIHVwb25GdWxmaWxsbWVudChwcm9taXNlLCBvbkZ1bGZpbGxlZCkge1xuXHRcdCAgICAgICAgdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIHVwb25SZWplY3Rpb24ocHJvbWlzZSwgb25SZWplY3RlZCkge1xuXHRcdCAgICAgICAgdXBvblByb21pc2UocHJvbWlzZSwgdW5kZWZpbmVkLCBvblJlamVjdGVkKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChwcm9taXNlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcblx0XHQgICAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHByb21pc2UpIHtcblx0XHQgICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCB1bmRlZmluZWQsIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbik7XG5cdFx0ICAgIH1cblx0XHQgICAgY29uc3QgcXVldWVNaWNyb3Rhc2sgPSAoKCkgPT4ge1xuXHRcdCAgICAgICAgY29uc3QgZ2xvYmFsUXVldWVNaWNyb3Rhc2sgPSBnbG9iYWxzICYmIGdsb2JhbHMucXVldWVNaWNyb3Rhc2s7XG5cdFx0ICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFF1ZXVlTWljcm90YXNrO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChmbikgPT4gUGVyZm9ybVByb21pc2VUaGVuKHJlc29sdmVkUHJvbWlzZSwgZm4pO1xuXHRcdCAgICB9KSgpO1xuXHRcdCAgICBmdW5jdGlvbiByZWZsZWN0Q2FsbChGLCBWLCBhcmdzKSB7XG5cdFx0ICAgICAgICBpZiAodHlwZW9mIEYgIT09ICdmdW5jdGlvbicpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKEYsIFYsIGFyZ3MpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIHByb21pc2VDYWxsKEYsIFYsIGFyZ3MpIHtcblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgocmVmbGVjdENhbGwoRiwgViwgYXJncykpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY2F0Y2ggKHZhbHVlKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodmFsdWUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cblx0XHQgICAgLy8gT3JpZ2luYWwgZnJvbSBDaHJvbWl1bVxuXHRcdCAgICAvLyBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLysvMGFlZTQ0MzRhNGRiYTQyYTQyYWJhZWE5YmZiYzBjZDE5NmE2M2JjMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL3N0cmVhbXMvU2ltcGxlUXVldWUuanNcblx0XHQgICAgY29uc3QgUVVFVUVfTUFYX0FSUkFZX1NJWkUgPSAxNjM4NDtcblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIFNpbXBsZSBxdWV1ZSBzdHJ1Y3R1cmUuXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEF2b2lkcyBzY2FsYWJpbGl0eSBpc3N1ZXMgd2l0aCB1c2luZyBhIHBhY2tlZCBhcnJheSBkaXJlY3RseSBieSB1c2luZ1xuXHRcdCAgICAgKiBtdWx0aXBsZSBhcnJheXMgaW4gYSBsaW5rZWQgbGlzdCBhbmQga2VlcGluZyB0aGUgYXJyYXkgc2l6ZSBib3VuZGVkLlxuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgU2ltcGxlUXVldWUge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IoKSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gMDtcblx0XHQgICAgICAgICAgICB0aGlzLl9zaXplID0gMDtcblx0XHQgICAgICAgICAgICAvLyBfZnJvbnQgYW5kIF9iYWNrIGFyZSBhbHdheXMgZGVmaW5lZC5cblx0XHQgICAgICAgICAgICB0aGlzLl9mcm9udCA9IHtcblx0XHQgICAgICAgICAgICAgICAgX2VsZW1lbnRzOiBbXSxcblx0XHQgICAgICAgICAgICAgICAgX25leHQ6IHVuZGVmaW5lZFxuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgdGhpcy5fYmFjayA9IHRoaXMuX2Zyb250O1xuXHRcdCAgICAgICAgICAgIC8vIFRoZSBjdXJzb3IgaXMgdXNlZCB0byBhdm9pZCBjYWxsaW5nIEFycmF5LnNoaWZ0KCkuXG5cdFx0ICAgICAgICAgICAgLy8gSXQgY29udGFpbnMgdGhlIGluZGV4IG9mIHRoZSBmcm9udCBlbGVtZW50IG9mIHRoZSBhcnJheSBpbnNpZGUgdGhlXG5cdFx0ICAgICAgICAgICAgLy8gZnJvbnQtbW9zdCBub2RlLiBJdCBpcyBhbHdheXMgaW4gdGhlIHJhbmdlIFswLCBRVUVVRV9NQVhfQVJSQVlfU0laRSkuXG5cdFx0ICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gMDtcblx0XHQgICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIG9ubHkgb25lIG5vZGUsIHNpemUgPT09IGVsZW1lbnRzLmxlbmd0aCAtIGN1cnNvci5cblx0XHQgICAgICAgICAgICB0aGlzLl9zaXplID0gMDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGdldCBsZW5ndGgoKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBGb3IgZXhjZXB0aW9uIHNhZmV0eSwgdGhpcyBtZXRob2QgaXMgc3RydWN0dXJlZCBpbiBvcmRlcjpcblx0XHQgICAgICAgIC8vIDEuIFJlYWQgc3RhdGVcblx0XHQgICAgICAgIC8vIDIuIENhbGN1bGF0ZSByZXF1aXJlZCBzdGF0ZSBtdXRhdGlvbnNcblx0XHQgICAgICAgIC8vIDMuIFBlcmZvcm0gc3RhdGUgbXV0YXRpb25zXG5cdFx0ICAgICAgICBwdXNoKGVsZW1lbnQpIHtcblx0XHQgICAgICAgICAgICBjb25zdCBvbGRCYWNrID0gdGhpcy5fYmFjaztcblx0XHQgICAgICAgICAgICBsZXQgbmV3QmFjayA9IG9sZEJhY2s7XG5cdFx0ICAgICAgICAgICAgaWYgKG9sZEJhY2suX2VsZW1lbnRzLmxlbmd0aCA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUgLSAxKSB7XG5cdFx0ICAgICAgICAgICAgICAgIG5ld0JhY2sgPSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBfZWxlbWVudHM6IFtdLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgX25leHQ6IHVuZGVmaW5lZFxuXHRcdCAgICAgICAgICAgICAgICB9O1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAvLyBwdXNoKCkgaXMgdGhlIG11dGF0aW9uIG1vc3QgbGlrZWx5IHRvIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gaXRcblx0XHQgICAgICAgICAgICAvLyBnb2VzIGZpcnN0LlxuXHRcdCAgICAgICAgICAgIG9sZEJhY2suX2VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0ICAgICAgICAgICAgaWYgKG5ld0JhY2sgIT09IG9sZEJhY2spIHtcblx0XHQgICAgICAgICAgICAgICAgdGhpcy5fYmFjayA9IG5ld0JhY2s7XG5cdFx0ICAgICAgICAgICAgICAgIG9sZEJhY2suX25leHQgPSBuZXdCYWNrO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICArK3RoaXMuX3NpemU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBMaWtlIHB1c2goKSwgc2hpZnQoKSBmb2xsb3dzIHRoZSByZWFkIC0+IGNhbGN1bGF0ZSAtPiBtdXRhdGUgcGF0dGVybiBmb3Jcblx0XHQgICAgICAgIC8vIGV4Y2VwdGlvbiBzYWZldHkuXG5cdFx0ICAgICAgICBzaGlmdCgpIHsgLy8gbXVzdCBub3QgYmUgY2FsbGVkIG9uIGFuIGVtcHR5IHF1ZXVlXG5cdFx0ICAgICAgICAgICAgY29uc3Qgb2xkRnJvbnQgPSB0aGlzLl9mcm9udDtcblx0XHQgICAgICAgICAgICBsZXQgbmV3RnJvbnQgPSBvbGRGcm9udDtcblx0XHQgICAgICAgICAgICBjb25zdCBvbGRDdXJzb3IgPSB0aGlzLl9jdXJzb3I7XG5cdFx0ICAgICAgICAgICAgbGV0IG5ld0N1cnNvciA9IG9sZEN1cnNvciArIDE7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBvbGRGcm9udC5fZWxlbWVudHM7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW29sZEN1cnNvcl07XG5cdFx0ICAgICAgICAgICAgaWYgKG5ld0N1cnNvciA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUpIHtcblx0XHQgICAgICAgICAgICAgICAgbmV3RnJvbnQgPSBvbGRGcm9udC5fbmV4dDtcblx0XHQgICAgICAgICAgICAgICAgbmV3Q3Vyc29yID0gMDtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgLy8gTm8gbXV0YXRpb25zIGJlZm9yZSB0aGlzIHBvaW50LlxuXHRcdCAgICAgICAgICAgIC0tdGhpcy5fc2l6ZTtcblx0XHQgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBuZXdDdXJzb3I7XG5cdFx0ICAgICAgICAgICAgaWYgKG9sZEZyb250ICE9PSBuZXdGcm9udCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aGlzLl9mcm9udCA9IG5ld0Zyb250O1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAvLyBQZXJtaXQgc2hpZnRlZCBlbGVtZW50IHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuXHRcdCAgICAgICAgICAgIGVsZW1lbnRzW29sZEN1cnNvcl0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBUaGUgdHJpY2t5IHRoaW5nIGFib3V0IGZvckVhY2goKSBpcyB0aGF0IGl0IGNhbiBiZSBjYWxsZWRcblx0XHQgICAgICAgIC8vIHJlLWVudHJhbnRseS4gVGhlIHF1ZXVlIG1heSBiZSBtdXRhdGVkIGluc2lkZSB0aGUgY2FsbGJhY2suIEl0IGlzIGVhc3kgdG9cblx0XHQgICAgICAgIC8vIHNlZSB0aGF0IHB1c2goKSB3aXRoaW4gdGhlIGNhbGxiYWNrIGhhcyBubyBuZWdhdGl2ZSBlZmZlY3RzIHNpbmNlIHRoZSBlbmRcblx0XHQgICAgICAgIC8vIG9mIHRoZSBxdWV1ZSBpcyBjaGVja2VkIGZvciBvbiBldmVyeSBpdGVyYXRpb24uIElmIHNoaWZ0KCkgaXMgY2FsbGVkXG5cdFx0ICAgICAgICAvLyByZXBlYXRlZGx5IHdpdGhpbiB0aGUgY2FsbGJhY2sgdGhlbiB0aGUgbmV4dCBpdGVyYXRpb24gbWF5IHJldHVybiBhblxuXHRcdCAgICAgICAgLy8gZWxlbWVudCB0aGF0IGhhcyBiZWVuIHJlbW92ZWQuIEluIHRoaXMgY2FzZSB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcblx0XHQgICAgICAgIC8vIHdpdGggdW5kZWZpbmVkIHZhbHVlcyB1bnRpbCB3ZSBlaXRoZXIgXCJjYXRjaCB1cFwiIHdpdGggZWxlbWVudHMgdGhhdCBzdGlsbFxuXHRcdCAgICAgICAgLy8gZXhpc3Qgb3IgcmVhY2ggdGhlIGJhY2sgb2YgdGhlIHF1ZXVlLlxuXHRcdCAgICAgICAgZm9yRWFjaChjYWxsYmFjaykge1xuXHRcdCAgICAgICAgICAgIGxldCBpID0gdGhpcy5fY3Vyc29yO1xuXHRcdCAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5fZnJvbnQ7XG5cdFx0ICAgICAgICAgICAgbGV0IGVsZW1lbnRzID0gbm9kZS5fZWxlbWVudHM7XG5cdFx0ICAgICAgICAgICAgd2hpbGUgKGkgIT09IGVsZW1lbnRzLmxlbmd0aCB8fCBub2RlLl9uZXh0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKGkgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuX25leHQ7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IG5vZGUuX2VsZW1lbnRzO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgY2FsbGJhY2soZWxlbWVudHNbaV0pO1xuXHRcdCAgICAgICAgICAgICAgICArK2k7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gUmV0dXJuIHRoZSBlbGVtZW50IHRoYXQgd291bGQgYmUgcmV0dXJuZWQgaWYgc2hpZnQoKSB3YXMgY2FsbGVkIG5vdyxcblx0XHQgICAgICAgIC8vIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBxdWV1ZS5cblx0XHQgICAgICAgIHBlZWsoKSB7IC8vIG11c3Qgbm90IGJlIGNhbGxlZCBvbiBhbiBlbXB0eSBxdWV1ZVxuXHRcdCAgICAgICAgICAgIGNvbnN0IGZyb250ID0gdGhpcy5fZnJvbnQ7XG5cdFx0ICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5fY3Vyc29yO1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmcm9udC5fZWxlbWVudHNbY3Vyc29yXTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUocmVhZGVyLCBzdHJlYW0pIHtcblx0XHQgICAgICAgIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9IHN0cmVhbTtcblx0XHQgICAgICAgIHN0cmVhbS5fcmVhZGVyID0gcmVhZGVyO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZChyZWFkZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZChyZWFkZXIsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEEgY2xpZW50IG9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciBhbmQgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZVxuXHRcdCAgICAvLyBjaGVjay5cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHJlYWRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG5cdFx0ICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKSB7XG5cdFx0ICAgICAgICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgbmV3IFR5cGVFcnJvcihgUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZChyZWFkZXIsIG5ldyBUeXBlRXJyb3IoYFJlYWRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCkpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtLl9yZWFkZXIgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXG5cdFx0ICAgIGZ1bmN0aW9uIHJlYWRlckxvY2tFeGNlcHRpb24obmFtZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCAnICsgbmFtZSArICcgYSBzdHJlYW0gdXNpbmcgYSByZWxlYXNlZCByZWFkZXInKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLlxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKSB7XG5cdFx0ICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQgICAgICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0ICAgICAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCByZWFzb24pIHtcblx0XHQgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuXHRcdCAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCByZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQocmVhZGVyKSB7XG5cdFx0ICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcblx0XHQgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBpZiAocmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShyZWFkZXIuX2Nsb3NlZFByb21pc2UpO1xuXHRcdCAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuXHRcdCAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHJlYWRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgcmVhc29uKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKSB7XG5cdFx0ICAgICAgICBpZiAocmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBjb25zdCBBYm9ydFN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbQWJvcnRTdGVwc11dJyk7XG5cdFx0ICAgIGNvbnN0IEVycm9yU3RlcHMgPSBTeW1ib2xQb2x5ZmlsbCgnW1tFcnJvclN0ZXBzXV0nKTtcblx0XHQgICAgY29uc3QgQ2FuY2VsU3RlcHMgPSBTeW1ib2xQb2x5ZmlsbCgnW1tDYW5jZWxTdGVwc11dJyk7XG5cdFx0ICAgIGNvbnN0IFB1bGxTdGVwcyA9IFN5bWJvbFBvbHlmaWxsKCdbW1B1bGxTdGVwc11dJyk7XG5cblx0XHQgICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuXHRcdCAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNGaW5pdGUjUG9seWZpbGxcblx0XHQgICAgY29uc3QgTnVtYmVySXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gKHgpIHtcblx0XHQgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoeCk7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuXHRcdCAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jI1BvbHlmaWxsXG5cdFx0ICAgIGNvbnN0IE1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcblx0XHQgICAgICAgIHJldHVybiB2IDwgMCA/IE1hdGguY2VpbCh2KSA6IE1hdGguZmxvb3Iodik7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLWRpY3Rpb25hcmllc1xuXHRcdCAgICBmdW5jdGlvbiBpc0RpY3Rpb25hcnkoeCkge1xuXHRcdCAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBhc3NlcnREaWN0aW9uYXJ5KG9iaiwgY29udGV4dCkge1xuXHRcdCAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkICYmICFpc0RpY3Rpb25hcnkob2JqKSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIG9iamVjdC5gKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtY2FsbGJhY2stZnVuY3Rpb25zXG5cdFx0ICAgIGZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHgsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgZnVuY3Rpb24uYCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLW9iamVjdFxuXHRcdCAgICBmdW5jdGlvbiBpc09iamVjdCh4KSB7XG5cdFx0ICAgICAgICByZXR1cm4gKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBhc3NlcnRPYmplY3QoeCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgaWYgKCFpc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIG9iamVjdC5gKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHgsIHBvc2l0aW9uLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICR7cG9zaXRpb259IGlzIHJlcXVpcmVkIGluICcke2NvbnRleHR9Jy5gKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBhc3NlcnRSZXF1aXJlZEZpZWxkKHgsIGZpZWxkLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmaWVsZH0gaXMgcmVxdWlyZWQgaW4gJyR7Y29udGV4dH0nLmApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC11bnJlc3RyaWN0ZWQtZG91YmxlXG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUodmFsdWUpIHtcblx0XHQgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNlbnNvck5lZ2F0aXZlWmVybyh4KSB7XG5cdFx0ICAgICAgICByZXR1cm4geCA9PT0gMCA/IDAgOiB4O1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGludGVnZXJQYXJ0KHgpIHtcblx0XHQgICAgICAgIHJldHVybiBjZW5zb3JOZWdhdGl2ZVplcm8oTWF0aFRydW5jKHgpKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtdW5zaWduZWQtbG9uZy1sb25nXG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSh2YWx1ZSwgY29udGV4dCkge1xuXHRcdCAgICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IDA7XG5cdFx0ICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cdFx0ICAgICAgICBsZXQgeCA9IE51bWJlcih2YWx1ZSk7XG5cdFx0ICAgICAgICB4ID0gY2Vuc29yTmVnYXRpdmVaZXJvKHgpO1xuXHRcdCAgICAgICAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgZmluaXRlIG51bWJlcmApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgeCA9IGludGVnZXJQYXJ0KHgpO1xuXHRcdCAgICAgICAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBvdXRzaWRlIHRoZSBhY2NlcHRlZCByYW5nZSBvZiAke2xvd2VyQm91bmR9IHRvICR7dXBwZXJCb3VuZH0sIGluY2x1c2l2ZWApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSB8fCB4ID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIDA7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBUT0RPIFVzZSBCaWdJbnQgaWYgc3VwcG9ydGVkP1xuXHRcdCAgICAgICAgLy8gbGV0IHhCaWdJbnQgPSBCaWdJbnQoaW50ZWdlclBhcnQoeCkpO1xuXHRcdCAgICAgICAgLy8geEJpZ0ludCA9IEJpZ0ludC5hc1VpbnROKDY0LCB4QmlnSW50KTtcblx0XHQgICAgICAgIC8vIHJldHVybiBOdW1iZXIoeEJpZ0ludCk7XG5cdFx0ICAgICAgICByZXR1cm4geDtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGFzc2VydFJlYWRhYmxlU3RyZWFtKHgsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh4KSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgUmVhZGFibGVTdHJlYW0uYCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cdFx0ICAgIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0sIHJlYWRSZXF1ZXN0KSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX3JlYWRlci5fcmVhZFJlcXVlc3RzLnB1c2gocmVhZFJlcXVlc3QpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGRvbmUpIHtcblx0XHQgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSByZWFkZXIuX3JlYWRSZXF1ZXN0cy5zaGlmdCgpO1xuXHRcdCAgICAgICAgaWYgKGRvbmUpIHtcblx0XHQgICAgICAgICAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkge1xuXHRcdCAgICAgICAgcmV0dXJuIHN0cmVhbS5fcmVhZGVyLl9yZWFkUmVxdWVzdHMubGVuZ3RoO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pIHtcblx0XHQgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXHRcdCAgICAgICAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgIH1cblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEEgZGVmYXVsdCByZWFkZXIgdmVuZGVkIGJ5IGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtfS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuXHRcdCAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyJyk7XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHJlYWRpbmcgYnkgYW5vdGhlciByZWFkZXInKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSh0aGlzLCBzdHJlYW0pO1xuXHRcdCAgICAgICAgICAgIHRoaXMuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCxcblx0XHQgICAgICAgICAqIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3IgdGhlIHJlYWRlcidzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGNsb3NlZCgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgUmVhZGFibGVTdHJlYW0uY2FuY2VsIHwgc3RyZWFtLmNhbmNlbChyZWFzb24pfS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgY2FuY2VsKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwodGhpcywgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBhbGxvd3MgYWNjZXNzIHRvIHRoZSBuZXh0IGNodW5rIGZyb20gdGhlIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLCBpZiBhdmFpbGFibGUuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogSWYgcmVhZGluZyBhIGNodW5rIGNhdXNlcyB0aGUgcXVldWUgdG8gYmVjb21lIGVtcHR5LCBtb3JlIGRhdGEgd2lsbCBiZSBwdWxsZWQgZnJvbSB0aGUgdW5kZXJseWluZyBzb3VyY2UuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIHJlYWQoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdyZWFkIGZyb20nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGxldCByZXNvbHZlUHJvbWlzZTtcblx0XHQgICAgICAgICAgICBsZXQgcmVqZWN0UHJvbWlzZTtcblx0XHQgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcblx0XHQgICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcblx0XHQgICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSxcblx0XHQgICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KSxcblx0XHQgICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6IGUgPT4gcmVqZWN0UHJvbWlzZShlKVxuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCh0aGlzLCByZWFkUmVxdWVzdCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJlbGVhc2VzIHRoZSByZWFkZXIncyBsb2NrIG9uIHRoZSBjb3JyZXNwb25kaW5nIHN0cmVhbS4gQWZ0ZXIgdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgaXMgbm8gbG9uZ2VyIGFjdGl2ZS5cblx0XHQgICAgICAgICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXlcblx0XHQgICAgICAgICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIEEgcmVhZGVyJ3MgbG9jayBjYW5ub3QgYmUgcmVsZWFzZWQgd2hpbGUgaXQgc3RpbGwgaGFzIGEgcGVuZGluZyByZWFkIHJlcXVlc3QsIGkuZS4sIGlmIGEgcHJvbWlzZSByZXR1cm5lZCBieVxuXHRcdCAgICAgICAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xuXHRcdCAgICAgICAgICogZG8gc28gd2lsbCB0aHJvdyBhIGBUeXBlRXJyb3JgIGFuZCBsZWF2ZSB0aGUgcmVhZGVyIGxvY2tlZCB0byB0aGUgc3RyZWFtLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICByZWxlYXNlTG9jaygpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWRSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RyaWVkIHRvIHJlbGVhc2UgYSByZWFkZXIgbG9jayB3aGVuIHRoYXQgcmVhZGVyIGhhcyBwZW5kaW5nIHJlYWQoKSBjYWxscyB1bi1zZXR0bGVkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHJlYWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuXHRcdCAgICAgICAgICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSByZWFkZXJzLlxuXHRcdCAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZFJlcXVlc3RzJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcblx0XHQgICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhzdHJlYW0uX3N0b3JlZEVycm9yKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW1B1bGxTdGVwc10ocmVhZFJlcXVlc3QpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcmApO1xuXHRcdCAgICB9XG5cblx0XHQgICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE4LmFzeW5jaXRlcmFibGVcIiAvPlxuXHRcdCAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24gKi9cblx0XHQgICAgY29uc3QgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXN5bmMgZnVuY3Rpb24qICgpIHsgfSkucHJvdG90eXBlKTtcblxuXHRcdCAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTguYXN5bmNpdGVyYWJsZVwiIC8+XG5cdFx0ICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IocmVhZGVyLCBwcmV2ZW50Q2FuY2VsKSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgIHRoaXMuX3JlYWRlciA9IHJlYWRlcjtcblx0XHQgICAgICAgICAgICB0aGlzLl9wcmV2ZW50Q2FuY2VsID0gcHJldmVudENhbmNlbDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIG5leHQoKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgbmV4dFN0ZXBzID0gKCkgPT4gdGhpcy5fbmV4dFN0ZXBzKCk7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/XG5cdFx0ICAgICAgICAgICAgICAgIHRyYW5zZm9ybVByb21pc2VXaXRoKHRoaXMuX29uZ29pbmdQcm9taXNlLCBuZXh0U3RlcHMsIG5leHRTdGVwcykgOlxuXHRcdCAgICAgICAgICAgICAgICBuZXh0U3RlcHMoKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4odmFsdWUpIHtcblx0XHQgICAgICAgICAgICBjb25zdCByZXR1cm5TdGVwcyA9ICgpID0+IHRoaXMuX3JldHVyblN0ZXBzKHZhbHVlKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2UgP1xuXHRcdCAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0aGlzLl9vbmdvaW5nUHJvbWlzZSwgcmV0dXJuU3RlcHMsIHJldHVyblN0ZXBzKSA6XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVyblN0ZXBzKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBfbmV4dFN0ZXBzKCkge1xuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkZXI7XG5cdFx0ICAgICAgICAgICAgaWYgKHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2l0ZXJhdGUnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGxldCByZXNvbHZlUHJvbWlzZTtcblx0XHQgICAgICAgICAgICBsZXQgcmVqZWN0UHJvbWlzZTtcblx0XHQgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcblx0XHQgICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcblx0XHQgICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGJ5IG9uZSBtaWNyb3Rhc2ssIG90aGVyd2lzZSB3ZSBzdG9wIHB1bGxpbmcgdG9vIGVhcmx5IHdoaWNoIGJyZWFrcyBhIHRlc3QuXG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBJcyB0aGlzIGEgYnVnIGluIHRoZSBzcGVjaWZpY2F0aW9uLCBvciBpbiB0aGUgdGVzdD9cblx0XHQgICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSk7XG5cdFx0ICAgICAgICAgICAgICAgIH0sXG5cdFx0ICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuXHRcdCAgICAgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogcmVhc29uID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlKHJlYXNvbik7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9O1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBfcmV0dXJuU3RlcHModmFsdWUpIHtcblx0XHQgICAgICAgICAgICBpZiAodGhpcy5faXNGaW5pc2hlZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuX3JlYWRlcjtcblx0XHQgICAgICAgICAgICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbignZmluaXNoIGl0ZXJhdGluZycpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKCF0aGlzLl9wcmV2ZW50Q2FuY2VsKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbChyZWFkZXIsIHZhbHVlKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgocmVzdWx0LCAoKSA9PiAoeyB2YWx1ZSwgZG9uZTogdHJ1ZSB9KSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh7IHZhbHVlLCBkb25lOiB0cnVlIH0pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IHtcblx0XHQgICAgICAgIG5leHQoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbignbmV4dCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLm5leHQoKTtcblx0XHQgICAgICAgIH0sXG5cdFx0ICAgICAgICByZXR1cm4odmFsdWUpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXR1cm4nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hc3luY0l0ZXJhdG9ySW1wbC5yZXR1cm4odmFsdWUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9O1xuXHRcdCAgICBpZiAoQXN5bmNJdGVyYXRvclByb3RvdHlwZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cdFx0ICAgIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtLCBwcmV2ZW50Q2FuY2VsKSB7XG5cdFx0ICAgICAgICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG5cdFx0ICAgICAgICBjb25zdCBpbXBsID0gbmV3IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwocmVhZGVyLCBwcmV2ZW50Q2FuY2VsKTtcblx0XHQgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXHRcdCAgICAgICAgaXRlcmF0b3IuX2FzeW5jSXRlcmF0b3JJbXBsID0gaW1wbDtcblx0XHQgICAgICAgIHJldHVybiBpdGVyYXRvcjtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXN5bmNJdGVyYXRvckltcGwnKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFN1c3BpY2lvdXNUeXBlT2ZHdWFyZFxuXHRcdCAgICAgICAgICAgIHJldHVybiB4Ll9hc3luY0l0ZXJhdG9ySW1wbCBpbnN0YW5jZW9mXG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGw7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjYXRjaCAoX2EpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXHRcdCAgICBmdW5jdGlvbiBzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RlYW1Bc3luY0l0ZXJhdG9yYCk7XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuY29yZVwiIC8+XG5cdFx0ICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc05hTiNQb2x5ZmlsbFxuXHRcdCAgICBjb25zdCBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAoeCkge1xuXHRcdCAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXHRcdCAgICAgICAgcmV0dXJuIHggIT09IHg7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgZnVuY3Rpb24gQ3JlYXRlQXJyYXlGcm9tTGlzdChlbGVtZW50cykge1xuXHRcdCAgICAgICAgLy8gV2UgdXNlIGFycmF5cyB0byByZXByZXNlbnQgbGlzdHMsIHNvIHRoaXMgaXMgYmFzaWNhbGx5IGEgbm8tb3AuXG5cdFx0ICAgICAgICAvLyBEbyBhIHNsaWNlIHRob3VnaCBqdXN0IGluIGNhc2Ugd2UgaGFwcGVuIHRvIGRlcGVuZCBvbiB0aGUgdW5pcXVlLW5lc3MuXG5cdFx0ICAgICAgICByZXR1cm4gZWxlbWVudHMuc2xpY2UoKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBDb3B5RGF0YUJsb2NrQnl0ZXMoZGVzdCwgZGVzdE9mZnNldCwgc3JjLCBzcmNPZmZzZXQsIG4pIHtcblx0XHQgICAgICAgIG5ldyBVaW50OEFycmF5KGRlc3QpLnNldChuZXcgVWludDhBcnJheShzcmMsIHNyY09mZnNldCwgbiksIGRlc3RPZmZzZXQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHlcblx0XHQgICAgZnVuY3Rpb24gVHJhbnNmZXJBcnJheUJ1ZmZlcihPKSB7XG5cdFx0ICAgICAgICByZXR1cm4gTztcblx0XHQgICAgfVxuXHRcdCAgICAvLyBOb3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5XG5cdFx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcblx0XHQgICAgZnVuY3Rpb24gSXNEZXRhY2hlZEJ1ZmZlcihPKSB7XG5cdFx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gQXJyYXlCdWZmZXJTbGljZShidWZmZXIsIGJlZ2luLCBlbmQpIHtcblx0XHQgICAgICAgIC8vIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3QgYXZhaWxhYmxlIG9uIElFMTBcblx0XHQgICAgICAgIC8vIGh0dHBzOi8vd3d3LmNhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX2FycmF5YnVmZmVyX3NsaWNlXG5cdFx0ICAgICAgICBpZiAoYnVmZmVyLnNsaWNlKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZShiZWdpbiwgZW5kKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCAtIGJlZ2luO1xuXHRcdCAgICAgICAgY29uc3Qgc2xpY2UgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcblx0XHQgICAgICAgIENvcHlEYXRhQmxvY2tCeXRlcyhzbGljZSwgMCwgYnVmZmVyLCBiZWdpbiwgbGVuZ3RoKTtcblx0XHQgICAgICAgIHJldHVybiBzbGljZTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIElzTm9uTmVnYXRpdmVOdW1iZXIodikge1xuXHRcdCAgICAgICAgaWYgKHR5cGVvZiB2ICE9PSAnbnVtYmVyJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChOdW1iZXJJc05hTih2KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh2IDwgMCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIENsb25lQXNVaW50OEFycmF5KE8pIHtcblx0XHQgICAgICAgIGNvbnN0IGJ1ZmZlciA9IEFycmF5QnVmZmVyU2xpY2UoTy5idWZmZXIsIE8uYnl0ZU9mZnNldCwgTy5ieXRlT2Zmc2V0ICsgTy5ieXRlTGVuZ3RoKTtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gRGVxdWV1ZVZhbHVlKGNvbnRhaW5lcikge1xuXHRcdCAgICAgICAgY29uc3QgcGFpciA9IGNvbnRhaW5lci5fcXVldWUuc2hpZnQoKTtcblx0XHQgICAgICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgLT0gcGFpci5zaXplO1xuXHRcdCAgICAgICAgaWYgKGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPCAwKSB7XG5cdFx0ICAgICAgICAgICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA9IDA7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gcGFpci52YWx1ZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250YWluZXIsIHZhbHVlLCBzaXplKSB7XG5cdFx0ICAgICAgICBpZiAoIUlzTm9uTmVnYXRpdmVOdW1iZXIoc2l6ZSkgfHwgc2l6ZSA9PT0gSW5maW5pdHkpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignU2l6ZSBtdXN0IGJlIGEgZmluaXRlLCBub24tTmFOLCBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29udGFpbmVyLl9xdWV1ZS5wdXNoKHsgdmFsdWUsIHNpemUgfSk7XG5cdFx0ICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplICs9IHNpemU7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUGVla1F1ZXVlVmFsdWUoY29udGFpbmVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5wZWVrKCk7XG5cdFx0ICAgICAgICByZXR1cm4gcGFpci52YWx1ZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZXNldFF1ZXVlKGNvbnRhaW5lcikge1xuXHRcdCAgICAgICAgY29udGFpbmVyLl9xdWV1ZSA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA9IDA7XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvKipcblx0XHQgICAgICogQSBwdWxsLWludG8gcmVxdWVzdCBpbiBhIHtAbGluayBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyfS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB7XG5cdFx0ICAgICAgICBjb25zdHJ1Y3RvcigpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJldHVybnMgdGhlIHZpZXcgZm9yIHdyaXRpbmcgaW4gdG8sIG9yIGBudWxsYCBpZiB0aGUgQllPQiByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gcmVzcG9uZGVkIHRvLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgdmlldygpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3ZpZXcnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXc7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXNwb25kKGJ5dGVzV3JpdHRlbikge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigncmVzcG9uZCcpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGJ5dGVzV3JpdHRlbiwgMSwgJ3Jlc3BvbmQnKTtcblx0XHQgICAgICAgICAgICBieXRlc1dyaXR0ZW4gPSBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoYnl0ZXNXcml0dGVuLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodGhpcy5fdmlldy5idWZmZXIpKSA7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXNwb25kV2l0aE5ld1ZpZXcodmlldykge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQodmlldywgMSwgJ3Jlc3BvbmRXaXRoTmV3VmlldycpO1xuXHRcdCAgICAgICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW4gb25seSByZXNwb25kIHdpdGggYXJyYXkgYnVmZmVyIHZpZXdzJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHZpZXcuYnVmZmVyKSkgO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIHZpZXcpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLCB7XG5cdFx0ICAgICAgICByZXNwb25kOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHJlc3BvbmRXaXRoTmV3VmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICB2aWV3OiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QnLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgYnl0ZSBzdHJlYW19J3Mgc3RhdGUgYW5kIGludGVybmFsIHF1ZXVlLlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBCWU9CIHB1bGwgcmVxdWVzdCwgb3IgYG51bGxgIGlmIHRoZXJlIGlzbid0IG9uZS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGJ5b2JSZXF1ZXN0KCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYnlvYlJlcXVlc3QnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdCh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIGNvbnRyb2xsZWQgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzXG5cdFx0ICAgICAgICAgKiBvdmVyLWZ1bGwuIEFuIHVuZGVybHlpbmcgYnl0ZSBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCBkZXNpcmVkU2l6ZSgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxuXHRcdCAgICAgICAgICogdGhlIHN0cmVhbSwgYnV0IG9uY2UgdGhvc2UgYXJlIHJlYWQsIHRoZSBzdHJlYW0gd2lsbCBiZWNvbWUgY2xvc2VkLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBjbG9zZSgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkOyBkbyBub3QgY2xvc2UgaXQgYWdhaW4hJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICAgICAgaWYgKHN0YXRlICE9PSAncmVhZGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7c3RhdGV9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgY2xvc2VkYCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVucXVldWUoY2h1bmspIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChjaHVuaywgMSwgJ2VucXVldWUnKTtcblx0XHQgICAgICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2h1bmsgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlldycpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaHVuayBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aCcpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoY2h1bmsuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgY2h1bmsncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhgKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmVhbSBpcyBjbG9zZWQgb3IgZHJhaW5pbmcnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgICAgICBpZiAoc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtzdGF0ZX0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgcmVhZGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBlbnF1ZXVlZCB0b2ApO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBlcnJvcihlID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IodGhpcywgZSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKiogQGludGVybmFsICovXG5cdFx0ICAgICAgICBbQ2FuY2VsU3RlcHNdKHJlYXNvbikge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3ModGhpcyk7XG5cdFx0ICAgICAgICAgICAgUmVzZXRRdWV1ZSh0aGlzKTtcblx0XHQgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKiogQGludGVybmFsICovXG5cdFx0ICAgICAgICBbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCkge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cdFx0ICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlVG90YWxTaXplIC09IGVudHJ5LmJ5dGVMZW5ndGg7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKHRoaXMpO1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW50cnkuYnVmZmVyLCBlbnRyeS5ieXRlT2Zmc2V0LCBlbnRyeS5ieXRlTGVuZ3RoKTtcblx0XHQgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHModmlldyk7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdGhpcy5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuXHRcdCAgICAgICAgICAgIGlmIChhdXRvQWxsb2NhdGVDaHVua1NpemUgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICBsZXQgYnVmZmVyO1xuXHRcdCAgICAgICAgICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgY2F0Y2ggKGJ1ZmZlckUpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKGJ1ZmZlckUpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcixcblx0XHQgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckJ5dGVMZW5ndGg6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcblx0XHQgICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IDAsXG5cdFx0ICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoOiBhdXRvQWxsb2NhdGVDaHVua1NpemUsXG5cdFx0ICAgICAgICAgICAgICAgICAgICBieXRlc0ZpbGxlZDogMCxcblx0XHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTaXplOiAxLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgdmlld0NvbnN0cnVjdG9yOiBVaW50OEFycmF5LFxuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVhZGVyVHlwZTogJ2RlZmF1bHQnXG5cdFx0ICAgICAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0KHN0cmVhbSwgcmVhZFJlcXVlc3QpO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCB7XG5cdFx0ICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGJ5b2JSZXF1ZXN0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbScpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzaG91bGRQdWxsID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgaWYgKCFzaG91bGRQdWxsKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxpbmcpIHtcblx0XHQgICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSB0cnVlO1xuXHRcdCAgICAgICAgLy8gVE9ETzogVGVzdCBjb250cm9sbGVyIGFyZ3VtZW50XG5cdFx0ICAgICAgICBjb25zdCBwdWxsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0oKTtcblx0XHQgICAgICAgIHVwb25Qcm9taXNlKHB1bGxQcm9taXNlLCAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsQWdhaW4pIHtcblx0XHQgICAgICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0sIGUgPT4ge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKHN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG5cdFx0ICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKTtcblx0XHQgICAgICAgIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IucmVhZGVyVHlwZSA9PT0gJ2RlZmF1bHQnKSB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCBmaWxsZWRWaWV3LCBkb25lKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIGZpbGxlZFZpZXcsIGRvbmUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yKHB1bGxJbnRvRGVzY3JpcHRvcikge1xuXHRcdCAgICAgICAgY29uc3QgYnl0ZXNGaWxsZWQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG5cdFx0ICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcblx0XHQgICAgICAgIHJldHVybiBuZXcgcHVsbEludG9EZXNjcmlwdG9yLnZpZXdDb25zdHJ1Y3RvcihwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCwgYnl0ZXNGaWxsZWQgLyBlbGVtZW50U2l6ZSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9xdWV1ZS5wdXNoKHsgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0pO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgKz0gYnl0ZUxlbmd0aDtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcblx0XHQgICAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuXHRcdCAgICAgICAgY29uc3QgY3VycmVudEFsaWduZWRCeXRlcyA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAlIGVsZW1lbnRTaXplO1xuXHRcdCAgICAgICAgY29uc3QgbWF4Qnl0ZXNUb0NvcHkgPSBNYXRoLm1pbihjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVMZW5ndGggLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQpO1xuXHRcdCAgICAgICAgY29uc3QgbWF4Qnl0ZXNGaWxsZWQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyBtYXhCeXRlc1RvQ29weTtcblx0XHQgICAgICAgIGNvbnN0IG1heEFsaWduZWRCeXRlcyA9IG1heEJ5dGVzRmlsbGVkIC0gbWF4Qnl0ZXNGaWxsZWQgJSBlbGVtZW50U2l6ZTtcblx0XHQgICAgICAgIGxldCB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID0gbWF4Qnl0ZXNUb0NvcHk7XG5cdFx0ICAgICAgICBsZXQgcmVhZHkgPSBmYWxzZTtcblx0XHQgICAgICAgIGlmIChtYXhBbGlnbmVkQnl0ZXMgPiBjdXJyZW50QWxpZ25lZEJ5dGVzKSB7XG5cdFx0ICAgICAgICAgICAgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA9IG1heEFsaWduZWRCeXRlcyAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcblx0XHQgICAgICAgICAgICByZWFkeSA9IHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBxdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlO1xuXHRcdCAgICAgICAgd2hpbGUgKHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgaGVhZE9mUXVldWUgPSBxdWV1ZS5wZWVrKCk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgYnl0ZXNUb0NvcHkgPSBNYXRoLm1pbih0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nLCBoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoKTtcblx0XHQgICAgICAgICAgICBjb25zdCBkZXN0U3RhcnQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcblx0XHQgICAgICAgICAgICBDb3B5RGF0YUJsb2NrQnl0ZXMocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgZGVzdFN0YXJ0LCBoZWFkT2ZRdWV1ZS5idWZmZXIsIGhlYWRPZlF1ZXVlLmJ5dGVPZmZzZXQsIGJ5dGVzVG9Db3B5KTtcblx0XHQgICAgICAgICAgICBpZiAoaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCA9PT0gYnl0ZXNUb0NvcHkpIHtcblx0XHQgICAgICAgICAgICAgICAgcXVldWUuc2hpZnQoKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGhlYWRPZlF1ZXVlLmJ5dGVPZmZzZXQgKz0gYnl0ZXNUb0NvcHk7XG5cdFx0ICAgICAgICAgICAgICAgIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGggLT0gYnl0ZXNUb0NvcHk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplIC09IGJ5dGVzVG9Db3B5O1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBieXRlc1RvQ29weSwgcHVsbEludG9EZXNjcmlwdG9yKTtcblx0XHQgICAgICAgICAgICB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nIC09IGJ5dGVzVG9Db3B5O1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHJlYWR5O1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBzaXplLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcblx0XHQgICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArPSBzaXplO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCAmJiBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCkge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QuX3ZpZXcgPSBudWxsO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBudWxsO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgd2hpbGUgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuXHRcdCAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuXHRcdCAgICAgICAgICAgIGlmIChSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8oY29udHJvbGxlciwgdmlldywgcmVhZEludG9SZXF1ZXN0KSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXHRcdCAgICAgICAgbGV0IGVsZW1lbnRTaXplID0gMTtcblx0XHQgICAgICAgIGlmICh2aWV3LmNvbnN0cnVjdG9yICE9PSBEYXRhVmlldykge1xuXHRcdCAgICAgICAgICAgIGVsZW1lbnRTaXplID0gdmlldy5jb25zdHJ1Y3Rvci5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IGN0b3IgPSB2aWV3LmNvbnN0cnVjdG9yO1xuXHRcdCAgICAgICAgLy8gdHJ5IHtcblx0XHQgICAgICAgIGNvbnN0IGJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIodmlldy5idWZmZXIpO1xuXHRcdCAgICAgICAgLy8gfSBjYXRjaCAoZSkge1xuXHRcdCAgICAgICAgLy8gICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG5cdFx0ICAgICAgICAvLyAgIHJldHVybjtcblx0XHQgICAgICAgIC8vIH1cblx0XHQgICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IHtcblx0XHQgICAgICAgICAgICBidWZmZXIsXG5cdFx0ICAgICAgICAgICAgYnVmZmVyQnl0ZUxlbmd0aDogYnVmZmVyLmJ5dGVMZW5ndGgsXG5cdFx0ICAgICAgICAgICAgYnl0ZU9mZnNldDogdmlldy5ieXRlT2Zmc2V0LFxuXHRcdCAgICAgICAgICAgIGJ5dGVMZW5ndGg6IHZpZXcuYnl0ZUxlbmd0aCxcblx0XHQgICAgICAgICAgICBieXRlc0ZpbGxlZDogMCxcblx0XHQgICAgICAgICAgICBlbGVtZW50U2l6ZSxcblx0XHQgICAgICAgICAgICB2aWV3Q29uc3RydWN0b3I6IGN0b3IsXG5cdFx0ICAgICAgICAgICAgcmVhZGVyVHlwZTogJ2J5b2InXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXHRcdCAgICAgICAgICAgIC8vIE5vIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKCkgY2FsbCBzaW5jZTpcblx0XHQgICAgICAgICAgICAvLyAtIE5vIGNoYW5nZSBoYXBwZW5zIG9uIGRlc2lyZWRTaXplXG5cdFx0ICAgICAgICAgICAgLy8gLSBUaGUgc291cmNlIGhhcyBhbHJlYWR5IGJlZW4gbm90aWZpZWQgb2YgdGhhdCB0aGVyZSdzIGF0IGxlYXN0IDEgcGVuZGluZyByZWFkKHZpZXcpXG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpO1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGVtcHR5VmlldyA9IG5ldyBjdG9yKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCAwKTtcblx0XHQgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Nsb3NlU3RlcHMoZW1wdHlWaWV3KTtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgZmlsbGVkVmlldyA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yKHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoZmlsbGVkVmlldyk7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcblx0XHQgICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cdFx0ICAgICAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCk7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUoY29udHJvbGxlciwgZmlyc3REZXNjcmlwdG9yKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXHRcdCAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW0pKSB7XG5cdFx0ICAgICAgICAgICAgd2hpbGUgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3IgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3Ioc3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZShjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuXHRcdCAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgcHVsbEludG9EZXNjcmlwdG9yKTtcblx0XHQgICAgICAgIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPCBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemUpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBjb25zdCByZW1haW5kZXJTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuXHRcdCAgICAgICAgaWYgKHJlbWFpbmRlclNpemUgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZW5kID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVtYWluZGVyID0gQXJyYXlCdWZmZXJTbGljZShwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBlbmQgLSByZW1haW5kZXJTaXplLCBlbmQpO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHJlbWFpbmRlciwgMCwgcmVtYWluZGVyLmJ5dGVMZW5ndGgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIC09IHJlbWFpbmRlclNpemU7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKSB7XG5cdFx0ICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcblx0XHQgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgZmlyc3REZXNjcmlwdG9yKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5zaGlmdCgpO1xuXHRcdCAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgZGVzaXJlZFNpemUgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBpZiAoZGVzaXJlZFNpemUgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEEgY2xpZW50IG9mIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblx0XHQgICAgICAgIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCB8fCBzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZmlyc3RQZW5kaW5nUHVsbEludG8gPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcblx0XHQgICAgICAgICAgICBpZiAoZmlyc3RQZW5kaW5nUHVsbEludG8uYnl0ZXNGaWxsZWQgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBidWZmZXIgPSBjaHVuay5idWZmZXI7XG5cdFx0ICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gY2h1bmsuYnl0ZU9mZnNldDtcblx0XHQgICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBjaHVuay5ieXRlTGVuZ3RoO1xuXHRcdCAgICAgICAgY29uc3QgdHJhbnNmZXJyZWRCdWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGJ1ZmZlcik7XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZmlyc3RQZW5kaW5nUHVsbEludG8gPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcblx0XHQgICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpKSA7XG5cdFx0ICAgICAgICAgICAgZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSkge1xuXHRcdCAgICAgICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2ZlcnJlZFZpZXcgPSBuZXcgVWludDhBcnJheSh0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgdHJhbnNmZXJyZWRWaWV3LCBmYWxzZSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcblx0XHQgICAgICAgICAgICAvLyBUT0RPOiBJZGVhbGx5IGluIHRoaXMgYnJhbmNoIGRldGFjaGluZyBzaG91bGQgaGFwcGVuIG9ubHkgaWYgdGhlIGJ1ZmZlciBpcyBub3QgY29uc3VtZWQgZnVsbHkuXG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSkge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwgJiYgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGZpcnN0RGVzY3JpcHRvci5idWZmZXIsIGZpcnN0RGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkLCBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCAtIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgYnlvYlJlcXVlc3QgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlKTtcblx0XHQgICAgICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QoYnlvYlJlcXVlc3QsIGNvbnRyb2xsZXIsIHZpZXcpO1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gYnlvYlJlcXVlc3Q7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gY29udHJvbGxlci5fYnlvYlJlcXVlc3Q7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiAwO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKSB7XG5cdFx0ICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKGJ5dGVzV3JpdHRlbiAhPT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1dyaXR0ZW4gbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSBjbG9zZWQgc3RyZWFtJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1dyaXR0ZW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gMCB3aGVuIGNhbGxpbmcgcmVzcG9uZCgpIG9uIGEgcmVhZGFibGUgc3RyZWFtJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyBieXRlc1dyaXR0ZW4gPiBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYnl0ZXNXcml0dGVuIG91dCBvZiByYW5nZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZpcnN0RGVzY3JpcHRvci5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGZpcnN0RGVzY3JpcHRvci5idWZmZXIpO1xuXHRcdCAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoY29udHJvbGxlciwgdmlldykge1xuXHRcdCAgICAgICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG5cdFx0ICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggIT09IDApIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZpZXdcXCdzIGxlbmd0aCBtdXN0IGJlIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgY2xvc2VkIHN0cmVhbScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZpZXdcXCdzIGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kV2l0aE5ld1ZpZXcoKSBvbiBhIHJlYWRhYmxlIHN0cmVhbScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZU9mZnNldCArIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAhPT0gdmlldy5ieXRlT2Zmc2V0KSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSByZWdpb24gc3BlY2lmaWVkIGJ5IHZpZXcgZG9lcyBub3QgbWF0Y2ggYnlvYlJlcXVlc3QnKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnVmZmVyQnl0ZUxlbmd0aCAhPT0gdmlldy5idWZmZXIuYnl0ZUxlbmd0aCkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgYnVmZmVyIG9mIHZpZXcgaGFzIGRpZmZlcmVudCBjYXBhY2l0eSB0aGFuIGJ5b2JSZXF1ZXN0Jyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgdmlldy5ieXRlTGVuZ3RoID4gZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGgpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHJlZ2lvbiBzcGVjaWZpZWQgYnkgdmlldyBpcyBsYXJnZXIgdGhhbiBieW9iUmVxdWVzdCcpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3Qgdmlld0J5dGVMZW5ndGggPSB2aWV3LmJ5dGVMZW5ndGg7XG5cdFx0ICAgICAgICBmaXJzdERlc2NyaXB0b3IuYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcih2aWV3LmJ1ZmZlcik7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsKGNvbnRyb2xsZXIsIHZpZXdCeXRlTGVuZ3RoKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBhdXRvQWxsb2NhdGVDaHVua1NpemUpIHtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0gPSBzdHJlYW07XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gbnVsbDtcblx0XHQgICAgICAgIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxuXHRcdCAgICAgICAgY29udHJvbGxlci5fcXVldWUgPSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHB1bGxBbGdvcml0aG07XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9hdXRvQWxsb2NhdGVDaHVua1NpemUgPSBhdXRvQWxsb2NhdGVDaHVua1NpemU7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cdFx0ICAgICAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfSwgciA9PiB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIHIpO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2Uoc3RyZWFtLCB1bmRlcmx5aW5nQnl0ZVNvdXJjZSwgaGlnaFdhdGVyTWFyaykge1xuXHRcdCAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xuXHRcdCAgICAgICAgbGV0IHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgbGV0IHB1bGxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBsZXQgY2FuY2VsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdCeXRlU291cmNlLnN0YXJ0KGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLnB1bGwgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHB1bGxBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5wdWxsKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLmNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgY2FuY2VsQWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdCeXRlU291cmNlLmNhbmNlbChyZWFzb24pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdW5kZXJseWluZ0J5dGVTb3VyY2UuYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuXHRcdCAgICAgICAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBhdXRvQWxsb2NhdGVDaHVua1NpemUpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdChyZXF1ZXN0LCBjb250cm9sbGVyLCB2aWV3KSB7XG5cdFx0ICAgICAgICByZXF1ZXN0Ll9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICByZXF1ZXN0Ll92aWV3ID0gdmlldztcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5cblx0XHQgICAgZnVuY3Rpb24gYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0YCk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcmApO1xuXHRcdCAgICB9XG5cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXHRcdCAgICBmdW5jdGlvbiBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBSZWFkYWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgcmVhZEludG9SZXF1ZXN0KSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX3JlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5wdXNoKHJlYWRJbnRvUmVxdWVzdCk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGRvbmUpIHtcblx0XHQgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZEludG9SZXF1ZXN0ID0gcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLnNoaWZ0KCk7XG5cdFx0ICAgICAgICBpZiAoZG9uZSkge1xuXHRcdCAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pIHtcblx0XHQgICAgICAgIHJldHVybiBzdHJlYW0uX3JlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5sZW5ndGg7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkge1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cdFx0ICAgICAgICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgfVxuXHRcdCAgICAvKipcblx0XHQgICAgICogQSBCWU9CIHJlYWRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW19LlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXInKTtcblx0XHQgICAgICAgICAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlcicpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBmb3IgYSBzdHJlYW0gbm90IGNvbnN0cnVjdGVkIHdpdGggYSBieXRlICcgK1xuXHRcdCAgICAgICAgICAgICAgICAgICAgJ3NvdXJjZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCwgb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvclxuXHRcdCAgICAgICAgICogdGhlIHJlYWRlcidzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGNsb3NlZCgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgUmVhZGFibGVTdHJlYW0uY2FuY2VsIHwgc3RyZWFtLmNhbmNlbChyZWFzb24pfS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgY2FuY2VsKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwodGhpcywgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogQXR0ZW1wdHMgdG8gcmVhZHMgYnl0ZXMgaW50byB2aWV3LCBhbmQgcmV0dXJucyBhIHByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0LlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIElmIHJlYWRpbmcgYSBjaHVuayBjYXVzZXMgdGhlIHF1ZXVlIHRvIGJlY29tZSBlbXB0eSwgbW9yZSBkYXRhIHdpbGwgYmUgcHVsbGVkIGZyb20gdGhlIHVuZGVybHlpbmcgc291cmNlLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICByZWFkKHZpZXcpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3IG11c3QgYmUgYW4gYXJyYXkgYnVmZmVyIHZpZXcnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcigndmlldyBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHZpZXcuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihgdmlldydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aGApKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKSA7XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdyZWFkIGZyb20nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGxldCByZXNvbHZlUHJvbWlzZTtcblx0XHQgICAgICAgICAgICBsZXQgcmVqZWN0UHJvbWlzZTtcblx0XHQgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcblx0XHQgICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICBjb25zdCByZWFkSW50b1JlcXVlc3QgPSB7XG5cdFx0ICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSksXG5cdFx0ICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogdHJ1ZSB9KSxcblx0XHQgICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6IGUgPT4gcmVqZWN0UHJvbWlzZShlKVxuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZCh0aGlzLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZWxlYXNlcyB0aGUgcmVhZGVyJ3MgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXG5cdFx0ICAgICAgICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5XG5cdFx0ICAgICAgICAgKiBmcm9tIG5vdyBvbjsgb3RoZXJ3aXNlLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGNsb3NlZC5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBBIHJlYWRlcidzIGxvY2sgY2Fubm90IGJlIHJlbGVhc2VkIHdoaWxlIGl0IHN0aWxsIGhhcyBhIHBlbmRpbmcgcmVhZCByZXF1ZXN0LCBpLmUuLCBpZiBhIHByb21pc2UgcmV0dXJuZWQgYnlcblx0XHQgICAgICAgICAqIHRoZSByZWFkZXIncyB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnJlYWQgfCByZWFkKCl9IG1ldGhvZCBoYXMgbm90IHlldCBiZWVuIHNldHRsZWQuIEF0dGVtcHRpbmcgdG9cblx0XHQgICAgICAgICAqIGRvIHNvIHdpbGwgdGhyb3cgYSBgVHlwZUVycm9yYCBhbmQgbGVhdmUgdGhlIHJlYWRlciBsb2NrZWQgdG8gdGhlIHN0cmVhbS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgcmVsZWFzZUxvY2soKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aCA+IDApIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHJpZWQgdG8gcmVsZWFzZSBhIHJlYWRlciBsb2NrIHdoZW4gdGhhdCByZWFkZXIgaGFzIHBlbmRpbmcgcmVhZCgpIGNhbGxzIHVuLXNldHRsZWQnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLCB7XG5cdFx0ICAgICAgICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXInLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXG5cdFx0ICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkSW50b1JlcXVlc3RzJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHJlYWRlciwgdmlldywgcmVhZEludG9SZXF1ZXN0KSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcmApO1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIGRlZmF1bHRIV00pIHtcblx0XHQgICAgICAgIGNvbnN0IHsgaGlnaFdhdGVyTWFyayB9ID0gc3RyYXRlZ3k7XG5cdFx0ICAgICAgICBpZiAoaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRIV007XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoTnVtYmVySXNOYU4oaGlnaFdhdGVyTWFyaykgfHwgaGlnaFdhdGVyTWFyayA8IDApIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBoaWdoV2F0ZXJNYXJrJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gaGlnaFdhdGVyTWFyaztcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSkge1xuXHRcdCAgICAgICAgY29uc3QgeyBzaXplIH0gPSBzdHJhdGVneTtcblx0XHQgICAgICAgIGlmICghc2l6ZSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiAoKSA9PiAxO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHNpemU7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KGluaXQsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydERpY3Rpb25hcnkoaW5pdCwgY29udGV4dCk7XG5cdFx0ICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmhpZ2hXYXRlck1hcms7XG5cdFx0ICAgICAgICBjb25zdCBzaXplID0gaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LnNpemU7XG5cdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IGhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoaGlnaFdhdGVyTWFyayksXG5cdFx0ICAgICAgICAgICAgc2l6ZTogc2l6ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUoc2l6ZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2l6ZScgdGhhdGApXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplKGZuLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG5cdFx0ICAgICAgICByZXR1cm4gY2h1bmsgPT4gY29udmVydFVucmVzdHJpY3RlZERvdWJsZShmbihjaHVuaykpO1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rKG9yaWdpbmFsLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9yaWdpbmFsLCBjb250ZXh0KTtcblx0XHQgICAgICAgIGNvbnN0IGFib3J0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmFib3J0O1xuXHRcdCAgICAgICAgY29uc3QgY2xvc2UgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuY2xvc2U7XG5cdFx0ICAgICAgICBjb25zdCBzdGFydCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5zdGFydDtcblx0XHQgICAgICAgIGNvbnN0IHR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHlwZTtcblx0XHQgICAgICAgIGNvbnN0IHdyaXRlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLndyaXRlO1xuXHRcdCAgICAgICAgcmV0dXJuIHtcblx0XHQgICAgICAgICAgICBhYm9ydDogYWJvcnQgPT09IHVuZGVmaW5lZCA/XG5cdFx0ICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2soYWJvcnQsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdhYm9ydCcgdGhhdGApLFxuXHRcdCAgICAgICAgICAgIGNsb3NlOiBjbG9zZSA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayhjbG9zZSwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2Nsb3NlJyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuXHRcdCAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuXHRcdCAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcblx0XHQgICAgICAgICAgICB3cml0ZTogd3JpdGUgPT09IHVuZGVmaW5lZCA/XG5cdFx0ICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2sod3JpdGUsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd3cml0ZScgdGhhdGApLFxuXHRcdCAgICAgICAgICAgIHR5cGVcblx0XHQgICAgICAgIH07XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiAocmVhc29uKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuICgpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW10pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG5cdFx0ICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChjaHVuaywgY29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGFzc2VydFdyaXRhYmxlU3RyZWFtKHgsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh4KSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgV3JpdGFibGVTdHJlYW0uYCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBpc0Fib3J0U2lnbmFsKHZhbHVlKSB7XG5cdFx0ICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5hYm9ydGVkID09PSAnYm9vbGVhbic7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjYXRjaCAoX2EpIHtcblx0XHQgICAgICAgICAgICAvLyBBYm9ydFNpZ25hbC5wcm90b3R5cGUuYWJvcnRlZCB0aHJvd3MgaWYgaXRzIGJyYW5kIGNoZWNrIGZhaWxzXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IHN1cHBvcnRzQWJvcnRDb250cm9sbGVyID0gdHlwZW9mIEFib3J0Q29udHJvbGxlciA9PT0gJ2Z1bmN0aW9uJztcblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIENvbnN0cnVjdCBhIG5ldyBBYm9ydENvbnRyb2xsZXIsIGlmIHN1cHBvcnRlZCBieSB0aGUgcGxhdGZvcm0uXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEBpbnRlcm5hbFxuXHRcdCAgICAgKi9cblx0XHQgICAgZnVuY3Rpb24gY3JlYXRlQWJvcnRDb250cm9sbGVyKCkge1xuXHRcdCAgICAgICAgaWYgKHN1cHBvcnRzQWJvcnRDb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvKipcblx0XHQgICAgICogQSB3cml0YWJsZSBzdHJlYW0gcmVwcmVzZW50cyBhIGRlc3RpbmF0aW9uIGZvciBkYXRhLCBpbnRvIHdoaWNoIHlvdSBjYW4gd3JpdGUuXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEBwdWJsaWNcblx0XHQgICAgICovXG5cdFx0ICAgIGNsYXNzIFdyaXRhYmxlU3RyZWFtIHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKHJhd1VuZGVybHlpbmdTaW5rID0ge30sIHJhd1N0cmF0ZWd5ID0ge30pIHtcblx0XHQgICAgICAgICAgICBpZiAocmF3VW5kZXJseWluZ1NpbmsgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByYXdVbmRlcmx5aW5nU2luayA9IG51bGw7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICBhc3NlcnRPYmplY3QocmF3VW5kZXJseWluZ1NpbmssICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHVuZGVybHlpbmdTaW5rID0gY29udmVydFVuZGVybHlpbmdTaW5rKHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB1bmRlcmx5aW5nU2luay50eXBlO1xuXHRcdCAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZSBpcyBzcGVjaWZpZWQnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHN0cmF0ZWd5KTtcblx0XHQgICAgICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xuXHRcdCAgICAgICAgICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayh0aGlzLCB1bmRlcmx5aW5nU2luaywgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHdyaXRhYmxlIHN0cmVhbSBpcyBsb2NrZWQgdG8gYSB3cml0ZXIuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCBsb2NrZWQoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMignbG9ja2VkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBBYm9ydHMgdGhlIHN0cmVhbSwgc2lnbmFsaW5nIHRoYXQgdGhlIHByb2R1Y2VyIGNhbiBubyBsb25nZXIgc3VjY2Vzc2Z1bGx5IHdyaXRlIHRvIHRoZSBzdHJlYW0gYW5kIGl0IGlzIHRvIGJlXG5cdFx0ICAgICAgICAgKiBpbW1lZGlhdGVseSBtb3ZlZCB0byBhbiBlcnJvcmVkIHN0YXRlLCB3aXRoIGFueSBxdWV1ZWQtdXAgd3JpdGVzIGRpc2NhcmRlZC4gVGhpcyB3aWxsIGFsc28gZXhlY3V0ZSBhbnkgYWJvcnRcblx0XHQgICAgICAgICAqIG1lY2hhbmlzbSBvZiB0aGUgdW5kZXJseWluZyBzaW5rLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgZnVsZmlsbCBpZiB0aGUgc3RyZWFtIHNodXRzIGRvd24gc3VjY2Vzc2Z1bGx5LCBvciByZWplY3QgaWYgdGhlIHVuZGVybHlpbmcgc2luayBzaWduYWxlZFxuXHRcdCAgICAgICAgICogdGhhdCB0aGVyZSB3YXMgYW4gZXJyb3IgZG9pbmcgc28uIEFkZGl0aW9uYWxseSwgaXQgd2lsbCByZWplY3Qgd2l0aCBhIGBUeXBlRXJyb3JgICh3aXRob3V0IGF0dGVtcHRpbmcgdG8gY2FuY2VsXG5cdFx0ICAgICAgICAgKiB0aGUgc3RyZWFtKSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2NrZWQuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGFib3J0KHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2Fib3J0JykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgYWJvcnQgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQodGhpcywgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogQ2xvc2VzIHRoZSBzdHJlYW0uIFRoZSB1bmRlcmx5aW5nIHNpbmsgd2lsbCBmaW5pc2ggcHJvY2Vzc2luZyBhbnkgcHJldmlvdXNseS13cml0dGVuIGNodW5rcywgYmVmb3JlIGludm9raW5nIGl0c1xuXHRcdCAgICAgICAgICogY2xvc2UgYmVoYXZpb3IuIER1cmluZyB0aGlzIHRpbWUgYW55IGZ1cnRoZXIgYXR0ZW1wdHMgdG8gd3JpdGUgd2lsbCBmYWlsICh3aXRob3V0IGVycm9yaW5nIHRoZSBzdHJlYW0pLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIFRoZSBtZXRob2QgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgaWYgYWxsIHJlbWFpbmluZyBjaHVua3MgYXJlIHN1Y2Nlc3NmdWxseSB3cml0dGVuIGFuZCB0aGUgc3RyZWFtXG5cdFx0ICAgICAgICAgKiBzdWNjZXNzZnVsbHkgY2xvc2VzLCBvciByZWplY3RzIGlmIGFuIGVycm9yIGlzIGVuY291bnRlcmVkIGR1cmluZyB0aGlzIHByb2Nlc3MuIEFkZGl0aW9uYWxseSwgaXQgd2lsbCByZWplY3Qgd2l0aFxuXHRcdCAgICAgICAgICogYSBgVHlwZUVycm9yYCAod2l0aG91dCBhdHRlbXB0aW5nIHRvIGNhbmNlbCB0aGUgc3RyZWFtKSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2NrZWQuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGNsb3NlKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2Nsb3NlJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1DbG9zZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogQ3JlYXRlcyBhIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgfCB3cml0ZXJ9IGFuZCBsb2NrcyB0aGUgc3RyZWFtIHRvIHRoZSBuZXcgd3JpdGVyLiBXaGlsZSB0aGUgc3RyZWFtXG5cdFx0ICAgICAgICAgKiBpcyBsb2NrZWQsIG5vIG90aGVyIHdyaXRlciBjYW4gYmUgYWNxdWlyZWQgdW50aWwgdGhpcyBvbmUgaXMgcmVsZWFzZWQuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogVGhpcyBmdW5jdGlvbmFsaXR5IGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBjcmVhdGluZyBhYnN0cmFjdGlvbnMgdGhhdCBkZXNpcmUgdGhlIGFiaWxpdHkgdG8gd3JpdGUgdG8gYSBzdHJlYW1cblx0XHQgICAgICAgICAqIHdpdGhvdXQgaW50ZXJydXB0aW9uIG9yIGludGVybGVhdmluZy4gQnkgZ2V0dGluZyBhIHdyaXRlciBmb3IgdGhlIHN0cmVhbSwgeW91IGNhbiBlbnN1cmUgbm9ib2R5IGVsc2UgY2FuIHdyaXRlIGF0XG5cdFx0ICAgICAgICAgKiB0aGUgc2FtZSB0aW1lLCB3aGljaCB3b3VsZCBjYXVzZSB0aGUgcmVzdWx0aW5nIHdyaXR0ZW4gZGF0YSB0byBiZSB1bnByZWRpY3RhYmxlIGFuZCBwcm9iYWJseSB1c2VsZXNzLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXRXcml0ZXIoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMignZ2V0V3JpdGVyJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgZ2V0V3JpdGVyOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGxvY2tlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cblx0XHQgICAgfSk7XG5cdFx0ICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuXHRcdCAgICAgICAgICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW0nLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtLlxuXHRcdCAgICBmdW5jdGlvbiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHN0cmVhbSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoc3RyZWFtKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuXHRcdCAgICBmdW5jdGlvbiBDcmVhdGVXcml0YWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyayA9IDEsIHNpemVBbGdvcml0aG0gPSAoKSA9PiAxKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0oc3RyZWFtKTtcblx0XHQgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblx0XHQgICAgICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcblx0XHQgICAgICAgIHJldHVybiBzdHJlYW07XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHN0cmVhbSkge1xuXHRcdCAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICd3cml0YWJsZSc7XG5cdFx0ICAgICAgICAvLyBUaGUgZXJyb3IgdGhhdCB3aWxsIGJlIHJlcG9ydGVkIGJ5IG5ldyBtZXRob2QgY2FsbHMgb25jZSB0aGUgc3RhdGUgYmVjb21lcyBlcnJvcmVkLiBPbmx5IHNldCB3aGVuIFtbc3RhdGVdXSBpc1xuXHRcdCAgICAgICAgLy8gJ2Vycm9yaW5nJyBvciAnZXJyb3JlZCcuIE1heSBiZSBzZXQgdG8gYW4gdW5kZWZpbmVkIHZhbHVlLlxuXHRcdCAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHN0cmVhbS5fd3JpdGVyID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byB1bmRlZmluZWQgZmlyc3QgYmVjYXVzZSB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNvbnRyb2xsZXIgY2hlY2tzIHRoaXNcblx0XHQgICAgICAgIC8vIHZhcmlhYmxlIHRvIHZhbGlkYXRlIHRoZSBjYWxsZXIuXG5cdFx0ICAgICAgICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIC8vIFRoaXMgcXVldWUgaXMgcGxhY2VkIGhlcmUgaW5zdGVhZCBvZiB0aGUgd3JpdGVyIGNsYXNzIGluIG9yZGVyIHRvIGFsbG93IGZvciBwYXNzaW5nIGEgd3JpdGVyIHRvIHRoZSBuZXh0IGRhdGFcblx0XHQgICAgICAgIC8vIHByb2R1Y2VyIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIHF1ZXVlZCB3cml0ZXMgdG8gZmluaXNoLlxuXHRcdCAgICAgICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cdFx0ICAgICAgICAvLyBXcml0ZSByZXF1ZXN0cyBhcmUgcmVtb3ZlZCBmcm9tIF93cml0ZVJlcXVlc3RzIHdoZW4gd3JpdGUoKSBpcyBjYWxsZWQgb24gdGhlIHVuZGVybHlpbmcgc2luay4gVGhpcyBwcmV2ZW50c1xuXHRcdCAgICAgICAgLy8gdGhlbSBmcm9tIGJlaW5nIGVycm9uZW91c2x5IHJlamVjdGVkIG9uIGVycm9yLiBJZiBhIHdyaXRlKCkgY2FsbCBpcyBpbi1mbGlnaHQsIHRoZSByZXF1ZXN0IGlzIHN0b3JlZCBoZXJlLlxuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIC8vIFRoZSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gd3JpdGVyLmNsb3NlKCkuIFN0b3JlZCBoZXJlIGJlY2F1c2UgaXQgbWF5IGJlIGZ1bGZpbGxlZCBhZnRlciB0aGUgd3JpdGVyXG5cdFx0ICAgICAgICAvLyBoYXMgYmVlbiBkZXRhY2hlZC5cblx0XHQgICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgLy8gQ2xvc2UgcmVxdWVzdCBpcyByZW1vdmVkIGZyb20gX2Nsb3NlUmVxdWVzdCB3aGVuIGNsb3NlKCkgaXMgY2FsbGVkIG9uIHRoZSB1bmRlcmx5aW5nIHNpbmsuIFRoaXMgcHJldmVudHMgaXRcblx0XHQgICAgICAgIC8vIGZyb20gYmVpbmcgZXJyb25lb3VzbHkgcmVqZWN0ZWQgb24gZXJyb3IuIElmIGEgY2xvc2UoKSBjYWxsIGlzIGluLWZsaWdodCwgdGhlIHJlcXVlc3QgaXMgc3RvcmVkIGhlcmUuXG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgLy8gVGhlIHByb21pc2UgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB3cml0ZXIuYWJvcnQoKS4gVGhpcyBtYXkgYWxzbyBiZSBmdWxmaWxsZWQgYWZ0ZXIgdGhlIHdyaXRlciBoYXMgZGV0YWNoZWQuXG5cdFx0ICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAvLyBUaGUgYmFja3ByZXNzdXJlIHNpZ25hbCBzZXQgYnkgdGhlIGNvbnRyb2xsZXIuXG5cdFx0ICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGZhbHNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW0oeCkge1xuXHRcdCAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcicpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkge1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fd3JpdGVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUFib3J0KHN0cmVhbSwgcmVhc29uKSB7XG5cdFx0ICAgICAgICB2YXIgX2E7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLl9hYm9ydFJlYXNvbiA9IHJlYXNvbjtcblx0XHQgICAgICAgIChfYSA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLl9hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYm9ydCgpO1xuXHRcdCAgICAgICAgLy8gVHlwZVNjcmlwdCBuYXJyb3dzIHRoZSB0eXBlIG9mIGBzdHJlYW0uX3N0YXRlYCBkb3duIHRvICd3cml0YWJsZScgfCAnZXJyb3JpbmcnLFxuXHRcdCAgICAgICAgLy8gYnV0IGl0IGRvZXNuJ3Qga25vdyB0aGF0IHNpZ25hbGluZyBhYm9ydCBydW5zIGF1dGhvciBjb2RlIHRoYXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHRoZSBzdGF0ZS5cblx0XHQgICAgICAgIC8vIFdpZGVuIHRoZSB0eXBlIGFnYWluIGJ5IGNhc3RpbmcgdG8gV3JpdGFibGVTdHJlYW1TdGF0ZS5cblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmVkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9wcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgbGV0IHdhc0FscmVhZHlFcnJvcmluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG5cdFx0ICAgICAgICAgICAgd2FzQWxyZWFkeUVycm9yaW5nID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICAvLyByZWFzb24gd2lsbCBub3QgYmUgdXNlZCwgc28gZG9uJ3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdC5cblx0XHQgICAgICAgICAgICByZWFzb24gPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfcHJvbWlzZTogdW5kZWZpbmVkLFxuXHRcdCAgICAgICAgICAgICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcblx0XHQgICAgICAgICAgICAgICAgX3JlamVjdDogcmVqZWN0LFxuXHRcdCAgICAgICAgICAgICAgICBfcmVhc29uOiByZWFzb24sXG5cdFx0ICAgICAgICAgICAgICAgIF93YXNBbHJlYWR5RXJyb3Jpbmc6IHdhc0FscmVhZHlFcnJvcmluZ1xuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcHJvbWlzZSA9IHByb21pc2U7XG5cdFx0ICAgICAgICBpZiAoIXdhc0FscmVhZHlFcnJvcmluZykge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIHJlYXNvbik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbSkge1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtzdGF0ZX0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgd3JpdGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBjbG9zZWRgKSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgY2xvc2VSZXF1ZXN0ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcblx0XHQgICAgICAgICAgICAgICAgX3JlamVjdDogcmVqZWN0XG5cdFx0ICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IGNsb3NlUmVxdWVzdDtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG5cdFx0ICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9iYWNrcHJlc3N1cmUgJiYgc3RhdGUgPT09ICd3cml0YWJsZScpIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKTtcblx0XHQgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFdyaXRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3Qoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgd3JpdGVSZXF1ZXN0ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcblx0XHQgICAgICAgICAgICAgICAgX3JlamVjdDogcmVqZWN0XG5cdFx0ICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMucHVzaCh3cml0ZVJlcXVlc3QpO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIGVycm9yKTtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yaW5nJztcblx0XHQgICAgICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSByZWFzb247XG5cdFx0ICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcblx0XHQgICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodChzdHJlYW0pICYmIGNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pIHtcblx0XHQgICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JlZCc7XG5cdFx0ICAgICAgICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcltFcnJvclN0ZXBzXSgpO1xuXHRcdCAgICAgICAgY29uc3Qgc3RvcmVkRXJyb3IgPSBzdHJlYW0uX3N0b3JlZEVycm9yO1xuXHRcdCAgICAgICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzLmZvckVhY2god3JpdGVSZXF1ZXN0ID0+IHtcblx0XHQgICAgICAgICAgICB3cml0ZVJlcXVlc3QuX3JlamVjdChzdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IGFib3J0UmVxdWVzdCA9IHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdDtcblx0XHQgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGlmIChhYm9ydFJlcXVlc3QuX3dhc0FscmVhZHlFcnJvcmluZykge1xuXHRcdCAgICAgICAgICAgIGFib3J0UmVxdWVzdC5fcmVqZWN0KHN0b3JlZEVycm9yKTtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgcHJvbWlzZSA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Fib3J0U3RlcHNdKGFib3J0UmVxdWVzdC5fcmVhc29uKTtcblx0XHQgICAgICAgIHVwb25Qcm9taXNlKHByb21pc2UsICgpID0+IHtcblx0XHQgICAgICAgICAgICBhYm9ydFJlcXVlc3QuX3Jlc29sdmUoKTtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9LCAocmVhc29uKSA9PiB7XG5cdFx0ICAgICAgICAgICAgYWJvcnRSZXF1ZXN0Ll9yZWplY3QocmVhc29uKTtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0Ll9yZXNvbHZlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW0sIGVycm9yKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlKHN0cmVhbSkge1xuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdC5fcmVzb2x2ZSh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuXHRcdCAgICAgICAgICAgIC8vIFRoZSBlcnJvciB3YXMgdG9vIGxhdGUgdG8gZG8gYW55dGhpbmcsIHNvIGl0IGlzIGlnbm9yZWQuXG5cdFx0ICAgICAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9yZXNvbHZlKCk7XG5cdFx0ICAgICAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG5cdFx0ICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcblx0XHQgICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW0sIGVycm9yKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIC8vIE5ldmVyIGV4ZWN1dGUgc2luayBhYm9ydCgpIGFmdGVyIHNpbmsgY2xvc2UoKS5cblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcmVqZWN0KGVycm9yKTtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFRPRE8ocmljZWEpOiBGaXggYWxwaGFiZXRpY2FsIG9yZGVyLlxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSkge1xuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHN0cmVhbS5fY2xvc2VSZXF1ZXN0O1xuXHRcdCAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pIHtcblx0XHQgICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSBzdHJlYW0uX3dyaXRlUmVxdWVzdHMuc2hpZnQoKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSkge1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fY2xvc2VSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdC5fcmVqZWN0KHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG5cdFx0ICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKSB7XG5cdFx0ICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcblx0XHQgICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCAmJiBiYWNrcHJlc3N1cmUgIT09IHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKGJhY2twcmVzc3VyZSkge1xuXHRcdCAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXQod3JpdGVyKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBiYWNrcHJlc3N1cmU7XG5cdFx0ICAgIH1cblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEEgZGVmYXVsdCB3cml0ZXIgdmVuZGVkIGJ5IGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtfS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuXHRcdCAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyJyk7XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0V3JpdGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHdyaXRpbmcgYnkgYW5vdGhlciB3cml0ZXInKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9IHN0cmVhbTtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX3dyaXRlciA9IHRoaXM7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHRoaXMpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcblx0XHQgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHRoaXMsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBzdG9yZWRFcnJvciA9IHN0cmVhbS5fc3RvcmVkRXJyb3I7XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3Jcblx0XHQgICAgICAgICAqIHRoZSB3cml0ZXLigJlzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGNsb3NlZCgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgc3RyZWFt4oCZcyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXMgb3Zlci1mdWxsLlxuXHRcdCAgICAgICAgICogQSBwcm9kdWNlciBjYW4gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHRoZSByaWdodCBhbW91bnQgb2YgZGF0YSB0byB3cml0ZS5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBJdCB3aWxsIGJlIGBudWxsYCBpZiB0aGUgc3RyZWFtIGNhbm5vdCBiZSBzdWNjZXNzZnVsbHkgd3JpdHRlbiB0byAoZHVlIHRvIGVpdGhlciBiZWluZyBlcnJvcmVkLCBvciBoYXZpbmcgYW4gYWJvcnRcblx0XHQgICAgICAgICAqIHF1ZXVlZCB1cCkuIEl0IHdpbGwgcmV0dXJuIHplcm8gaWYgdGhlIHN0cmVhbSBpcyBjbG9zZWQuIEFuZCB0aGUgZ2V0dGVyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGludm9rZWQgd2hlblxuXHRcdCAgICAgICAgICogdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZC5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgc3RyZWFt4oCZcyBpbnRlcm5hbCBxdWV1ZSB0cmFuc2l0aW9uc1xuXHRcdCAgICAgICAgICogZnJvbSBub24tcG9zaXRpdmUgdG8gcG9zaXRpdmUsIHNpZ25hbGluZyB0aGF0IGl0IGlzIG5vIGxvbmdlciBhcHBseWluZyBiYWNrcHJlc3N1cmUuIE9uY2UgdGhlIGRlc2lyZWQgc2l6ZSBkaXBzXG5cdFx0ICAgICAgICAgKiBiYWNrIHRvIHplcm8gb3IgYmVsb3csIHRoZSBnZXR0ZXIgd2lsbCByZXR1cm4gYSBuZXcgcHJvbWlzZSB0aGF0IHN0YXlzIHBlbmRpbmcgdW50aWwgdGhlIG5leHQgdHJhbnNpdGlvbi5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBJZiB0aGUgc3RyZWFtIGJlY29tZXMgZXJyb3JlZCBvciBhYm9ydGVkLCBvciB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlY29tZVxuXHRcdCAgICAgICAgICogcmVqZWN0ZWQuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCByZWFkeSgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkeScpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5UHJvbWlzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFdyaXRhYmxlU3RyZWFtLmFib3J0IHwgc3RyZWFtLmFib3J0KHJlYXNvbil9LlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBhYm9ydChyZWFzb24gPSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdhYm9ydCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignYWJvcnQnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCh0aGlzLCByZWFzb24pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgV3JpdGFibGVTdHJlYW0uY2xvc2UgfCBzdHJlYW0uY2xvc2UoKX0uXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGNsb3NlKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignY2xvc2UnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2UodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJlbGVhc2VzIHRoZSB3cml0ZXLigJlzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHdyaXRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuXHRcdCAgICAgICAgICogSWYgdGhlIGFzc29jaWF0ZWQgc3RyZWFtIGlzIGVycm9yZWQgd2hlbiB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHdyaXRlciB3aWxsIGFwcGVhciBlcnJvcmVkIGluIHRoZSBzYW1lIHdheSBmcm9tXG5cdFx0ICAgICAgICAgKiBub3cgb247IG90aGVyd2lzZSwgdGhlIHdyaXRlciB3aWxsIGFwcGVhciBjbG9zZWQuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBsb2NrIGNhbiBzdGlsbCBiZSByZWxlYXNlZCBldmVuIGlmIHNvbWUgb25nb2luZyB3cml0ZXMgaGF2ZSBub3QgeWV0IGZpbmlzaGVkIChpLmUuIGV2ZW4gaWYgdGhlXG5cdFx0ICAgICAgICAgKiBwcm9taXNlcyByZXR1cm5lZCBmcm9tIHByZXZpb3VzIGNhbGxzIHRvIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIud3JpdGUgfCB3cml0ZSgpfSBoYXZlIG5vdCB5ZXQgc2V0dGxlZCkuXG5cdFx0ICAgICAgICAgKiBJdOKAmXMgbm90IG5lY2Vzc2FyeSB0byBob2xkIHRoZSBsb2NrIG9uIHRoZSB3cml0ZXIgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgd3JpdGU7IHRoZSBsb2NrIGluc3RlYWQgc2ltcGx5IHByZXZlbnRzXG5cdFx0ICAgICAgICAgKiBvdGhlciBwcm9kdWNlcnMgZnJvbSB3cml0aW5nIGluIGFuIGludGVybGVhdmVkIG1hbm5lci5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgcmVsZWFzZUxvY2soKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcblx0XHQgICAgICAgICAgICBpZiAoc3RyZWFtID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgd3JpdGUoY2h1bmsgPSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCd3cml0ZScpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignd3JpdGUgdG8nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh0aGlzLCBjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgd3JpdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHJlYWR5OiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuXHRcdCAgICAgICAgICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19vd25lcldyaXRhYmxlU3RyZWFtJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBIGNsaWVudCBvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCh3cml0ZXIsIHJlYXNvbikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoc3RyZWFtLCByZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHdyaXRlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uKHdyaXRlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgfHwgc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2Uod3JpdGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCBlcnJvcikge1xuXHRcdCAgICAgICAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID09PSAncGVuZGluZycpIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgZXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgZXJyb3IpIHtcblx0XHQgICAgICAgIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID09PSAncGVuZGluZycpIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgZXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIGVycm9yKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh3cml0ZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIDA7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHdyaXRlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgY29uc3QgcmVsZWFzZWRFcnJvciA9IG5ldyBUeXBlRXJyb3IoYFdyaXRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCk7XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlbGVhc2VkRXJyb3IpO1xuXHRcdCAgICAgICAgLy8gVGhlIHN0YXRlIHRyYW5zaXRpb25zIHRvIFwiZXJyb3JlZFwiIGJlZm9yZSB0aGUgc2luayBhYm9ydCgpIG1ldGhvZCBydW5zLCBidXQgdGhlIHdyaXRlci5jbG9zZWQgcHJvbWlzZSBpcyBub3Rcblx0XHQgICAgICAgIC8vIHJlamVjdGVkIHVudGlsIGFmdGVyd2FyZHMuIFRoaXMgbWVhbnMgdGhhdCBzaW1wbHkgdGVzdGluZyBzdGF0ZSB3aWxsIG5vdCB3b3JrLlxuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVsZWFzZWRFcnJvcik7XG5cdFx0ICAgICAgICBzdHJlYW0uX3dyaXRlciA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSA9IHVuZGVmaW5lZDtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh3cml0ZXIsIGNodW5rKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICBjb25zdCBjaHVua1NpemUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplKGNvbnRyb2xsZXIsIGNodW5rKTtcblx0XHQgICAgICAgIGlmIChzdHJlYW0gIT09IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCd3cml0ZSB0bycpKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB8fCBzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIGNsb3Npbmcgb3IgY2xvc2VkIGFuZCBjYW5ub3QgYmUgd3JpdHRlbiB0bycpKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgcHJvbWlzZSA9IFdyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0KHN0cmVhbSk7XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyV3JpdGUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG5cdFx0ICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0XHQgICAgfVxuXHRcdCAgICBjb25zdCBjbG9zZVNlbnRpbmVsID0ge307XG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBXcml0YWJsZVN0cmVhbSB8IHdyaXRhYmxlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEBwdWJsaWNcblx0XHQgICAgICovXG5cdFx0ICAgIGNsYXNzIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IoKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBUaGUgcmVhc29uIHdoaWNoIHdhcyBwYXNzZWQgdG8gYFdyaXRhYmxlU3RyZWFtLmFib3J0KHJlYXNvbilgIHdoZW4gdGhlIHN0cmVhbSB3YXMgYWJvcnRlZC5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBAZGVwcmVjYXRlZFxuXHRcdCAgICAgICAgICogIFRoaXMgcHJvcGVydHkgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBzcGVjaWZpY2F0aW9uLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9zdHJlYW1zL3B1bGwvMTE3Ny5cblx0XHQgICAgICAgICAqICBVc2Uge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuc2lnbmFsfSdzIGByZWFzb25gIGluc3RlYWQuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCBhYm9ydFJlYXNvbigpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMignYWJvcnRSZWFzb24nKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0UmVhc29uO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBBbiBgQWJvcnRTaWduYWxgIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWJvcnQgdGhlIHBlbmRpbmcgd3JpdGUgb3IgY2xvc2Ugb3BlcmF0aW9uIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm9ydGVkLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgc2lnbmFsKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdzaWduYWwnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX2Fib3J0Q29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIC8vIE9sZGVyIGJyb3dzZXJzIG9yIG9sZGVyIE5vZGUgdmVyc2lvbnMgbWF5IG5vdCBzdXBwb3J0IGBBYm9ydENvbnRyb2xsZXJgIG9yIGBBYm9ydFNpZ25hbGAuXG5cdFx0ICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYnVuZGxlIGFuZCBzaGlwIGFuIGBBYm9ydENvbnRyb2xsZXJgIHBvbHlmaWxsIHRvZ2V0aGVyIHdpdGggb3VyIHBvbHlmaWxsLFxuXHRcdCAgICAgICAgICAgICAgICAvLyBzbyBpbnN0ZWFkIHdlIG9ubHkgaW1wbGVtZW50IHN1cHBvcnQgZm9yIGBzaWduYWxgIGlmIHdlIGZpbmQgYSBnbG9iYWwgYEFib3J0Q29udHJvbGxlcmAgY29uc3RydWN0b3IuXG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLnNpZ25hbCBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBDbG9zZXMgdGhlIGNvbnRyb2xsZWQgd3JpdGFibGUgc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZSBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyByYXJlbHkgdXNlZCwgc2luY2UgdXN1YWxseSBpdCBzdWZmaWNlcyB0byByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIGZyb20gb25lIG9mIHRoZSB1bmRlcmx5aW5nXG5cdFx0ICAgICAgICAgKiBzaW5rJ3MgbWV0aG9kcy4gSG93ZXZlciwgaXQgY2FuIGJlIHVzZWZ1bCBmb3Igc3VkZGVubHkgc2h1dHRpbmcgZG93biBhIHN0cmVhbSBpbiByZXNwb25zZSB0byBhbiBldmVudCBvdXRzaWRlIHRoZVxuXHRcdCAgICAgICAgICogbm9ybWFsIGxpZmVjeWNsZSBvZiBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgdW5kZXJseWluZyBzaW5rLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBlcnJvcihlID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2Vycm9yJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgICAgICBpZiAoc3RhdGUgIT09ICd3cml0YWJsZScpIHtcblx0XHQgICAgICAgICAgICAgICAgLy8gVGhlIHN0cmVhbSBpcyBjbG9zZWQsIGVycm9yZWQgb3Igd2lsbCBiZSBzb29uLiBUaGUgc2luayBjYW4ndCBkbyBhbnl0aGluZyB1c2VmdWwgaWYgaXQgZ2V0cyBhbiBlcnJvciBoZXJlLCBzb1xuXHRcdCAgICAgICAgICAgICAgICAvLyBqdXN0IHRyZWF0IGl0IGFzIGEgbm8tb3AuXG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIGUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuXHRcdCAgICAgICAgW0Fib3J0U3RlcHNdKHJlYXNvbikge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2Fib3J0QWxnb3JpdGhtKHJlYXNvbik7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuXHRcdCAgICAgICAgW0Vycm9yU3RlcHNdKCkge1xuXHRcdCAgICAgICAgICAgIFJlc2V0UXVldWUodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcblx0XHQgICAgICAgIGFib3J0UmVhc29uOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHNpZ25hbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH1cblx0XHQgICAgfSk7XG5cdFx0ICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgaW1wbGVtZW50aW5nIGludGVyZmFjZSByZXF1aXJlZCBieSB0aGUgV3JpdGFibGVTdHJlYW0uXG5cdFx0ICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbSA9IHN0cmVhbTtcblx0XHQgICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcblx0XHQgICAgICAgIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxuXHRcdCAgICAgICAgY29udHJvbGxlci5fcXVldWUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9hYm9ydFJlYXNvbiA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2Fib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcigpO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gc2l6ZUFsZ29yaXRobTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtID0gd3JpdGVBbGdvcml0aG07XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSA9IGNsb3NlQWxnb3JpdGhtO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fYWJvcnRBbGdvcml0aG0gPSBhYm9ydEFsZ29yaXRobTtcblx0XHQgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG5cdFx0ICAgICAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICBjb25zdCBzdGFydFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KTtcblx0XHQgICAgICAgIHVwb25Qcm9taXNlKHN0YXJ0UHJvbWlzZSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH0sIHIgPT4ge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCByKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayhzdHJlYW0sIHVuZGVybHlpbmdTaW5rLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBsZXQgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBsZXQgd3JpdGVBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBsZXQgY2xvc2VBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBsZXQgYWJvcnRBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ1Npbmsuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1Npbmsuc3RhcnQoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ1Npbmsud3JpdGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHdyaXRlQWxnb3JpdGhtID0gY2h1bmsgPT4gdW5kZXJseWluZ1Npbmsud3JpdGUoY2h1bmssIGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHVuZGVybHlpbmdTaW5rLmNsb3NlICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBjbG9zZUFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTaW5rLmNsb3NlKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ1NpbmsuYWJvcnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGFib3J0QWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdTaW5rLmFib3J0KHJlYXNvbik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQ2xlYXJBbGdvcml0aG1zIG1heSBiZSBjYWxsZWQgdHdpY2UuIEVycm9yaW5nIHRoZSBzYW1lIHN0cmVhbSBpbiBtdWx0aXBsZSB3YXlzIHdpbGwgb2Z0ZW4gcmVzdWx0IGluIHJlZHVuZGFudCBjYWxscy5cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fYWJvcnRBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNsb3NlU2VudGluZWwsIDApO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemUoY29udHJvbGxlciwgY2h1bmspIHtcblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjYXRjaCAoY2h1bmtTaXplRSkge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGNodW5rU2l6ZUUpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiAxO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyV3JpdGUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSkge1xuXHRcdCAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNhdGNoIChlbnF1ZXVlRSkge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGVucXVldWVFKTtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgaWYgKCFjb250cm9sbGVyLl9zdGFydGVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgdmFsdWUgPSBQZWVrUXVldWVWYWx1ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGlmICh2YWx1ZSA9PT0gY2xvc2VTZW50aW5lbCkge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlKGNvbnRyb2xsZXIsIHZhbHVlKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBlcnJvcikge1xuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcblx0XHQgICAgICAgIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGNvbnN0IHNpbmtDbG9zZVByb21pc2UgPSBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgIHVwb25Qcm9taXNlKHNpbmtDbG9zZVByb21pc2UsICgpID0+IHtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2Uoc3RyZWFtKTtcblx0XHQgICAgICAgIH0sIHJlYXNvbiA9PiB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzV3JpdGUoY29udHJvbGxlciwgY2h1bmspIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcblx0XHQgICAgICAgIFdyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcblx0XHQgICAgICAgIGNvbnN0IHNpbmtXcml0ZVByb21pc2UgPSBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobShjaHVuayk7XG5cdFx0ICAgICAgICB1cG9uUHJvbWlzZShzaW5rV3JpdGVQcm9taXNlLCAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlKHN0cmVhbSk7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgICAgIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RhdGUgPT09ICd3cml0YWJsZScpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9LCByZWFzb24gPT4ge1xuXHRcdCAgICAgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW0sIHJlYXNvbik7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgcmV0dXJuIGRlc2lyZWRTaXplIDw9IDA7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQSBjbGllbnQgb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlcnJvcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIGVycm9yKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW0uXG5cdFx0ICAgIGZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtYCk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyYCk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24obmFtZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCAnICsgbmFtZSArICcgYSBzdHJlYW0gdXNpbmcgYSByZWxlYXNlZCB3cml0ZXInKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKSB7XG5cdFx0ICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQgICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0ICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcblx0XHQgICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdwZW5kaW5nJztcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcblx0XHQgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuXHRcdCAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyKSB7XG5cdFx0ICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcblx0XHQgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSh3cml0ZXIuX2Nsb3NlZFByb21pc2UpO1xuXHRcdCAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuXHRcdCAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncmVqZWN0ZWQnO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKSB7XG5cdFx0ICAgICAgICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZXNvbHZlZCc7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKSB7XG5cdFx0ICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdCAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuXHRcdCAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdwZW5kaW5nJztcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcblx0XHQgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG5cdFx0ICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyKSB7XG5cdFx0ICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuXHRcdCAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHdyaXRlci5fcmVhZHlQcm9taXNlKTtcblx0XHQgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdChyZWFzb24pO1xuXHRcdCAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAncmVqZWN0ZWQnO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXIpIHtcblx0XHQgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuXHRcdCAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpIHtcblx0XHQgICAgICAgIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdmdWxmaWxsZWQnO1xuXHRcdCAgICB9XG5cblx0XHQgICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cblx0XHQgICAgY29uc3QgTmF0aXZlRE9NRXhjZXB0aW9uID0gdHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBET01FeGNlcHRpb24gOiB1bmRlZmluZWQ7XG5cblx0XHQgICAgLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJub2RlXCIgLz5cblx0XHQgICAgZnVuY3Rpb24gaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvcihjdG9yKSB7XG5cdFx0ICAgICAgICBpZiAoISh0eXBlb2YgY3RvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY3RvciA9PT0gJ29iamVjdCcpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICBuZXcgY3RvcigpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY2F0Y2ggKF9hKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNyZWF0ZURPTUV4Y2VwdGlvblBvbHlmaWxsKCkge1xuXHRcdCAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuXHRcdCAgICAgICAgY29uc3QgY3RvciA9IGZ1bmN0aW9uIERPTUV4Y2VwdGlvbihtZXNzYWdlLCBuYW1lKSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcblx0XHQgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICdFcnJvcic7XG5cdFx0ICAgICAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG5cdFx0ICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH07XG5cdFx0ICAgICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgeyB2YWx1ZTogY3Rvciwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblx0XHQgICAgICAgIHJldHVybiBjdG9yO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblx0XHQgICAgY29uc3QgRE9NRXhjZXB0aW9uJDEgPSBpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKE5hdGl2ZURPTUV4Y2VwdGlvbikgPyBOYXRpdmVET01FeGNlcHRpb24gOiBjcmVhdGVET01FeGNlcHRpb25Qb2x5ZmlsbCgpO1xuXG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUGlwZVRvKHNvdXJjZSwgZGVzdCwgcHJldmVudENsb3NlLCBwcmV2ZW50QWJvcnQsIHByZXZlbnRDYW5jZWwsIHNpZ25hbCkge1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzb3VyY2UpO1xuXHRcdCAgICAgICAgY29uc3Qgd3JpdGVyID0gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcihkZXN0KTtcblx0XHQgICAgICAgIHNvdXJjZS5fZGlzdHVyYmVkID0gdHJ1ZTtcblx0XHQgICAgICAgIGxldCBzaHV0dGluZ0Rvd24gPSBmYWxzZTtcblx0XHQgICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBzcGVjJ3MgcmVxdWlyZW1lbnQgdGhhdCB3ZSB3YWl0IGZvciBvbmdvaW5nIHdyaXRlcyBkdXJpbmcgc2h1dGRvd24uXG5cdFx0ICAgICAgICBsZXQgY3VycmVudFdyaXRlID0gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdCAgICAgICAgICAgIGxldCBhYm9ydEFsZ29yaXRobTtcblx0XHQgICAgICAgICAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0gPSAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBET01FeGNlcHRpb24kMSgnQWJvcnRlZCcsICdBYm9ydEVycm9yJyk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb25zID0gW107XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRBYm9ydCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCgoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgZXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHNvdXJjZSwgZXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUHJvbWlzZS5hbGwoYWN0aW9ucy5tYXAoYWN0aW9uID0+IGFjdGlvbigpKSksIHRydWUsIGVycm9yKTtcblx0XHQgICAgICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBhYm9ydEFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QWxnb3JpdGhtKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgLy8gVXNpbmcgcmVhZGVyIGFuZCB3cml0ZXIsIHJlYWQgYWxsIGNodW5rcyBmcm9tIHRoaXMgYW5kIHdyaXRlIHRoZW0gdG8gZGVzdFxuXHRcdCAgICAgICAgICAgIC8vIC0gQmFja3ByZXNzdXJlIG11c3QgYmUgZW5mb3JjZWRcblx0XHQgICAgICAgICAgICAvLyAtIFNodXRkb3duIG11c3Qgc3RvcCBhbGwgYWN0aXZpdHlcblx0XHQgICAgICAgICAgICBmdW5jdGlvbiBwaXBlTG9vcCgpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmVMb29wLCByZWplY3RMb29wKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBuZXh0KGRvbmUpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlTG9vcCgpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGBQZXJmb3JtUHJvbWlzZVRoZW5gIGluc3RlYWQgb2YgYHVwb25Qcm9taXNlYCB0byBhdm9pZFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRpbmcgdW5uZWNlc3NhcnkgYC5jYXRjaChyZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pYCBoYW5kbGVyc1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBQZXJmb3JtUHJvbWlzZVRoZW4ocGlwZVN0ZXAoKSwgbmV4dCwgcmVqZWN0TG9vcCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgbmV4dChmYWxzZSk7XG5cdFx0ICAgICAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBmdW5jdGlvbiBwaXBlU3RlcCgpIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodHJ1ZSk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbih3cml0ZXIuX3JlYWR5UHJvbWlzZSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmVSZWFkLCByZWplY3RSZWFkKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXcml0ZSA9IFBlcmZvcm1Qcm9taXNlVGhlbihXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh3cml0ZXIsIGNodW5rKSwgdW5kZWZpbmVkLCBub29wKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVSZWFkKGZhbHNlKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHJlc29sdmVSZWFkKHRydWUpLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogcmVqZWN0UmVhZFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAvLyBFcnJvcnMgbXVzdCBiZSBwcm9wYWdhdGVkIGZvcndhcmRcblx0XHQgICAgICAgICAgICBpc09yQmVjb21lc0Vycm9yZWQoc291cmNlLCByZWFkZXIuX2Nsb3NlZFByb21pc2UsIHN0b3JlZEVycm9yID0+IHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBXcml0YWJsZVN0cmVhbUFib3J0KGRlc3QsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgLy8gRXJyb3JzIG11c3QgYmUgcHJvcGFnYXRlZCBiYWNrd2FyZFxuXHRcdCAgICAgICAgICAgIGlzT3JCZWNvbWVzRXJyb3JlZChkZXN0LCB3cml0ZXIuX2Nsb3NlZFByb21pc2UsIHN0b3JlZEVycm9yID0+IHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBzdG9yZWRFcnJvciksIHRydWUsIHN0b3JlZEVycm9yKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHNodXRkb3duKHRydWUsIHN0b3JlZEVycm9yKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIC8vIENsb3NpbmcgbXVzdCBiZSBwcm9wYWdhdGVkIGZvcndhcmRcblx0XHQgICAgICAgICAgICBpc09yQmVjb21lc0Nsb3NlZChzb3VyY2UsIHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDbG9zZSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24od3JpdGVyKSk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bigpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgLy8gQ2xvc2luZyBtdXN0IGJlIHByb3BhZ2F0ZWQgYmFja3dhcmRcblx0XHQgICAgICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkgfHwgZGVzdC5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RDbG9zZWQgPSBuZXcgVHlwZUVycm9yKCd0aGUgZGVzdGluYXRpb24gd3JpdGFibGUgc3RyZWFtIGNsb3NlZCBiZWZvcmUgYWxsIGRhdGEgY291bGQgYmUgcGlwZWQgdG8gaXQnKTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBkZXN0Q2xvc2VkKSwgdHJ1ZSwgZGVzdENsb3NlZCk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bih0cnVlLCBkZXN0Q2xvc2VkKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHBpcGVMb29wKCkpO1xuXHRcdCAgICAgICAgICAgIGZ1bmN0aW9uIHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpIHtcblx0XHQgICAgICAgICAgICAgICAgLy8gQW5vdGhlciB3cml0ZSBtYXkgaGF2ZSBzdGFydGVkIHdoaWxlIHdlIHdlcmUgd2FpdGluZyBvbiB0aGlzIGN1cnJlbnRXcml0ZSwgc28gd2UgaGF2ZSB0byBiZSBzdXJlIHRvIHdhaXRcblx0XHQgICAgICAgICAgICAgICAgLy8gZm9yIHRoYXQgdG9vLlxuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBvbGRDdXJyZW50V3JpdGUgPSBjdXJyZW50V3JpdGU7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4oY3VycmVudFdyaXRlLCAoKSA9PiBvbGRDdXJyZW50V3JpdGUgIT09IGN1cnJlbnRXcml0ZSA/IHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpIDogdW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZnVuY3Rpb24gaXNPckJlY29tZXNFcnJvcmVkKHN0cmVhbSwgcHJvbWlzZSwgYWN0aW9uKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGFjdGlvbihzdHJlYW0uX3N0b3JlZEVycm9yKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHVwb25SZWplY3Rpb24ocHJvbWlzZSwgYWN0aW9uKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBmdW5jdGlvbiBpc09yQmVjb21lc0Nsb3NlZChzdHJlYW0sIHByb21pc2UsIGFjdGlvbikge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGFjdGlvbigpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHByb21pc2UsIGFjdGlvbik7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZnVuY3Rpb24gc2h1dGRvd25XaXRoQWN0aW9uKGFjdGlvbiwgb3JpZ2luYWxJc0Vycm9yLCBvcmlnaW5hbEVycm9yKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBzaHV0dGluZ0Rvd24gPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScgJiYgIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksIGRvVGhlUmVzdCk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBkb1RoZVJlc3QoKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb1RoZVJlc3QoKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB1cG9uUHJvbWlzZShhY3Rpb24oKSwgKCkgPT4gZmluYWxpemUob3JpZ2luYWxJc0Vycm9yLCBvcmlnaW5hbEVycm9yKSwgbmV3RXJyb3IgPT4gZmluYWxpemUodHJ1ZSwgbmV3RXJyb3IpKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBmdW5jdGlvbiBzaHV0ZG93bihpc0Vycm9yLCBlcnJvcikge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnICYmICFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpLCAoKSA9PiBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcikpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgZmluYWxpemUoaXNFcnJvciwgZXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2Uod3JpdGVyKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QWxnb3JpdGhtKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciB7XG5cdFx0ICAgICAgICBjb25zdHJ1Y3RvcigpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBjb250cm9sbGVkIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpc1xuXHRcdCAgICAgICAgICogb3Zlci1mdWxsLiBBbiB1bmRlcmx5aW5nIHNvdXJjZSBvdWdodCB0byB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgd2hlbiBhbmQgaG93IHRvIGFwcGx5IGJhY2twcmVzc3VyZS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdkZXNpcmVkU2l6ZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBDbG9zZXMgdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLiBDb25zdW1lcnMgd2lsbCBzdGlsbCBiZSBhYmxlIHRvIHJlYWQgYW55IHByZXZpb3VzbHktZW5xdWV1ZWQgY2h1bmtzIGZyb21cblx0XHQgICAgICAgICAqIHRoZSBzdHJlYW0sIGJ1dCBvbmNlIHRob3NlIGFyZSByZWFkLCB0aGUgc3RyZWFtIHdpbGwgYmVjb21lIGNsb3NlZC5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgY2xvc2UoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2Nsb3NlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGNsb3NlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVucXVldWUoY2h1bmsgPSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZW5xdWV1ZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBlbnF1ZXVlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBlcnJvcihlID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2Vycm9yJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cblx0XHQgICAgICAgIFtDYW5jZWxTdGVwc10ocmVhc29uKSB7XG5cdFx0ICAgICAgICAgICAgUmVzZXRRdWV1ZSh0aGlzKTtcblx0XHQgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKiogQGludGVybmFsICovXG5cdFx0ICAgICAgICBbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCkge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IERlcXVldWVWYWx1ZSh0aGlzKTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKGNodW5rKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgZW5xdWV1ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cblx0XHQgICAgfSk7XG5cdFx0ICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXHRcdCAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoeCkge1xuXHRcdCAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbScpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IHNob3VsZFB1bGwgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBpZiAoIXNob3VsZFB1bGwpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IHRydWU7XG5cdFx0ICAgICAgICBjb25zdCBwdWxsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0oKTtcblx0XHQgICAgICAgIHVwb25Qcm9taXNlKHB1bGxQcm9taXNlLCAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsQWdhaW4pIHtcblx0XHQgICAgICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0sIGUgPT4ge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgaWYgKGRlc2lyZWRTaXplID4gMCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBIGNsaWVudCBvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG5cdFx0ICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblx0XHQgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGNodW5rLCBmYWxzZSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBsZXQgY2h1bmtTaXplO1xuXHRcdCAgICAgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNodW5rU2l6ZSA9IGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNhdGNoIChjaHVua1NpemVFKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBjaHVua1NpemVFKTtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgY2h1bmtTaXplRTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICAgICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNhdGNoIChlbnF1ZXVlRSkge1xuXHRcdCAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZW5xdWV1ZUUpO1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBlbnF1ZXVlRTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSkge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gMDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneUhXTSAtIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFRoaXMgaXMgdXNlZCBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVHJhbnNmb3JtU3RyZWFtLlxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcikpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKCFjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCAmJiBzdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSA9IHN0cmVhbTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSBmYWxzZTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gc2l6ZUFsZ29yaXRobTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gY2FuY2VsQWxnb3JpdGhtO1xuXHRcdCAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXHRcdCAgICAgICAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgdXBvblByb21pc2UocHJvbWlzZVJlc29sdmVkV2l0aChzdGFydFJlc3VsdCksICgpID0+IHtcblx0XHQgICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH0sIHIgPT4ge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCByKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKHN0cmVhbSwgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuXHRcdCAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuXHRcdCAgICAgICAgbGV0IHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgbGV0IHB1bGxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBsZXQgY2FuY2VsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NvdXJjZS5zdGFydChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh1bmRlcmx5aW5nU291cmNlLnB1bGwgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHB1bGxBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU291cmNlLnB1bGwoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS5jYW5jZWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobSA9IHJlYXNvbiA9PiB1bmRlcmx5aW5nU291cmNlLmNhbmNlbChyZWFzb24pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVRlZShzdHJlYW0sIGNsb25lRm9yQnJhbmNoMikge1xuXHRcdCAgICAgICAgaWYgKElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtVGVlKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0VGVlKHN0cmVhbSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0VGVlKHN0cmVhbSwgY2xvbmVGb3JCcmFuY2gyKSB7XG5cdFx0ICAgICAgICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG5cdFx0ICAgICAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IHJlYWRBZ2FpbiA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IGNhbmNlbGVkMSA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IGNhbmNlbGVkMiA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IHJlYXNvbjE7XG5cdFx0ICAgICAgICBsZXQgcmVhc29uMjtcblx0XHQgICAgICAgIGxldCBicmFuY2gxO1xuXHRcdCAgICAgICAgbGV0IGJyYW5jaDI7XG5cdFx0ICAgICAgICBsZXQgcmVzb2x2ZUNhbmNlbFByb21pc2U7XG5cdFx0ICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHQgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSA9IHJlc29sdmU7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKHJlYWRpbmcpIHtcblx0XHQgICAgICAgICAgICAgICAgcmVhZEFnYWluID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmVhZGluZyA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XG5cdFx0ICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIHN5bmNocm9ub3VzbHktYXZhaWxhYmxlIHJlYWRzIGdldCBhaGVhZCBvZiBhc3luY2hyb25vdXNseS1hdmFpbGFibGUgZXJyb3JzLlxuXHRcdCAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbiA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rMSA9IGNodW5rO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rMiA9IGNodW5rO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHdheSB0byBhY2Nlc3MgdGhlIGNsb25pbmcgY29kZSByaWdodCBub3cgaW4gdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi5cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhZGQgb25lIHRoZW4gd2UnbGwgbmVlZCBhbiBpbXBsZW1lbnRhdGlvbiBmb3Igc2VyaWFsaXphYmxlIG9iamVjdHMuXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCFjYW5jZWxlZDIgJiYgY2xvbmVGb3JCcmFuY2gyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjaHVuazIgPSBTdHJ1Y3R1cmVkRGVzZXJpYWxpemUoU3RydWN0dXJlZFNlcmlhbGl6ZShjaHVuazIpKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazEpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEFnYWluKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxBbGdvcml0aG0oKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICAgICAgfSxcblx0XHQgICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIH0sXG5cdFx0ICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9O1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uKSB7XG5cdFx0ICAgICAgICAgICAgY2FuY2VsZWQxID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICByZWFzb24xID0gcmVhc29uO1xuXHRcdCAgICAgICAgICAgIGlmIChjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG5cdFx0ICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gY2FuY2VsMkFsZ29yaXRobShyZWFzb24pIHtcblx0XHQgICAgICAgICAgICBjYW5jZWxlZDIgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIHJlYXNvbjIgPSByZWFzb247XG5cdFx0ICAgICAgICAgICAgaWYgKGNhbmNlbGVkMSkge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcblx0XHQgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpIHtcblx0XHQgICAgICAgICAgICAvLyBkbyBub3RoaW5nXG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBicmFuY2gxID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xuXHRcdCAgICAgICAgYnJhbmNoMiA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwyQWxnb3JpdGhtKTtcblx0XHQgICAgICAgIHVwb25SZWplY3Rpb24ocmVhZGVyLl9jbG9zZWRQcm9taXNlLCAocikgPT4ge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuXHRcdCAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHJldHVybiBbYnJhbmNoMSwgYnJhbmNoMl07XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtVGVlKHN0cmVhbSkge1xuXHRcdCAgICAgICAgbGV0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcblx0XHQgICAgICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICBsZXQgcmVhZEFnYWluRm9yQnJhbmNoMSA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcblx0XHQgICAgICAgIGxldCBjYW5jZWxlZDEgPSBmYWxzZTtcblx0XHQgICAgICAgIGxldCBjYW5jZWxlZDIgPSBmYWxzZTtcblx0XHQgICAgICAgIGxldCByZWFzb24xO1xuXHRcdCAgICAgICAgbGV0IHJlYXNvbjI7XG5cdFx0ICAgICAgICBsZXQgYnJhbmNoMTtcblx0XHQgICAgICAgIGxldCBicmFuY2gyO1xuXHRcdCAgICAgICAgbGV0IHJlc29sdmVDYW5jZWxQcm9taXNlO1xuXHRcdCAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IG5ld1Byb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0ICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UgPSByZXNvbHZlO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgICAgICBmdW5jdGlvbiBmb3J3YXJkUmVhZGVyRXJyb3IodGhpc1JlYWRlcikge1xuXHRcdCAgICAgICAgICAgIHVwb25SZWplY3Rpb24odGhpc1JlYWRlci5fY2xvc2VkUHJvbWlzZSwgciA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmICh0aGlzUmVhZGVyICE9PSByZWFkZXIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG5cdFx0ICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIHB1bGxXaXRoRGVmYXVsdFJlYWRlcigpIHtcblx0XHQgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuXHRcdCAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcblx0XHQgICAgICAgICAgICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRSZXF1ZXN0ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcblx0XHQgICAgICAgICAgICAgICAgICAgIC8vIHJlYWRlci5fY2xvc2VkUHJvbWlzZSBiZWxvdyksIGFuZCB3ZSB3YW50IGVycm9ycyBpbiBzdHJlYW0gdG8gZXJyb3IgYm90aCBicmFuY2hlcyBpbW1lZGlhdGVseS4gV2UgY2Fubm90IGxldFxuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSByZWFkcyBnZXQgYWhlYWQgb2YgYXN5bmNocm9ub3VzbHktYXZhaWxhYmxlIGVycm9ycy5cblx0XHQgICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rMSA9IGNodW5rO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaHVuazIgPSBjaHVuaztcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSAmJiAhY2FuY2VsZWQyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazIgPSBDbG9uZUFzVWludDhBcnJheShjaHVuayk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGNsb25lRSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNsb25lRSkpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsxKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazIpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDEpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbDFBbGdvcml0aG0oKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVhZEFnYWluRm9yQnJhbmNoMikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsMkFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gcHVsbFdpdGhCWU9CUmVhZGVyKHZpZXcsIGZvckJyYW5jaDIpIHtcblx0XHQgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuXHRcdCAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKTtcblx0XHQgICAgICAgICAgICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IGJ5b2JCcmFuY2ggPSBmb3JCcmFuY2gyID8gYnJhbmNoMiA6IGJyYW5jaDE7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgb3RoZXJCcmFuY2ggPSBmb3JCcmFuY2gyID8gYnJhbmNoMSA6IGJyYW5jaDI7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVhZEludG9SZXF1ZXN0ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcblx0XHQgICAgICAgICAgICAgICAgICAgIC8vIHJlYWRlci5fY2xvc2VkUHJvbWlzZSBiZWxvdyksIGFuZCB3ZSB3YW50IGVycm9ycyBpbiBzdHJlYW0gdG8gZXJyb3IgYm90aCBicmFuY2hlcyBpbW1lZGlhdGVseS4gV2UgY2Fubm90IGxldFxuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSByZWFkcyBnZXQgYWhlYWQgb2YgYXN5bmNocm9ub3VzbHktYXZhaWxhYmxlIGVycm9ycy5cblx0XHQgICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5b2JDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDIgOiBjYW5jZWxlZDE7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDEgOiBjYW5jZWxlZDI7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlckNhbmNlbGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbG9uZWRDaHVuaztcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZENodW5rID0gQ2xvbmVBc1VpbnQ4QXJyYXkoY2h1bmspO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChjbG9uZUUpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3Iob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY2xvbmVFKSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVkQ2h1bmspO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYnlvYkNhbmNlbGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEFnYWluRm9yQnJhbmNoMSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsMUFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGwyQWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgIH0sXG5cdFx0ICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiBjaHVuayA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBjb25zdCBieW9iQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQyIDogY2FuY2VsZWQxO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDEgOiBjYW5jZWxlZDI7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlckNhbmNlbGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQgJiYgb3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkIHx8ICFvdGhlckNhbmNlbGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgfSxcblx0XHQgICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZChyZWFkZXIsIHZpZXcsIHJlYWRJbnRvUmVxdWVzdCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBmdW5jdGlvbiBwdWxsMUFsZ29yaXRobSgpIHtcblx0XHQgICAgICAgICAgICBpZiAocmVhZGluZykge1xuXHRcdCAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmVhZGluZyA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgY29uc3QgYnlvYlJlcXVlc3QgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICBpZiAoYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcblx0XHQgICAgICAgICAgICAgICAgcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICBwdWxsV2l0aEJZT0JSZWFkZXIoYnlvYlJlcXVlc3QuX3ZpZXcsIGZhbHNlKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIHB1bGwyQWxnb3JpdGhtKCkge1xuXHRcdCAgICAgICAgICAgIGlmIChyZWFkaW5nKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZWFkaW5nID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICBjb25zdCBieW9iUmVxdWVzdCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgIGlmIChieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuXHRcdCAgICAgICAgICAgICAgICBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIHB1bGxXaXRoQllPQlJlYWRlcihieW9iUmVxdWVzdC5fdmlldywgdHJ1ZSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBmdW5jdGlvbiBjYW5jZWwxQWxnb3JpdGhtKHJlYXNvbikge1xuXHRcdCAgICAgICAgICAgIGNhbmNlbGVkMSA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgcmVhc29uMSA9IHJlYXNvbjtcblx0XHQgICAgICAgICAgICBpZiAoY2FuY2VsZWQyKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuXHRcdCAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIGNhbmNlbDJBbGdvcml0aG0ocmVhc29uKSB7XG5cdFx0ICAgICAgICAgICAgY2FuY2VsZWQyID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICByZWFzb24yID0gcmVhc29uO1xuXHRcdCAgICAgICAgICAgIGlmIChjYW5jZWxlZDEpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG5cdFx0ICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbDFBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xuXHRcdCAgICAgICAgYnJhbmNoMiA9IENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbDJBbGdvcml0aG0sIGNhbmNlbDJBbGdvcml0aG0pO1xuXHRcdCAgICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG5cdFx0ICAgICAgICByZXR1cm4gW2JyYW5jaDEsIGJyYW5jaDJdO1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlKHNvdXJjZSwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShzb3VyY2UsIGNvbnRleHQpO1xuXHRcdCAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBzb3VyY2U7XG5cdFx0ICAgICAgICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuXHRcdCAgICAgICAgY29uc3QgY2FuY2VsID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmNhbmNlbDtcblx0XHQgICAgICAgIGNvbnN0IHB1bGwgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwucHVsbDtcblx0XHQgICAgICAgIGNvbnN0IHN0YXJ0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnN0YXJ0O1xuXHRcdCAgICAgICAgY29uc3QgdHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC50eXBlO1xuXHRcdCAgICAgICAgcmV0dXJuIHtcblx0XHQgICAgICAgICAgICBhdXRvQWxsb2NhdGVDaHVua1NpemU6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYXV0b0FsbG9jYXRlQ2h1bmtTaXplJyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgY2FuY2VsOiBjYW5jZWwgPT09IHVuZGVmaW5lZCA/XG5cdFx0ICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soY2FuY2VsLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2FuY2VsJyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgcHVsbDogcHVsbCA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2socHVsbCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3B1bGwnIHRoYXRgKSxcblx0XHQgICAgICAgICAgICBzdGFydDogc3RhcnQgPT09IHVuZGVmaW5lZCA/XG5cdFx0ICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgdHlwZTogdHlwZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSh0eXBlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd0eXBlJyB0aGF0YClcblx0XHQgICAgICAgIH07XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiAocmVhc29uKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVN0cmVhbVR5cGUodHlwZSwgY29udGV4dCkge1xuXHRcdCAgICAgICAgdHlwZSA9IGAke3R5cGV9YDtcblx0XHQgICAgICAgIGlmICh0eXBlICE9PSAnYnl0ZXMnKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSAnJHt0eXBlfScgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtVHlwZWApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHR5cGU7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGVyT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuXHRcdCAgICAgICAgY29uc3QgbW9kZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlO1xuXHRcdCAgICAgICAgcmV0dXJuIHtcblx0XHQgICAgICAgICAgICBtb2RlOiBtb2RlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlKG1vZGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ21vZGUnIHRoYXRgKVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlKG1vZGUsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIG1vZGUgPSBgJHttb2RlfWA7XG5cdFx0ICAgICAgICBpZiAobW9kZSAhPT0gJ2J5b2InKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSAnJHttb2RlfScgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZWApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIG1vZGU7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0SXRlcmF0b3JPcHRpb25zKG9wdGlvbnMsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG5cdFx0ICAgICAgICBjb25zdCBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRDYW5jZWw7XG5cdFx0ICAgICAgICByZXR1cm4geyBwcmV2ZW50Q2FuY2VsOiBCb29sZWFuKHByZXZlbnRDYW5jZWwpIH07XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0UGlwZU9wdGlvbnMob3B0aW9ucywgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcblx0XHQgICAgICAgIGNvbnN0IHByZXZlbnRBYm9ydCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV2ZW50QWJvcnQ7XG5cdFx0ICAgICAgICBjb25zdCBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRDYW5jZWw7XG5cdFx0ICAgICAgICBjb25zdCBwcmV2ZW50Q2xvc2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENsb3NlO1xuXHRcdCAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbDtcblx0XHQgICAgICAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2lnbmFsJyB0aGF0YCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgICAgIHByZXZlbnRBYm9ydDogQm9vbGVhbihwcmV2ZW50QWJvcnQpLFxuXHRcdCAgICAgICAgICAgIHByZXZlbnRDYW5jZWw6IEJvb2xlYW4ocHJldmVudENhbmNlbCksXG5cdFx0ICAgICAgICAgICAgcHJldmVudENsb3NlOiBCb29sZWFuKHByZXZlbnRDbG9zZSksXG5cdFx0ICAgICAgICAgICAgc2lnbmFsXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgaWYgKCFpc0Fib3J0U2lnbmFsKHNpZ25hbCkpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBBYm9ydFNpZ25hbC5gKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcihwYWlyLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KHBhaXIsIGNvbnRleHQpO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGFibGUgPSBwYWlyID09PSBudWxsIHx8IHBhaXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhaXIucmVhZGFibGU7XG5cdFx0ICAgICAgICBhc3NlcnRSZXF1aXJlZEZpZWxkKHJlYWRhYmxlLCAncmVhZGFibGUnLCAnUmVhZGFibGVXcml0YWJsZVBhaXInKTtcblx0XHQgICAgICAgIGFzc2VydFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdyZWFkYWJsZScgdGhhdGApO1xuXHRcdCAgICAgICAgY29uc3Qgd3JpdGFibGUgPSBwYWlyID09PSBudWxsIHx8IHBhaXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhaXIud3JpdGFibGU7XG5cdFx0ICAgICAgICBhc3NlcnRSZXF1aXJlZEZpZWxkKHdyaXRhYmxlLCAnd3JpdGFibGUnLCAnUmVhZGFibGVXcml0YWJsZVBhaXInKTtcblx0XHQgICAgICAgIGFzc2VydFdyaXRhYmxlU3RyZWFtKHdyaXRhYmxlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd3cml0YWJsZScgdGhhdGApO1xuXHRcdCAgICAgICAgcmV0dXJuIHsgcmVhZGFibGUsIHdyaXRhYmxlIH07XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvKipcblx0XHQgICAgICogQSByZWFkYWJsZSBzdHJlYW0gcmVwcmVzZW50cyBhIHNvdXJjZSBvZiBkYXRhLCBmcm9tIHdoaWNoIHlvdSBjYW4gcmVhZC5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgUmVhZGFibGVTdHJlYW0ge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IocmF3VW5kZXJseWluZ1NvdXJjZSA9IHt9LCByYXdTdHJhdGVneSA9IHt9KSB7XG5cdFx0ICAgICAgICAgICAgaWYgKHJhd1VuZGVybHlpbmdTb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByYXdVbmRlcmx5aW5nU291cmNlID0gbnVsbDtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGFzc2VydE9iamVjdChyYXdVbmRlcmx5aW5nU291cmNlLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBjb25zdCB1bmRlcmx5aW5nU291cmNlID0gY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlKHJhd1VuZGVybHlpbmdTb3VyY2UsICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0odGhpcyk7XG5cdFx0ICAgICAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2UudHlwZSA9PT0gJ2J5dGVzJykge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoc3RyYXRlZ3kuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHN0cmF0ZWd5IGZvciBhIGJ5dGUgc3RyZWFtIGNhbm5vdCBoYXZlIGEgc2l6ZSBmdW5jdGlvbicpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMCk7XG5cdFx0ICAgICAgICAgICAgICAgIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKHRoaXMsIHVuZGVybHlpbmdTb3VyY2UsIGhpZ2hXYXRlck1hcmspO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHN0cmF0ZWd5KTtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAxKTtcblx0XHQgICAgICAgICAgICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UodGhpcywgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmVhZGFibGUgc3RyZWFtIGlzIGxvY2tlZCB0byBhIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgfCByZWFkZXJ9LlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgbG9ja2VkKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2xvY2tlZCcpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogQ2FuY2VscyB0aGUgc3RyZWFtLCBzaWduYWxpbmcgYSBsb3NzIG9mIGludGVyZXN0IGluIHRoZSBzdHJlYW0gYnkgYSBjb25zdW1lci5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBUaGUgc3VwcGxpZWQgYHJlYXNvbmAgYXJndW1lbnQgd2lsbCBiZSBnaXZlbiB0byB0aGUgdW5kZXJseWluZyBzb3VyY2UncyB7QGxpbmsgVW5kZXJseWluZ1NvdXJjZS5jYW5jZWwgfCBjYW5jZWwoKX1cblx0XHQgICAgICAgICAqIG1ldGhvZCwgd2hpY2ggbWlnaHQgb3IgbWlnaHQgbm90IHVzZSBpdC5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgY2FuY2VsKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2NhbmNlbCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbmNlbCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgcmVhZGVyJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwodGhpcywgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGdldFJlYWRlcihyYXdPcHRpb25zID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZ2V0UmVhZGVyJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0UmVhZGVyT3B0aW9ucyhyYXdPcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMubW9kZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHBpcGVUaHJvdWdoKHJhd1RyYW5zZm9ybSwgcmF3T3B0aW9ucyA9IHt9KSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgncGlwZVRocm91Z2gnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChyYXdUcmFuc2Zvcm0sIDEsICdwaXBlVGhyb3VnaCcpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcihyYXdUcmFuc2Zvcm0sICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRyYW5zZm9ybS53cml0YWJsZSkpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFdyaXRhYmxlU3RyZWFtJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBSZWFkYWJsZVN0cmVhbVBpcGVUbyh0aGlzLCB0cmFuc2Zvcm0ud3JpdGFibGUsIG9wdGlvbnMucHJldmVudENsb3NlLCBvcHRpb25zLnByZXZlbnRBYm9ydCwgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsLCBvcHRpb25zLnNpZ25hbCk7XG5cdFx0ICAgICAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwcm9taXNlKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtLnJlYWRhYmxlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcGlwZVRvKGRlc3RpbmF0aW9uLCByYXdPcHRpb25zID0ge30pIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdwaXBlVG8nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGBQYXJhbWV0ZXIgMSBpcyByZXF1aXJlZCBpbiAncGlwZVRvJy5gKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKGRlc3RpbmF0aW9uKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvJ3MgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFdyaXRhYmxlU3RyZWFtYCkpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBsZXQgb3B0aW9ucztcblx0XHQgICAgICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgICAgICBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNhdGNoIChlKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChkZXN0aW5hdGlvbikpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbyBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbScpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUGlwZVRvKHRoaXMsIGRlc3RpbmF0aW9uLCBvcHRpb25zLnByZXZlbnRDbG9zZSwgb3B0aW9ucy5wcmV2ZW50QWJvcnQsIG9wdGlvbnMucHJldmVudENhbmNlbCwgb3B0aW9ucy5zaWduYWwpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBUZWVzIHRoaXMgcmVhZGFibGUgc3RyZWFtLCByZXR1cm5pbmcgYSB0d28tZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSB0d28gcmVzdWx0aW5nIGJyYW5jaGVzIGFzXG5cdFx0ICAgICAgICAgKiBuZXcge0BsaW5rIFJlYWRhYmxlU3RyZWFtfSBpbnN0YW5jZXMuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogVGVlaW5nIGEgc3RyZWFtIHdpbGwgbG9jayBpdCwgcHJldmVudGluZyBhbnkgb3RoZXIgY29uc3VtZXIgZnJvbSBhY3F1aXJpbmcgYSByZWFkZXIuXG5cdFx0ICAgICAgICAgKiBUbyBjYW5jZWwgdGhlIHN0cmVhbSwgY2FuY2VsIGJvdGggb2YgdGhlIHJlc3VsdGluZyBicmFuY2hlczsgYSBjb21wb3NpdGUgY2FuY2VsbGF0aW9uIHJlYXNvbiB3aWxsIHRoZW4gYmVcblx0XHQgICAgICAgICAqIHByb3BhZ2F0ZWQgdG8gdGhlIHN0cmVhbSdzIHVuZGVybHlpbmcgc291cmNlLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgY2h1bmtzIHNlZW4gaW4gZWFjaCBicmFuY2ggd2lsbCBiZSB0aGUgc2FtZSBvYmplY3QuIElmIHRoZSBjaHVua3MgYXJlIG5vdCBpbW11dGFibGUsXG5cdFx0ICAgICAgICAgKiB0aGlzIGNvdWxkIGFsbG93IGludGVyZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gYnJhbmNoZXMuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIHRlZSgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCd0ZWUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3QgYnJhbmNoZXMgPSBSZWFkYWJsZVN0cmVhbVRlZSh0aGlzKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gQ3JlYXRlQXJyYXlGcm9tTGlzdChicmFuY2hlcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICB2YWx1ZXMocmF3T3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3ZhbHVlcycpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udmVydEl0ZXJhdG9yT3B0aW9ucyhyYXdPcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcywgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIHtcblx0XHQgICAgICAgIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBnZXRSZWFkZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcGlwZVRocm91Z2g6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcGlwZVRvOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHRlZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICB2YWx1ZXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgbG9ja2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbScsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLmFzeW5jSXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC5hc3luY0l0ZXJhdG9yLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6IFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS52YWx1ZXMsXG5cdFx0ICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cdFx0ICAgIC8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG5cdFx0ICAgIGZ1bmN0aW9uIENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmsgPSAxLCBzaXplQWxnb3JpdGhtID0gKCkgPT4gMSkge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuXHRcdCAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcblx0XHQgICAgICAgIHJldHVybiBzdHJlYW07XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gVGhyb3dzIGlmIGFuZCBvbmx5IGlmIHN0YXJ0QWxnb3JpdGhtIHRocm93cy5cblx0XHQgICAgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0pIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlKTtcblx0XHQgICAgICAgIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbShzdHJlYW0pO1xuXHRcdCAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xuXHRcdCAgICAgICAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgMCwgdW5kZWZpbmVkKTtcblx0XHQgICAgICAgIHJldHVybiBzdHJlYW07XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuXHRcdCAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICdyZWFkYWJsZSc7XG5cdFx0ICAgICAgICBzdHJlYW0uX3JlYWRlciA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IGZhbHNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW0oeCkge1xuXHRcdCAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcicpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkge1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fcmVhZGVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBSZWFkYWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cdFx0ICAgICAgICBpZiAocmVhZGVyICE9PSB1bmRlZmluZWQgJiYgSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuXHRcdCAgICAgICAgICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKHJlYWRJbnRvUmVxdWVzdCA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3Qgc291cmNlQ2FuY2VsUHJvbWlzZSA9IHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW0NhbmNlbFN0ZXBzXShyZWFzb24pO1xuXHRcdCAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHNvdXJjZUNhbmNlbFByb21pc2UsIG5vb3ApO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG5cdFx0ICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcblx0XHQgICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpO1xuXHRcdCAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcblx0XHQgICAgICAgICAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cy5mb3JFYWNoKHJlYWRSZXF1ZXN0ID0+IHtcblx0XHQgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yZWQnO1xuXHRcdCAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IGU7XG5cdFx0ICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcblx0XHQgICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgZSk7XG5cdFx0ICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuXHRcdCAgICAgICAgICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzLmZvckVhY2gocmVhZFJlcXVlc3QgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmZvckVhY2gocmVhZEludG9SZXF1ZXN0ID0+IHtcblx0XHQgICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cblx0XHQgICAgZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1gKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KGluaXQsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydERpY3Rpb25hcnkoaW5pdCwgY29udGV4dCk7XG5cdFx0ICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmhpZ2hXYXRlck1hcms7XG5cdFx0ICAgICAgICBhc3NlcnRSZXF1aXJlZEZpZWxkKGhpZ2hXYXRlck1hcmssICdoaWdoV2F0ZXJNYXJrJywgJ1F1ZXVpbmdTdHJhdGVneUluaXQnKTtcblx0XHQgICAgICAgIHJldHVybiB7XG5cdFx0ICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogY29udmVydFVucmVzdHJpY3RlZERvdWJsZShoaWdoV2F0ZXJNYXJrKVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIC8vIFRoZSBzaXplIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgbm9yIGJlIGEgY29uc3RydWN0b3Jcblx0XHQgICAgY29uc3QgYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiA9IChjaHVuaykgPT4ge1xuXHRcdCAgICAgICAgcmV0dXJuIGNodW5rLmJ5dGVMZW5ndGg7XG5cdFx0ICAgIH07XG5cdFx0ICAgIHRyeSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiwgJ25hbWUnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdzaXplJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNhdGNoIChfYSkge1xuXHRcdCAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBub24tY29uZmlndXJhYmxlIGluIG9sZGVyIGJyb3dzZXJzLCBzbyBpZ25vcmUgaWYgdGhpcyB0aHJvd3MuXG5cdFx0ICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuXHRcdCAgICB9XG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBIHF1ZXVpbmcgc3RyYXRlZ3kgdGhhdCBjb3VudHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiBlYWNoIGNodW5rLlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHQgICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KG9wdGlvbnMsIDEsICdCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5Jyk7XG5cdFx0ICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KG9wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICB0aGlzLl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyB0aGUgaGlnaCB3YXRlciBtYXJrIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGhpZ2hXYXRlck1hcmsoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24oJ2hpZ2hXYXRlck1hcmsnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBNZWFzdXJlcyB0aGUgc2l6ZSBvZiBgY2h1bmtgIGJ5IHJldHVybmluZyB0aGUgdmFsdWUgb2YgaXRzIGBieXRlTGVuZ3RoYCBwcm9wZXJ0eS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IHNpemUoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3NpemUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGJ5dGVMZW5ndGhTaXplRnVuY3Rpb247XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIHtcblx0XHQgICAgICAgIGhpZ2hXYXRlck1hcms6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgc2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cblx0XHQgICAgfSk7XG5cdFx0ICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5Jyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LlxuXHRcdCAgICBmdW5jdGlvbiBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneWApO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsnKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIC8vIFRoZSBzaXplIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgbm9yIGJlIGEgY29uc3RydWN0b3Jcblx0XHQgICAgY29uc3QgY291bnRTaXplRnVuY3Rpb24gPSAoKSA9PiB7XG5cdFx0ICAgICAgICByZXR1cm4gMTtcblx0XHQgICAgfTtcblx0XHQgICAgdHJ5IHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3VudFNpemVGdW5jdGlvbiwgJ25hbWUnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdzaXplJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNhdGNoIChfYSkge1xuXHRcdCAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBub24tY29uZmlndXJhYmxlIGluIG9sZGVyIGJyb3dzZXJzLCBzbyBpZ25vcmUgaWYgdGhpcyB0aHJvd3MuXG5cdFx0ICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuXHRcdCAgICB9XG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBIHF1ZXVpbmcgc3RyYXRlZ3kgdGhhdCBjb3VudHMgdGhlIG51bWJlciBvZiBjaHVua3MuXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEBwdWJsaWNcblx0XHQgICAgICovXG5cdFx0ICAgIGNsYXNzIENvdW50UXVldWluZ1N0cmF0ZWd5IHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHQgICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KG9wdGlvbnMsIDEsICdDb3VudFF1ZXVpbmdTdHJhdGVneScpO1xuXHRcdCAgICAgICAgICAgIG9wdGlvbnMgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChvcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBoaWdoIHdhdGVyIG1hcmsgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgaGlnaFdhdGVyTWFyaygpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzQ291bnRRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKCdoaWdoV2F0ZXJNYXJrJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIE1lYXN1cmVzIHRoZSBzaXplIG9mIGBjaHVua2AgYnkgYWx3YXlzIHJldHVybmluZyAxLlxuXHRcdCAgICAgICAgICogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHRvdGFsIHF1ZXVlIHNpemUgaXMgYSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIGNodW5rcyBpbiB0aGUgcXVldWUuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCBzaXplKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3NpemUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGNvdW50U2l6ZUZ1bmN0aW9uO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdDb3VudFF1ZXVpbmdTdHJhdGVneScsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgQ291bnRRdWV1aW5nU3RyYXRlZ3kuXG5cdFx0ICAgIGZ1bmN0aW9uIGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIENvdW50UXVldWluZ1N0cmF0ZWd5YCk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIENvdW50UXVldWluZ1N0cmF0ZWd5O1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyKG9yaWdpbmFsLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9yaWdpbmFsLCBjb250ZXh0KTtcblx0XHQgICAgICAgIGNvbnN0IGZsdXNoID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmZsdXNoO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGFibGVUeXBlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnJlYWRhYmxlVHlwZTtcblx0XHQgICAgICAgIGNvbnN0IHN0YXJ0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnN0YXJ0O1xuXHRcdCAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnRyYW5zZm9ybTtcblx0XHQgICAgICAgIGNvbnN0IHdyaXRhYmxlVHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC53cml0YWJsZVR5cGU7XG5cdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgICAgIGZsdXNoOiBmbHVzaCA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayhmbHVzaCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2ZsdXNoJyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgcmVhZGFibGVUeXBlLFxuXHRcdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gPT09IHVuZGVmaW5lZCA/XG5cdFx0ICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKHRyYW5zZm9ybSwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3RyYW5zZm9ybScgdGhhdGApLFxuXHRcdCAgICAgICAgICAgIHdyaXRhYmxlVHlwZVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChjaHVuaywgY29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIC8vIENsYXNzIFRyYW5zZm9ybVN0cmVhbVxuXHRcdCAgICAvKipcblx0XHQgICAgICogQSB0cmFuc2Zvcm0gc3RyZWFtIGNvbnNpc3RzIG9mIGEgcGFpciBvZiBzdHJlYW1zOiBhIHtAbGluayBXcml0YWJsZVN0cmVhbSB8IHdyaXRhYmxlIHN0cmVhbX0sXG5cdFx0ICAgICAqIGtub3duIGFzIGl0cyB3cml0YWJsZSBzaWRlLCBhbmQgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBzdHJlYW19LCBrbm93biBhcyBpdHMgcmVhZGFibGUgc2lkZS5cblx0XHQgICAgICogSW4gYSBtYW5uZXIgc3BlY2lmaWMgdG8gdGhlIHRyYW5zZm9ybSBzdHJlYW0gaW4gcXVlc3Rpb24sIHdyaXRlcyB0byB0aGUgd3JpdGFibGUgc2lkZSByZXN1bHQgaW4gbmV3IGRhdGEgYmVpbmdcblx0XHQgICAgICogbWFkZSBhdmFpbGFibGUgZm9yIHJlYWRpbmcgZnJvbSB0aGUgcmVhZGFibGUgc2lkZS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgVHJhbnNmb3JtU3RyZWFtIHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKHJhd1RyYW5zZm9ybWVyID0ge30sIHJhd1dyaXRhYmxlU3RyYXRlZ3kgPSB7fSwgcmF3UmVhZGFibGVTdHJhdGVneSA9IHt9KSB7XG5cdFx0ICAgICAgICAgICAgaWYgKHJhd1RyYW5zZm9ybWVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgcmF3VHJhbnNmb3JtZXIgPSBudWxsO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCB3cml0YWJsZVN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdXcml0YWJsZVN0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlU3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1JlYWRhYmxlU3RyYXRlZ3ksICdUaGlyZCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNvbnZlcnRUcmFuc2Zvcm1lcihyYXdUcmFuc2Zvcm1lciwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lci5yZWFkYWJsZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCByZWFkYWJsZVR5cGUgc3BlY2lmaWVkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lci53cml0YWJsZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB3cml0YWJsZVR5cGUgc3BlY2lmaWVkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHJlYWRhYmxlU3RyYXRlZ3ksIDApO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHJlYWRhYmxlU3RyYXRlZ3kpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHdyaXRhYmxlU3RyYXRlZ3ksIDEpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHdyaXRhYmxlU3RyYXRlZ3kpO1xuXHRcdCAgICAgICAgICAgIGxldCBzdGFydFByb21pc2VfcmVzb2x2ZTtcblx0XHQgICAgICAgICAgICBjb25zdCBzdGFydFByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbSh0aGlzLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG5cdFx0ICAgICAgICAgICAgU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcih0aGlzLCB0cmFuc2Zvcm1lcik7XG5cdFx0ICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodHJhbnNmb3JtZXIuc3RhcnQodGhpcy5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcikpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSB0cmFuc2Zvcm0gc3RyZWFtLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgcmVhZGFibGUoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkYWJsZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSB0cmFuc2Zvcm0gc3RyZWFtLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgd3JpdGFibGUoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCd3cml0YWJsZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgcmVhZGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgd3JpdGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW0nLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbShzdHJlYW0sIHN0YXJ0UHJvbWlzZSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKSB7XG5cdFx0ICAgICAgICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gc3RhcnRQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gd3JpdGVBbGdvcml0aG0oY2h1bmspIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobShzdHJlYW0sIGNodW5rKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIGFib3J0QWxnb3JpdGhtKHJlYXNvbikge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Fib3J0QWxnb3JpdGhtKHN0cmVhbSwgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIGNsb3NlQWxnb3JpdGhtKCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBzdHJlYW0uX3dyaXRhYmxlID0gQ3JlYXRlV3JpdGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtKTtcblx0XHQgICAgICAgIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBmdW5jdGlvbiBjYW5jZWxBbGdvcml0aG0ocmVhc29uKSB7XG5cdFx0ICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIHJlYXNvbik7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHN0cmVhbS5fcmVhZGFibGUgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG5cdFx0ICAgICAgICAvLyBUaGUgW1tiYWNrcHJlc3N1cmVdXSBzbG90IGlzIHNldCB0byB1bmRlZmluZWQgc28gdGhhdCBpdCBjYW4gYmUgaW5pdGlhbGlzZWQgYnkgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlLlxuXHRcdCAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIHRydWUpO1xuXHRcdCAgICAgICAgc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtKHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ190cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFRyYW5zZm9ybVN0cmVhbTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBUaGlzIGlzIGEgbm8tb3AgaWYgYm90aCBzaWRlcyBhcmUgYWxyZWFkeSBlcnJvcmVkLlxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIGUpIHtcblx0XHQgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGUpO1xuXHRcdCAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKSB7XG5cdFx0ICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoc3RyZWFtLl93cml0YWJsZS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLCBlKTtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuXHRcdCAgICAgICAgICAgIC8vIFByZXRlbmQgdGhhdCBwdWxsKCkgd2FzIGNhbGxlZCB0byBwZXJtaXQgYW55IHBlbmRpbmcgd3JpdGUoKSBjYWxscyB0byBjb21wbGV0ZS4gVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKClcblx0XHQgICAgICAgICAgICAvLyBjYW5ub3QgYmUgY2FsbGVkIGZyb20gZW5xdWV1ZSgpIG9yIHB1bGwoKSBvbmNlIHRoZSBSZWFkYWJsZVN0cmVhbSBpcyBlcnJvcmVkLCBzbyB0aGlzIHdpbGwgd2lsbCBiZSB0aGUgZmluYWwgdGltZVxuXHRcdCAgICAgICAgICAgIC8vIF9iYWNrcHJlc3N1cmUgaXMgc2V0LlxuXHRcdCAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGZhbHNlKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpIHtcblx0XHQgICAgICAgIC8vIFBhc3NlcyBhbHNvIHdoZW4gY2FsbGVkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gYmFja3ByZXNzdXJlO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIENsYXNzIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyXG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBbGxvd3MgY29udHJvbCBvZiB0aGUge0BsaW5rIFJlYWRhYmxlU3RyZWFtfSBhbmQge0BsaW5rIFdyaXRhYmxlU3RyZWFtfSBvZiB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgVHJhbnNmb3JtU3RyZWFtfS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IoKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgcmVhZGFibGUgc2lkZeKAmXMgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzIG92ZXItZnVsbC5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlQ29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZW5xdWV1ZShjaHVuayA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogRXJyb3JzIGJvdGggdGhlIHJlYWRhYmxlIHNpZGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlXG5cdFx0ICAgICAgICAgKiBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC4gQW55IGNodW5rcyBxdWV1ZWQgZm9yIHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgZGlzY2FyZGVkLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBlcnJvcihyZWFzb24gPSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIHJlYXNvbik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIENsb3NlcyB0aGUgcmVhZGFibGUgc2lkZSBhbmQgZXJyb3JzIHRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0uIFRoaXMgaXMgdXNlZnVsIHdoZW4gdGhlXG5cdFx0ICAgICAgICAgKiB0cmFuc2Zvcm1lciBvbmx5IG5lZWRzIHRvIGNvbnN1bWUgYSBwb3J0aW9uIG9mIHRoZSBjaHVua3Mgd3JpdHRlbiB0byB0aGUgd3JpdGFibGUgc2lkZS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgdGVybWluYXRlKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3Rlcm1pbmF0ZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclRlcm1pbmF0ZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcblx0XHQgICAgICAgIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgdGVybWluYXRlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBUcmFuc2Zvcm0gU3RyZWFtIERlZmF1bHQgQ29udHJvbGxlciBBYnN0cmFjdCBPcGVyYXRpb25zXG5cdFx0ICAgIGZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoeCkge1xuXHRcdCAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0nKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHRyYW5zZm9ybUFsZ29yaXRobSwgZmx1c2hBbGdvcml0aG0pIHtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0gPSBzdHJlYW07XG5cdFx0ICAgICAgICBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtID0gdHJhbnNmb3JtQWxnb3JpdGhtO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0gPSBmbHVzaEFsZ29yaXRobTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVRyYW5zZm9ybWVyKHN0cmVhbSwgdHJhbnNmb3JtZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBsZXQgdHJhbnNmb3JtQWxnb3JpdGhtID0gKGNodW5rKSA9PiB7XG5cdFx0ICAgICAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKTtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY2F0Y2ggKHRyYW5zZm9ybVJlc3VsdEUpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodHJhbnNmb3JtUmVzdWx0RSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgICAgIGxldCBmbHVzaEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIGlmICh0cmFuc2Zvcm1lci50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHRyYW5zZm9ybUFsZ29yaXRobSA9IGNodW5rID0+IHRyYW5zZm9ybWVyLnRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAodHJhbnNmb3JtZXIuZmx1c2ggIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGZsdXNoQWxnb3JpdGhtID0gKCkgPT4gdHJhbnNmb3JtZXIuZmx1c2goY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgdHJhbnNmb3JtQWxnb3JpdGhtLCBmbHVzaEFsZ29yaXRobSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuXHRcdCAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUocmVhZGFibGVDb250cm9sbGVyKSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlIHNpZGUgaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWUnKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIFdlIHRocm90dGxlIHRyYW5zZm9ybSBpbnZvY2F0aW9ucyBiYXNlZCBvbiB0aGUgYmFja3ByZXNzdXJlIG9mIHRoZSBSZWFkYWJsZVN0cmVhbSwgYnV0IHdlIHN0aWxsXG5cdFx0ICAgICAgICAvLyBhY2NlcHQgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKCkgY2FsbHMuXG5cdFx0ICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHJlYWRhYmxlQ29udHJvbGxlciwgY2h1bmspO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY2F0Y2ggKGUpIHtcblx0XHQgICAgICAgICAgICAvLyBUaGlzIGhhcHBlbnMgd2hlbiByZWFkYWJsZVN0cmF0ZWd5LnNpemUoKSB0aHJvd3MuXG5cdFx0ICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpO1xuXHRcdCAgICAgICAgICAgIHRocm93IHN0cmVhbS5fcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckhhc0JhY2twcmVzc3VyZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgaWYgKGJhY2twcmVzc3VyZSAhPT0gc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCB0cnVlKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpIHtcblx0XHQgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0sIGUpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuaykge1xuXHRcdCAgICAgICAgY29uc3QgdHJhbnNmb3JtUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobShjaHVuayk7XG5cdFx0ICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgodHJhbnNmb3JtUHJvbWlzZSwgdW5kZWZpbmVkLCByID0+IHtcblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLCByKTtcblx0XHQgICAgICAgICAgICB0aHJvdyByO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcblx0XHQgICAgICAgIGNvbnN0IHJlYWRhYmxlQ29udHJvbGxlciA9IHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtcblx0XHQgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKCdUcmFuc2Zvcm1TdHJlYW0gdGVybWluYXRlZCcpO1xuXHRcdCAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGVycm9yKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2luayBBbGdvcml0aG1zXG5cdFx0ICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rV3JpdGVBbGdvcml0aG0oc3RyZWFtLCBjaHVuaykge1xuXHRcdCAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2U7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKGJhY2twcmVzc3VyZUNoYW5nZVByb21pc2UsICgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3Qgd3JpdGFibGUgPSBzdHJlYW0uX3dyaXRhYmxlO1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHdyaXRhYmxlLl9zdGF0ZTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyB3cml0YWJsZS5fc3RvcmVkRXJyb3I7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuayk7XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtKGNvbnRyb2xsZXIsIGNodW5rKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Fib3J0QWxnb3JpdGhtKHN0cmVhbSwgcmVhc29uKSB7XG5cdFx0ICAgICAgICAvLyBhYm9ydCgpIGlzIG5vdCBjYWxsZWQgc3luY2hyb25vdXNseSwgc28gaXQgaXMgcG9zc2libGUgZm9yIGFib3J0KCkgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHN0cmVhbSBpcyBhbHJlYWR5XG5cdFx0ICAgICAgICAvLyBlcnJvcmVkLlxuXHRcdCAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCByZWFzb24pO1xuXHRcdCAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtKHN0cmVhbSkge1xuXHRcdCAgICAgICAgLy8gc3RyZWFtLl9yZWFkYWJsZSBjYW5ub3QgY2hhbmdlIGFmdGVyIGNvbnN0cnVjdGlvbiwgc28gY2FjaGluZyBpdCBhY3Jvc3MgYSBjYWxsIHRvIHVzZXIgY29kZSBpcyBzYWZlLlxuXHRcdCAgICAgICAgY29uc3QgcmVhZGFibGUgPSBzdHJlYW0uX3JlYWRhYmxlO1xuXHRcdCAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcblx0XHQgICAgICAgIGNvbnN0IGZsdXNoUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgIC8vIFJldHVybiBhIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWQgb24gc3VjY2Vzcy5cblx0XHQgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChmbHVzaFByb21pc2UsICgpID0+IHtcblx0XHQgICAgICAgICAgICBpZiAocmVhZGFibGUuX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9LCByID0+IHtcblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIHIpO1xuXHRcdCAgICAgICAgICAgIHRocm93IHJlYWRhYmxlLl9zdG9yZWRFcnJvcjtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2UgQWxnb3JpdGhtc1xuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobShzdHJlYW0pIHtcblx0XHQgICAgICAgIC8vIEludmFyaWFudC4gRW5mb3JjZWQgYnkgdGhlIHByb21pc2VzIHJldHVybmVkIGJ5IHN0YXJ0KCkgYW5kIHB1bGwoKS5cblx0XHQgICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGZhbHNlKTtcblx0XHQgICAgICAgIC8vIFByZXZlbnQgdGhlIG5leHQgcHVsbCgpIGNhbGwgdW50aWwgdGhlcmUgaXMgYmFja3ByZXNzdXJlLlxuXHRcdCAgICAgICAgcmV0dXJuIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFRyYW5zZm9ybVN0cmVhbS5cblx0XHQgICAgZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBUcmFuc2Zvcm1TdHJlYW1gKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGV4cG9ydHMuQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSA9IEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3k7XG5cdFx0ICAgIGV4cG9ydHMuQ291bnRRdWV1aW5nU3RyYXRlZ3kgPSBDb3VudFF1ZXVpbmdTdHJhdGVneTtcblx0XHQgICAgZXhwb3J0cy5SZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcblx0XHQgICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbSA9IFJlYWRhYmxlU3RyZWFtO1xuXHRcdCAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciA9IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcblx0XHQgICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0ID0gUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcblx0XHQgICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcblx0XHQgICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI7XG5cdFx0ICAgIGV4cG9ydHMuVHJhbnNmb3JtU3RyZWFtID0gVHJhbnNmb3JtU3RyZWFtO1xuXHRcdCAgICBleHBvcnRzLlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG5cdFx0ICAgIGV4cG9ydHMuV3JpdGFibGVTdHJlYW0gPSBXcml0YWJsZVN0cmVhbTtcblx0XHQgICAgZXhwb3J0cy5Xcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcblx0XHQgICAgZXhwb3J0cy5Xcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI7XG5cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRcdH0pKSk7XG5cdFx0XG59IChwb255ZmlsbF9lczIwMTgsIHBvbnlmaWxsX2VzMjAxOC5leHBvcnRzKSk7XG5cdHJldHVybiBwb255ZmlsbF9lczIwMTguZXhwb3J0cztcbn1cblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5cbi8vIDY0IEtpQiAoc2FtZSBzaXplIGNocm9tZSBzbGljZSB0aGVpcnMgYmxvYiBpbnRvIFVpbnQ4YXJyYXkncylcbmNvbnN0IFBPT0xfU0laRSQxID0gNjU1MzY7XG5cbmlmICghZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSkge1xuICAvLyBgbm9kZTpzdHJlYW0vd2ViYCBnb3QgaW50cm9kdWNlZCBpbiB2MTYuNS4wIGFzIGV4cGVyaW1lbnRhbFxuICAvLyBhbmQgaXQncyBwcmVmZXJyZWQgb3ZlciB0aGUgcG9seWZpbGxlZCB2ZXJzaW9uLiBTbyB3ZSBhbHNvXG4gIC8vIHN1cHByZXNzIHRoZSB3YXJuaW5nIHRoYXQgZ2V0cyBlbWl0dGVkIGJ5IE5vZGVKUyBmb3IgdXNpbmcgaXQuXG4gIHRyeSB7XG4gICAgY29uc3QgcHJvY2VzcyA9IHJlcXVpcmUoJ25vZGU6cHJvY2VzcycpO1xuICAgIGNvbnN0IHsgZW1pdFdhcm5pbmcgfSA9IHByb2Nlc3M7XG4gICAgdHJ5IHtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcgPSAoKSA9PiB7fTtcbiAgICAgIE9iamVjdC5hc3NpZ24oZ2xvYmFsVGhpcywgcmVxdWlyZSgnbm9kZTpzdHJlYW0vd2ViJykpO1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyA9IGVtaXRXYXJuaW5nO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nID0gZW1pdFdhcm5pbmc7XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBmYWxsYmFjayB0byBwb2x5ZmlsbCBpbXBsZW1lbnRhdGlvblxuICAgIE9iamVjdC5hc3NpZ24oZ2xvYmFsVGhpcywgcmVxdWlyZVBvbnlmaWxsX2VzMjAxOCgpKTtcbiAgfVxufVxuXG50cnkge1xuICAvLyBEb24ndCB1c2Ugbm9kZTogcHJlZml4IGZvciB0aGlzLCByZXF1aXJlK25vZGU6IGlzIG5vdCBzdXBwb3J0ZWQgdW50aWwgbm9kZSB2MTQuMTRcbiAgLy8gT25seSBgaW1wb3J0KClgIGNhbiB1c2UgcHJlZml4IGluIDEyLjIwIGFuZCBsYXRlclxuICBjb25zdCB7IEJsb2IgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuICBpZiAoQmxvYiAmJiAhQmxvYi5wcm90b3R5cGUuc3RyZWFtKSB7XG4gICAgQmxvYi5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24gbmFtZSAocGFyYW1zKSB7XG4gICAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgICAgY29uc3QgYmxvYiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICBhc3luYyBwdWxsIChjdHJsKSB7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBibG9iLnNsaWNlKHBvc2l0aW9uLCBNYXRoLm1pbihibG9iLnNpemUsIHBvc2l0aW9uICsgUE9PTF9TSVpFJDEpKTtcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjaHVuay5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgIHBvc2l0aW9uICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGN0cmwuZW5xdWV1ZShuZXcgVWludDhBcnJheShidWZmZXIpKTtcblxuICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gYmxvYi5zaXplKSB7XG4gICAgICAgICAgICBjdHJsLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH1cbn0gY2F0Y2ggKGVycm9yKSB7fVxuXG4vKiEgZmV0Y2gtYmxvYi4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cblxuLy8gNjQgS2lCIChzYW1lIHNpemUgY2hyb21lIHNsaWNlIHRoZWlycyBibG9iIGludG8gVWludDhhcnJheSdzKVxuY29uc3QgUE9PTF9TSVpFID0gNjU1MzY7XG5cbi8qKiBAcGFyYW0geyhCbG9iIHwgVWludDhBcnJheSlbXX0gcGFydHMgKi9cbmFzeW5jIGZ1bmN0aW9uICogdG9JdGVyYXRvciAocGFydHMsIGNsb25lID0gdHJ1ZSkge1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBpZiAoJ3N0cmVhbScgaW4gcGFydCkge1xuICAgICAgeWllbGQgKiAoLyoqIEB0eXBlIHtBc3luY0l0ZXJhYmxlSXRlcmF0b3I8VWludDhBcnJheT59ICovIChwYXJ0LnN0cmVhbSgpKSk7XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkpIHtcbiAgICAgIGlmIChjbG9uZSkge1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBwYXJ0LmJ5dGVPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHBhcnQuYnl0ZU9mZnNldCArIHBhcnQuYnl0ZUxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHBvc2l0aW9uICE9PSBlbmQpIHtcbiAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5taW4oZW5kIC0gcG9zaXRpb24sIFBPT0xfU0laRSk7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBwYXJ0LmJ1ZmZlci5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBzaXplKTtcbiAgICAgICAgICBwb3NpdGlvbiArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgIHlpZWxkIG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgcGFydDtcbiAgICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAxMCAqL1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYmxvYnMgdGhhdCBoYXZlIGFycmF5QnVmZmVyIGJ1dCBubyBzdHJlYW0gbWV0aG9kIChub2RlcyBidWZmZXIuQmxvYilcbiAgICAgIGxldCBwb3NpdGlvbiA9IDAsIGIgPSAoLyoqIEB0eXBlIHtCbG9ifSAqLyAocGFydCkpO1xuICAgICAgd2hpbGUgKHBvc2l0aW9uICE9PSBiLnNpemUpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBiLnNsaWNlKHBvc2l0aW9uLCBNYXRoLm1pbihiLnNpemUsIHBvc2l0aW9uICsgUE9PTF9TSVpFKSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNodW5rLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIHBvc2l0aW9uICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICB5aWVsZCBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBfQmxvYiA9IGNsYXNzIEJsb2Ige1xuICAvKiogQHR5cGUge0FycmF5LjwoQmxvYnxVaW50OEFycmF5KT59ICovXG4gICNwYXJ0cyA9IFtdXG4gICN0eXBlID0gJydcbiAgI3NpemUgPSAwXG4gICNlbmRpbmdzID0gJ3RyYW5zcGFyZW50J1xuXG4gIC8qKlxuICAgKiBUaGUgQmxvYigpIGNvbnN0cnVjdG9yIHJldHVybnMgYSBuZXcgQmxvYiBvYmplY3QuIFRoZSBjb250ZW50XG4gICAqIG9mIHRoZSBibG9iIGNvbnNpc3RzIG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSB2YWx1ZXMgZ2l2ZW5cbiAgICogaW4gdGhlIHBhcmFtZXRlciBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBibG9iUGFydHNcbiAgICogQHBhcmFtIHt7IHR5cGU/OiBzdHJpbmcsIGVuZGluZ3M/OiBzdHJpbmcgfX0gW29wdGlvbnNdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYmxvYlBhcnRzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgYmxvYlBhcnRzICE9PSAnb2JqZWN0JyB8fCBibG9iUGFydHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnQmxvYlxcJzogVGhlIHByb3ZpZGVkIHZhbHVlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBzZXF1ZW5jZS4nKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYmxvYlBhcnRzW1N5bWJvbC5pdGVyYXRvcl0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnQmxvYlxcJzogVGhlIG9iamVjdCBtdXN0IGhhdmUgYSBjYWxsYWJsZSBAQGl0ZXJhdG9yIHByb3BlcnR5LicpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGNvbnN0cnVjdCBcXCdCbG9iXFwnOiBwYXJhbWV0ZXIgMiBjYW5ub3QgY29udmVydCB0byBkaWN0aW9uYXJ5LicpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwpIG9wdGlvbnMgPSB7fTtcblxuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYmxvYlBhcnRzKSB7XG4gICAgICBsZXQgcGFydDtcbiAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZWxlbWVudCkpIHtcbiAgICAgICAgcGFydCA9IG5ldyBVaW50OEFycmF5KGVsZW1lbnQuYnVmZmVyLnNsaWNlKGVsZW1lbnQuYnl0ZU9mZnNldCwgZWxlbWVudC5ieXRlT2Zmc2V0ICsgZWxlbWVudC5ieXRlTGVuZ3RoKSk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBwYXJ0ID0gbmV3IFVpbnQ4QXJyYXkoZWxlbWVudC5zbGljZSgwKSk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHBhcnQgPSBlbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydCA9IGVuY29kZXIuZW5jb2RlKGAke2VsZW1lbnR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpemUgPSBBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkgPyBwYXJ0LmJ5dGVMZW5ndGggOiBwYXJ0LnNpemU7XG4gICAgICAvLyBBdm9pZCBwdXNoaW5nIGVtcHR5IHBhcnRzIGludG8gdGhlIGFycmF5IHRvIGJldHRlciBHQyB0aGVtXG4gICAgICBpZiAoc2l6ZSkge1xuICAgICAgICB0aGlzLiNzaXplICs9IHNpemU7XG4gICAgICAgIHRoaXMuI3BhcnRzLnB1c2gocGFydCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4jZW5kaW5ncyA9IGAke29wdGlvbnMuZW5kaW5ncyA9PT0gdW5kZWZpbmVkID8gJ3RyYW5zcGFyZW50JyA6IG9wdGlvbnMuZW5kaW5nc31gO1xuICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGUgPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKG9wdGlvbnMudHlwZSk7XG4gICAgdGhpcy4jdHlwZSA9IC9eW1xceDIwLVxceDdFXSokLy50ZXN0KHR5cGUpID8gdHlwZSA6ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBCbG9iIGludGVyZmFjZSdzIHNpemUgcHJvcGVydHkgcmV0dXJucyB0aGVcbiAgICogc2l6ZSBvZiB0aGUgQmxvYiBpbiBieXRlcy5cbiAgICovXG4gIGdldCBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2l6ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIHByb3BlcnR5IG9mIGEgQmxvYiBvYmplY3QgcmV0dXJucyB0aGUgTUlNRSB0eXBlIG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLiN0eXBlXG4gIH1cblxuICAvKipcbiAgICogVGhlIHRleHQoKSBtZXRob2QgaW4gdGhlIEJsb2IgaW50ZXJmYWNlIHJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHN0cmluZyBjb250YWluaW5nIHRoZSBjb250ZW50cyBvZlxuICAgKiB0aGUgYmxvYiwgaW50ZXJwcmV0ZWQgYXMgVVRGLTguXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICovXG4gIGFzeW5jIHRleHQgKCkge1xuICAgIC8vIE1vcmUgb3B0aW1pemVkIHRoYW4gdXNpbmcgdGhpcy5hcnJheUJ1ZmZlcigpXG4gICAgLy8gdGhhdCByZXF1aXJlcyB0d2ljZSBhcyBtdWNoIHJhbVxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIHRvSXRlcmF0b3IodGhpcy4jcGFydHMsIGZhbHNlKSkge1xuICAgICAgc3RyICs9IGRlY29kZXIuZGVjb2RlKHBhcnQsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBSZW1haW5pbmdcbiAgICBzdHIgKz0gZGVjb2Rlci5kZWNvZGUoKTtcbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICAvKipcbiAgICogVGhlIGFycmF5QnVmZmVyKCkgbWV0aG9kIGluIHRoZSBCbG9iIGludGVyZmFjZSByZXR1cm5zIGFcbiAgICogUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBibG9iIGFzXG4gICAqIGJpbmFyeSBkYXRhIGNvbnRhaW5lZCBpbiBhbiBBcnJheUJ1ZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBhc3luYyBhcnJheUJ1ZmZlciAoKSB7XG4gICAgLy8gRWFzaWVyIHdheS4uLiBKdXN0IGEgdW5uZWNlc3Nhcnkgb3ZlcmhlYWRcbiAgICAvLyBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplKTtcbiAgICAvLyBhd2FpdCB0aGlzLnN0cmVhbSgpLmdldFJlYWRlcih7bW9kZTogJ2J5b2InfSkucmVhZCh2aWV3KTtcbiAgICAvLyByZXR1cm4gdmlldy5idWZmZXI7XG5cbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRvSXRlcmF0b3IodGhpcy4jcGFydHMsIGZhbHNlKSkge1xuICAgICAgZGF0YS5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhLmJ1ZmZlclxuICB9XG5cbiAgc3RyZWFtICgpIHtcbiAgICBjb25zdCBpdCA9IHRvSXRlcmF0b3IodGhpcy4jcGFydHMsIHRydWUpO1xuXG4gICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICBhc3luYyBwdWxsIChjdHJsKSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgICBjaHVuay5kb25lID8gY3RybC5jbG9zZSgpIDogY3RybC5lbnF1ZXVlKGNodW5rLnZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIGFzeW5jIGNhbmNlbCAoKSB7XG4gICAgICAgIGF3YWl0IGl0LnJldHVybigpO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVGhlIEJsb2IgaW50ZXJmYWNlJ3Mgc2xpY2UoKSBtZXRob2QgY3JlYXRlcyBhbmQgcmV0dXJucyBhXG4gICAqIG5ldyBCbG9iIG9iamVjdCB3aGljaCBjb250YWlucyBkYXRhIGZyb20gYSBzdWJzZXQgb2YgdGhlXG4gICAqIGJsb2Igb24gd2hpY2ggaXQncyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdXG4gICAqL1xuICBzbGljZSAoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLnNpemUsIHR5cGUgPSAnJykge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gdGhpcztcblxuICAgIGxldCByZWxhdGl2ZVN0YXJ0ID0gc3RhcnQgPCAwID8gTWF0aC5tYXgoc2l6ZSArIHN0YXJ0LCAwKSA6IE1hdGgubWluKHN0YXJ0LCBzaXplKTtcbiAgICBsZXQgcmVsYXRpdmVFbmQgPSBlbmQgPCAwID8gTWF0aC5tYXgoc2l6ZSArIGVuZCwgMCkgOiBNYXRoLm1pbihlbmQsIHNpemUpO1xuXG4gICAgY29uc3Qgc3BhbiA9IE1hdGgubWF4KHJlbGF0aXZlRW5kIC0gcmVsYXRpdmVTdGFydCwgMCk7XG4gICAgY29uc3QgcGFydHMgPSB0aGlzLiNwYXJ0cztcbiAgICBjb25zdCBibG9iUGFydHMgPSBbXTtcbiAgICBsZXQgYWRkZWQgPSAwO1xuXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAvLyBkb24ndCBhZGQgdGhlIG92ZXJmbG93IHRvIG5ldyBibG9iUGFydHNcbiAgICAgIGlmIChhZGRlZCA+PSBzcGFuKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpemUgPSBBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkgPyBwYXJ0LmJ5dGVMZW5ndGggOiBwYXJ0LnNpemU7XG4gICAgICBpZiAocmVsYXRpdmVTdGFydCAmJiBzaXplIDw9IHJlbGF0aXZlU3RhcnQpIHtcbiAgICAgICAgLy8gU2tpcCB0aGUgYmVnaW5uaW5nIGFuZCBjaGFuZ2UgdGhlIHJlbGF0aXZlXG4gICAgICAgIC8vIHN0YXJ0ICYgZW5kIHBvc2l0aW9uIGFzIHdlIHNraXAgdGhlIHVud2FudGVkIHBhcnRzXG4gICAgICAgIHJlbGF0aXZlU3RhcnQgLT0gc2l6ZTtcbiAgICAgICAgcmVsYXRpdmVFbmQgLT0gc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSkge1xuICAgICAgICAgIGNodW5rID0gcGFydC5zdWJhcnJheShyZWxhdGl2ZVN0YXJ0LCBNYXRoLm1pbihzaXplLCByZWxhdGl2ZUVuZCkpO1xuICAgICAgICAgIGFkZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2h1bmsgPSBwYXJ0LnNsaWNlKHJlbGF0aXZlU3RhcnQsIE1hdGgubWluKHNpemUsIHJlbGF0aXZlRW5kKSk7XG4gICAgICAgICAgYWRkZWQgKz0gY2h1bmsuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZWxhdGl2ZUVuZCAtPSBzaXplO1xuICAgICAgICBibG9iUGFydHMucHVzaChjaHVuayk7XG4gICAgICAgIHJlbGF0aXZlU3RhcnQgPSAwOyAvLyBBbGwgbmV4dCBzZXF1ZW50aWFsIHBhcnRzIHNob3VsZCBzdGFydCBhdCAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtdLCB7IHR5cGU6IFN0cmluZyh0eXBlKS50b0xvd2VyQ2FzZSgpIH0pO1xuICAgIGJsb2IuI3NpemUgPSBzcGFuO1xuICAgIGJsb2IuI3BhcnRzID0gYmxvYlBhcnRzO1xuXG4gICAgcmV0dXJuIGJsb2JcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdCbG9iJ1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChvYmplY3QpIHtcbiAgICByZXR1cm4gKFxuICAgICAgb2JqZWN0ICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKFxuICAgICAgICB0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nXG4gICAgICApICYmXG4gICAgICAvXihCbG9ifEZpbGUpJC8udGVzdChvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSlcbiAgICApXG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF9CbG9iLnByb3RvdHlwZSwge1xuICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgdHlwZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHNsaWNlOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5cbi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXMuQmxvYn0gKi9cbmNvbnN0IEJsb2IgPSBfQmxvYjtcbmNvbnN0IF9CbG9iJDEgPSBCbG9iO1xuXG5jb25zdCBfRmlsZSA9IGNsYXNzIEZpbGUgZXh0ZW5kcyBfQmxvYiQxIHtcbiAgI2xhc3RNb2RpZmllZCA9IDBcbiAgI25hbWUgPSAnJ1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geypbXX0gZmlsZUJpdHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVOYW1lXG4gICAqIEBwYXJhbSB7e2xhc3RNb2RpZmllZD86IG51bWJlciwgdHlwZT86IHN0cmluZ319IG9wdGlvbnNcbiAgICovLy8gQHRzLWlnbm9yZVxuICBjb25zdHJ1Y3RvciAoZmlsZUJpdHMsIGZpbGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ0ZpbGUnOiAyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmApXG4gICAgfVxuICAgIHN1cGVyKGZpbGVCaXRzLCBvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zID09PSBudWxsKSBvcHRpb25zID0ge307XG5cbiAgICAvLyBTaW11bGF0ZSBXZWJJREwgdHlwZSBjYXN0aW5nIGZvciBOYU4gdmFsdWUgaW4gbGFzdE1vZGlmaWVkIG9wdGlvbi5cbiAgICBjb25zdCBsYXN0TW9kaWZpZWQgPSBvcHRpb25zLmxhc3RNb2RpZmllZCA9PT0gdW5kZWZpbmVkID8gRGF0ZS5ub3coKSA6IE51bWJlcihvcHRpb25zLmxhc3RNb2RpZmllZCk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obGFzdE1vZGlmaWVkKSkge1xuICAgICAgdGhpcy4jbGFzdE1vZGlmaWVkID0gbGFzdE1vZGlmaWVkO1xuICAgIH1cblxuICAgIHRoaXMuI25hbWUgPSBTdHJpbmcoZmlsZU5hbWUpO1xuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLiNuYW1lXG4gIH1cblxuICBnZXQgbGFzdE1vZGlmaWVkICgpIHtcbiAgICByZXR1cm4gdGhpcy4jbGFzdE1vZGlmaWVkXG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10gKCkge1xuICAgIHJldHVybiAnRmlsZSdcbiAgfVxuXG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSAob2JqZWN0KSB7XG4gICAgcmV0dXJuICEhb2JqZWN0ICYmIG9iamVjdCBpbnN0YW5jZW9mIF9CbG9iJDEgJiZcbiAgICAgIC9eKEZpbGUpJC8udGVzdChvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSlcbiAgfVxufTtcblxuLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpcy5GaWxlfSAqLy8vIEB0cy1pZ25vcmVcbmNvbnN0IEZpbGUgPSBfRmlsZTtcbmNvbnN0IEZpbGUkMSA9IEZpbGU7XG5cbi8qISBmb3JtZGF0YS1wb2x5ZmlsbC4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cblxudmFyIHt0b1N0cmluZ1RhZzp0LGl0ZXJhdG9yOmksaGFzSW5zdGFuY2U6aH09U3ltYm9sLFxucj1NYXRoLnJhbmRvbSxcbm09J2FwcGVuZCxzZXQsZ2V0LGdldEFsbCxkZWxldGUsa2V5cyx2YWx1ZXMsZW50cmllcyxmb3JFYWNoLGNvbnN0cnVjdG9yJy5zcGxpdCgnLCcpLFxuZj0oYSxiLGMpPT4oYSs9JycsL14oQmxvYnxGaWxlKSQvLnRlc3QoYiAmJiBiW3RdKT9bKGM9YyE9PXZvaWQgMD9jKycnOmJbdF09PSdGaWxlJz9iLm5hbWU6J2Jsb2InLGEpLGIubmFtZSE9PWN8fGJbdF09PSdibG9iJz9uZXcgRmlsZSQxKFtiXSxjLGIpOmJdOlthLGIrJyddKSxcbmU9KGMsZik9PihmP2M6Yy5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCdcXHJcXG4nKSkucmVwbGFjZSgvXFxuL2csJyUwQScpLnJlcGxhY2UoL1xcci9nLCclMEQnKS5yZXBsYWNlKC9cIi9nLCclMjInKSxcbng9KG4sIGEsIGUpPT57aWYoYS5sZW5ndGg8ZSl7dGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJyR7bn0nIG9uICdGb3JtRGF0YSc6ICR7ZX0gYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2EubGVuZ3RofSBwcmVzZW50LmApfX07XG5cbi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXMuRm9ybURhdGF9ICovXG5jb25zdCBGb3JtRGF0YSA9IGNsYXNzIEZvcm1EYXRhIHtcbiNkPVtdO1xuY29uc3RydWN0b3IoLi4uYSl7aWYoYS5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGNvbnN0cnVjdCAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnSFRNTEZvcm1FbGVtZW50Jy5gKX1cbmdldCBbdF0oKSB7cmV0dXJuICdGb3JtRGF0YSd9XG5baV0oKXtyZXR1cm4gdGhpcy5lbnRyaWVzKCl9XG5zdGF0aWMgW2hdKG8pIHtyZXR1cm4gbyYmdHlwZW9mIG89PT0nb2JqZWN0JyYmb1t0XT09PSdGb3JtRGF0YScmJiFtLnNvbWUobT0+dHlwZW9mIG9bbV0hPSdmdW5jdGlvbicpfVxuYXBwZW5kKC4uLmEpe3goJ2FwcGVuZCcsYXJndW1lbnRzLDIpO3RoaXMuI2QucHVzaChmKC4uLmEpKTt9XG5kZWxldGUoYSl7eCgnZGVsZXRlJyxhcmd1bWVudHMsMSk7YSs9Jyc7dGhpcy4jZD10aGlzLiNkLmZpbHRlcigoW2JdKT0+YiE9PWEpO31cbmdldChhKXt4KCdnZXQnLGFyZ3VtZW50cywxKTthKz0nJztmb3IodmFyIGI9dGhpcy4jZCxsPWIubGVuZ3RoLGM9MDtjPGw7YysrKWlmKGJbY11bMF09PT1hKXJldHVybiBiW2NdWzFdO3JldHVybiBudWxsfVxuZ2V0QWxsKGEsYil7eCgnZ2V0QWxsJyxhcmd1bWVudHMsMSk7Yj1bXTthKz0nJzt0aGlzLiNkLmZvckVhY2goYz0+Y1swXT09PWEmJmIucHVzaChjWzFdKSk7cmV0dXJuIGJ9XG5oYXMoYSl7eCgnaGFzJyxhcmd1bWVudHMsMSk7YSs9Jyc7cmV0dXJuIHRoaXMuI2Quc29tZShiPT5iWzBdPT09YSl9XG5mb3JFYWNoKGEsYil7eCgnZm9yRWFjaCcsYXJndW1lbnRzLDEpO2Zvcih2YXIgW2MsZF1vZiB0aGlzKWEuY2FsbChiLGQsYyx0aGlzKTt9XG5zZXQoLi4uYSl7eCgnc2V0Jyxhcmd1bWVudHMsMik7dmFyIGI9W10sYz0hMDthPWYoLi4uYSk7dGhpcy4jZC5mb3JFYWNoKGQ9PntkWzBdPT09YVswXT9jJiYoYz0hYi5wdXNoKGEpKTpiLnB1c2goZCk7fSk7YyYmYi5wdXNoKGEpO3RoaXMuI2Q9Yjt9XG4qZW50cmllcygpe3lpZWxkKnRoaXMuI2Q7fVxuKmtleXMoKXtmb3IodmFyW2Fdb2YgdGhpcyl5aWVsZCBhO31cbip2YWx1ZXMoKXtmb3IodmFyWyxhXW9mIHRoaXMpeWllbGQgYTt9fTtcblxuLyoqIEBwYXJhbSB7Rm9ybURhdGF9IEYgKi9cbmZ1bmN0aW9uIGZvcm1EYXRhVG9CbG9iIChGLEI9X0Jsb2IkMSl7XG52YXIgYj1gJHtyKCl9JHtyKCl9YC5yZXBsYWNlKC9cXC4vZywgJycpLnNsaWNlKC0yOCkucGFkU3RhcnQoMzIsICctJyksYz1bXSxwPWAtLSR7Yn1cXHJcXG5Db250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCJgO1xuRi5mb3JFYWNoKCh2LG4pPT50eXBlb2Ygdj09J3N0cmluZydcbj9jLnB1c2gocCtlKG4pK2BcIlxcclxcblxcclxcbiR7di5yZXBsYWNlKC9cXHIoPyFcXG4pfCg/PCFcXHIpXFxuL2csICdcXHJcXG4nKX1cXHJcXG5gKVxuOmMucHVzaChwK2UobikrYFwiOyBmaWxlbmFtZT1cIiR7ZSh2Lm5hbWUsIDEpfVwiXFxyXFxuQ29udGVudC1UeXBlOiAke3YudHlwZXx8XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn1cXHJcXG5cXHJcXG5gLCB2LCAnXFxyXFxuJykpO1xuYy5wdXNoKGAtLSR7Yn0tLWApO1xucmV0dXJuIG5ldyBCKGMse3R5cGU6XCJtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT1cIitifSl9XG5cbmNsYXNzIEZldGNoQmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCB0eXBlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0Ly8gSGlkZSBjdXN0b20gZXJyb3IgaW1wbGVtZW50YXRpb24gZGV0YWlscyBmcm9tIGVuZC11c2Vyc1xuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0fVxuXG5cdGdldCBuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0fVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHt7IGFkZHJlc3M/OiBzdHJpbmcsIGNvZGU6IHN0cmluZywgZGVzdD86IHN0cmluZywgZXJybm86IG51bWJlciwgaW5mbz86IG9iamVjdCwgbWVzc2FnZTogc3RyaW5nLCBwYXRoPzogc3RyaW5nLCBwb3J0PzogbnVtYmVyLCBzeXNjYWxsOiBzdHJpbmd9fSBTeXN0ZW1FcnJvclxuKi9cblxuLyoqXG4gKiBGZXRjaEVycm9yIGludGVyZmFjZSBmb3Igb3BlcmF0aW9uYWwgZXJyb3JzXG4gKi9cbmNsYXNzIEZldGNoRXJyb3IgZXh0ZW5kcyBGZXRjaEJhc2VFcnJvciB7XG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IG1lc3NhZ2UgLSAgICAgIEVycm9yIG1lc3NhZ2UgZm9yIGh1bWFuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gW3R5cGVdIC0gICAgICAgIEVycm9yIHR5cGUgZm9yIG1hY2hpbmVcblx0ICogQHBhcmFtICB7U3lzdGVtRXJyb3J9IFtzeXN0ZW1FcnJvcl0gLSBGb3IgTm9kZS5qcyBzeXN0ZW0gZXJyb3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHR5cGUsIHN5c3RlbUVycm9yKSB7XG5cdFx0c3VwZXIobWVzc2FnZSwgdHlwZSk7XG5cdFx0Ly8gV2hlbiBlcnIudHlwZSBpcyBgc3lzdGVtYCwgZXJyLmVycm9yZWRTeXNDYWxsIGNvbnRhaW5zIHN5c3RlbSBlcnJvciBhbmQgZXJyLmNvZGUgY29udGFpbnMgc3lzdGVtIGVycm9yIGNvZGVcblx0XHRpZiAoc3lzdGVtRXJyb3IpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cblx0XHRcdHRoaXMuY29kZSA9IHRoaXMuZXJybm8gPSBzeXN0ZW1FcnJvci5jb2RlO1xuXHRcdFx0dGhpcy5lcnJvcmVkU3lzQ2FsbCA9IHN5c3RlbUVycm9yLnN5c2NhbGw7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogSXMuanNcbiAqXG4gKiBPYmplY3QgdHlwZSBjaGVja3MuXG4gKi9cblxuY29uc3QgTkFNRSA9IFN5bWJvbC50b1N0cmluZ1RhZztcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvMjk2I2lzc3VlY29tbWVudC0zMDc1OTgxNDNcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrIGZvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNVUkxTZWFyY2hQYXJhbWV0ZXJzID0gb2JqZWN0ID0+IHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiBvYmplY3QuYXBwZW5kID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5kZWxldGUgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmdldCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBvYmplY3QuZ2V0QWxsID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5oYXMgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnNldCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBvYmplY3Quc29ydCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdG9iamVjdFtOQU1FXSA9PT0gJ1VSTFNlYXJjaFBhcmFtcydcblx0KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamVjdGAgaXMgYSBXM0MgYEJsb2JgIG9iamVjdCAod2hpY2ggYEZpbGVgIGluaGVyaXRzIGZyb20pXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBjaGVjayBmb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzQmxvYiA9IG9iamVjdCA9PiB7XG5cdHJldHVybiAoXG5cdFx0b2JqZWN0ICYmXG5cdFx0dHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC50eXBlID09PSAnc3RyaW5nJyAmJlxuXHRcdHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdC9eKEJsb2J8RmlsZSkkLy50ZXN0KG9iamVjdFtOQU1FXSlcblx0KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gaW5zdGFuY2Ugb2YgQWJvcnRTaWduYWwuXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBjaGVjayBmb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzQWJvcnRTaWduYWwgPSBvYmplY3QgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIChcblx0XHRcdG9iamVjdFtOQU1FXSA9PT0gJ0Fib3J0U2lnbmFsJyB8fFxuXHRcdFx0b2JqZWN0W05BTUVdID09PSAnRXZlbnRUYXJnZXQnXG5cdFx0KVxuXHQpO1xufTtcblxuLyoqXG4gKiBpc0RvbWFpbk9yU3ViZG9tYWluIHJlcG9ydHMgd2hldGhlciBzdWIgaXMgYSBzdWJkb21haW4gKG9yIGV4YWN0IG1hdGNoKSBvZlxuICogdGhlIHBhcmVudCBkb21haW4uXG4gKlxuICogQm90aCBkb21haW5zIG11c3QgYWxyZWFkeSBiZSBpbiBjYW5vbmljYWwgZm9ybS5cbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gb3JpZ2luYWxcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gZGVzdGluYXRpb25cbiAqL1xuY29uc3QgaXNEb21haW5PclN1YmRvbWFpbiA9IChkZXN0aW5hdGlvbiwgb3JpZ2luYWwpID0+IHtcblx0Y29uc3Qgb3JpZyA9IG5ldyBVUkwob3JpZ2luYWwpLmhvc3RuYW1lO1xuXHRjb25zdCBkZXN0ID0gbmV3IFVSTChkZXN0aW5hdGlvbikuaG9zdG5hbWU7XG5cblx0cmV0dXJuIG9yaWcgPT09IGRlc3QgfHwgb3JpZy5lbmRzV2l0aChgLiR7ZGVzdH1gKTtcbn07XG5cbi8qKlxuICogaXNTYW1lUHJvdG9jb2wgcmVwb3J0cyB3aGV0aGVyIHRoZSB0d28gcHJvdmlkZWQgVVJMcyB1c2UgdGhlIHNhbWUgcHJvdG9jb2wuXG4gKlxuICogQm90aCBkb21haW5zIG11c3QgYWxyZWFkeSBiZSBpbiBjYW5vbmljYWwgZm9ybS5cbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gb3JpZ2luYWxcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gZGVzdGluYXRpb25cbiAqL1xuY29uc3QgaXNTYW1lUHJvdG9jb2wgPSAoZGVzdGluYXRpb24sIG9yaWdpbmFsKSA9PiB7XG5cdGNvbnN0IG9yaWcgPSBuZXcgVVJMKG9yaWdpbmFsKS5wcm90b2NvbDtcblx0Y29uc3QgZGVzdCA9IG5ldyBVUkwoZGVzdGluYXRpb24pLnByb3RvY29sO1xuXG5cdHJldHVybiBvcmlnID09PSBkZXN0O1xufTtcblxuY29uc3QgcGlwZWxpbmUgPSBub2RlX3V0aWwucHJvbWlzaWZ5KFN0cmVhbS5waXBlbGluZSk7XG5jb25zdCBJTlRFUk5BTFMkMiA9IFN5bWJvbCgnQm9keSBpbnRlcm5hbHMnKTtcblxuLyoqXG4gKiBCb2R5IG1peGluXG4gKlxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keVxuICpcbiAqIEBwYXJhbSAgIFN0cmVhbSAgYm9keSAgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gICBPYmplY3QgIG9wdHMgIFJlc3BvbnNlIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuY2xhc3MgQm9keSB7XG5cdGNvbnN0cnVjdG9yKGJvZHksIHtcblx0XHRzaXplID0gMFxuXHR9ID0ge30pIHtcblx0XHRsZXQgYm91bmRhcnkgPSBudWxsO1xuXG5cdFx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHRcdC8vIEJvZHkgaXMgdW5kZWZpbmVkIG9yIG51bGxcblx0XHRcdGJvZHkgPSBudWxsO1xuXHRcdH0gZWxzZSBpZiAoaXNVUkxTZWFyY2hQYXJhbWV0ZXJzKGJvZHkpKSB7XG5cdFx0XHQvLyBCb2R5IGlzIGEgVVJMU2VhcmNoUGFyYW1zXG5cdFx0XHRib2R5ID0gbm9kZV9idWZmZXIuQnVmZmVyLmZyb20oYm9keS50b1N0cmluZygpKTtcblx0XHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkgOyBlbHNlIGlmIChub2RlX2J1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYm9keSkpIDsgZWxzZSBpZiAobm9kZV91dGlsLnR5cGVzLmlzQW55QXJyYXlCdWZmZXIoYm9keSkpIHtcblx0XHRcdC8vIEJvZHkgaXMgQXJyYXlCdWZmZXJcblx0XHRcdGJvZHkgPSBub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShib2R5KTtcblx0XHR9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBBcnJheUJ1ZmZlclZpZXdcblx0XHRcdGJvZHkgPSBub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShib2R5LmJ1ZmZlciwgYm9keS5ieXRlT2Zmc2V0LCBib2R5LmJ5dGVMZW5ndGgpO1xuXHRcdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkgOyBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRcdC8vIEJvZHkgaXMgRm9ybURhdGFcblx0XHRcdGJvZHkgPSBmb3JtRGF0YVRvQmxvYihib2R5KTtcblx0XHRcdGJvdW5kYXJ5ID0gYm9keS50eXBlLnNwbGl0KCc9JylbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIE5vbmUgb2YgdGhlIGFib3ZlXG5cdFx0XHQvLyBjb2VyY2UgdG8gc3RyaW5nIHRoZW4gYnVmZmVyXG5cdFx0XHRib2R5ID0gbm9kZV9idWZmZXIuQnVmZmVyLmZyb20oU3RyaW5nKGJvZHkpKTtcblx0XHR9XG5cblx0XHRsZXQgc3RyZWFtID0gYm9keTtcblxuXHRcdGlmIChub2RlX2J1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcblx0XHRcdHN0cmVhbSA9IFN0cmVhbS5SZWFkYWJsZS5mcm9tKGJvZHkpO1xuXHRcdH0gZWxzZSBpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0XHRzdHJlYW0gPSBTdHJlYW0uUmVhZGFibGUuZnJvbShib2R5LnN0cmVhbSgpKTtcblx0XHR9XG5cblx0XHR0aGlzW0lOVEVSTkFMUyQyXSA9IHtcblx0XHRcdGJvZHksXG5cdFx0XHRzdHJlYW0sXG5cdFx0XHRib3VuZGFyeSxcblx0XHRcdGRpc3R1cmJlZDogZmFsc2UsXG5cdFx0XHRlcnJvcjogbnVsbFxuXHRcdH07XG5cdFx0dGhpcy5zaXplID0gc2l6ZTtcblxuXHRcdGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG5cdFx0XHRib2R5Lm9uKCdlcnJvcicsIGVycm9yXyA9PiB7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gZXJyb3JfIGluc3RhbmNlb2YgRmV0Y2hCYXNlRXJyb3IgP1xuXHRcdFx0XHRcdGVycm9yXyA6XG5cdFx0XHRcdFx0bmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHt0aGlzLnVybH06ICR7ZXJyb3JfLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycm9yXyk7XG5cdFx0XHRcdHRoaXNbSU5URVJOQUxTJDJdLmVycm9yID0gZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRnZXQgYm9keSgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMl0uc3RyZWFtO1xuXHR9XG5cblx0Z2V0IGJvZHlVc2VkKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQyXS5kaXN0dXJiZWQ7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIEFycmF5QnVmZmVyXG5cdCAqXG5cdCAqIEByZXR1cm4gIFByb21pc2Vcblx0ICovXG5cdGFzeW5jIGFycmF5QnVmZmVyKCkge1xuXHRcdGNvbnN0IHtidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGh9ID0gYXdhaXQgY29uc3VtZUJvZHkodGhpcyk7XG5cdFx0cmV0dXJuIGJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG5cdH1cblxuXHRhc3luYyBmb3JtRGF0YSgpIHtcblx0XHRjb25zdCBjdCA9IHRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuXG5cdFx0aWYgKGN0LnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpKSB7XG5cdFx0XHRjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXHRcdFx0Y29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoYXdhaXQgdGhpcy50ZXh0KCkpO1xuXG5cdFx0XHRmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgcGFyYW1ldGVycykge1xuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm9ybURhdGE7XG5cdFx0fVxuXG5cdFx0Y29uc3Qge3RvRm9ybURhdGF9ID0gYXdhaXQgaW1wb3J0KCcuLi9jaHVua3MvbXVsdGlwYXJ0LXBhcnNlci5janMnKTtcblx0XHRyZXR1cm4gdG9Gb3JtRGF0YSh0aGlzLmJvZHksIGN0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gcmF3IHJlc3BvbnNlIGFzIEJsb2Jcblx0ICpcblx0ICogQHJldHVybiBQcm9taXNlXG5cdCAqL1xuXHRhc3luYyBibG9iKCkge1xuXHRcdGNvbnN0IGN0ID0gKHRoaXMuaGVhZGVycyAmJiB0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkgfHwgKHRoaXNbSU5URVJOQUxTJDJdLmJvZHkgJiYgdGhpc1tJTlRFUk5BTFMkMl0uYm9keS50eXBlKSB8fCAnJztcblx0XHRjb25zdCBidWYgPSBhd2FpdCB0aGlzLmFycmF5QnVmZmVyKCk7XG5cblx0XHRyZXR1cm4gbmV3IF9CbG9iJDEoW2J1Zl0sIHtcblx0XHRcdHR5cGU6IGN0XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIGpzb25cblx0ICpcblx0ICogQHJldHVybiAgUHJvbWlzZVxuXHQgKi9cblx0YXN5bmMganNvbigpIHtcblx0XHRjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy50ZXh0KCk7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIHRleHRcblx0ICpcblx0ICogQHJldHVybiAgUHJvbWlzZVxuXHQgKi9cblx0YXN5bmMgdGV4dCgpIHtcblx0XHRjb25zdCBidWZmZXIgPSBhd2FpdCBjb25zdW1lQm9keSh0aGlzKTtcblx0XHRyZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZlcik7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIGJ1ZmZlciAobm9uLXNwZWMgYXBpKVxuXHQgKlxuXHQgKiBAcmV0dXJuICBQcm9taXNlXG5cdCAqL1xuXHRidWZmZXIoKSB7XG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMpO1xuXHR9XG59XG5cbkJvZHkucHJvdG90eXBlLmJ1ZmZlciA9IG5vZGVfdXRpbC5kZXByZWNhdGUoQm9keS5wcm90b3R5cGUuYnVmZmVyLCAnUGxlYXNlIHVzZSBcXCdyZXNwb25zZS5hcnJheUJ1ZmZlcigpXFwnIGluc3RlYWQgb2YgXFwncmVzcG9uc2UuYnVmZmVyKClcXCcnLCAnbm9kZS1mZXRjaCNidWZmZXInKTtcblxuLy8gSW4gYnJvd3NlcnMsIGFsbCBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQm9keS5wcm90b3R5cGUsIHtcblx0Ym9keToge2VudW1lcmFibGU6IHRydWV9LFxuXHRib2R5VXNlZDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRhcnJheUJ1ZmZlcjoge2VudW1lcmFibGU6IHRydWV9LFxuXHRibG9iOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGpzb246IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0dGV4dDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRkYXRhOiB7Z2V0OiBub2RlX3V0aWwuZGVwcmVjYXRlKCgpID0+IHt9LFxuXHRcdCdkYXRhIGRvZXNuXFwndCBleGlzdCwgdXNlIGpzb24oKSwgdGV4dCgpLCBhcnJheUJ1ZmZlcigpLCBvciBib2R5IGluc3RlYWQnLFxuXHRcdCdodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMDAwIChyZXNwb25zZSknKX1cbn0pO1xuXG4vKipcbiAqIENvbnN1bWUgYW5kIGNvbnZlcnQgYW4gZW50aXJlIEJvZHkgdG8gYSBCdWZmZXIuXG4gKlxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LWNvbnN1bWUtYm9keVxuICpcbiAqIEByZXR1cm4gUHJvbWlzZVxuICovXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lQm9keShkYXRhKSB7XG5cdGlmIChkYXRhW0lOVEVSTkFMUyQyXS5kaXN0dXJiZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBib2R5IHVzZWQgYWxyZWFkeSBmb3I6ICR7ZGF0YS51cmx9YCk7XG5cdH1cblxuXHRkYXRhW0lOVEVSTkFMUyQyXS5kaXN0dXJiZWQgPSB0cnVlO1xuXG5cdGlmIChkYXRhW0lOVEVSTkFMUyQyXS5lcnJvcikge1xuXHRcdHRocm93IGRhdGFbSU5URVJOQUxTJDJdLmVycm9yO1xuXHR9XG5cblx0Y29uc3Qge2JvZHl9ID0gZGF0YTtcblxuXHQvLyBCb2R5IGlzIG51bGxcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gbm9kZV9idWZmZXIuQnVmZmVyLmFsbG9jKDApO1xuXHR9XG5cblx0LyogYzggaWdub3JlIG5leHQgMyAqL1xuXHRpZiAoIShib2R5IGluc3RhbmNlb2YgU3RyZWFtKSkge1xuXHRcdHJldHVybiBub2RlX2J1ZmZlci5CdWZmZXIuYWxsb2MoMCk7XG5cdH1cblxuXHQvLyBCb2R5IGlzIHN0cmVhbVxuXHQvLyBnZXQgcmVhZHkgdG8gYWN0dWFsbHkgY29uc3VtZSB0aGUgYm9keVxuXHRjb25zdCBhY2N1bSA9IFtdO1xuXHRsZXQgYWNjdW1CeXRlcyA9IDA7XG5cblx0dHJ5IHtcblx0XHRmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcblx0XHRcdGlmIChkYXRhLnNpemUgPiAwICYmIGFjY3VtQnl0ZXMgKyBjaHVuay5sZW5ndGggPiBkYXRhLnNpemUpIHtcblx0XHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgRmV0Y2hFcnJvcihgY29udGVudCBzaXplIGF0ICR7ZGF0YS51cmx9IG92ZXIgbGltaXQ6ICR7ZGF0YS5zaXplfWAsICdtYXgtc2l6ZScpO1xuXHRcdFx0XHRib2R5LmRlc3Ryb3koZXJyb3IpO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblxuXHRcdFx0YWNjdW1CeXRlcyArPSBjaHVuay5sZW5ndGg7XG5cdFx0XHRhY2N1bS5wdXNoKGNodW5rKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Y29uc3QgZXJyb3JfID0gZXJyb3IgaW5zdGFuY2VvZiBGZXRjaEJhc2VFcnJvciA/IGVycm9yIDogbmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtkYXRhLnVybH06ICR7ZXJyb3IubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyb3IpO1xuXHRcdHRocm93IGVycm9yXztcblx0fVxuXG5cdGlmIChib2R5LnJlYWRhYmxlRW5kZWQgPT09IHRydWUgfHwgYm9keS5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9PT0gdHJ1ZSkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoYWNjdW0uZXZlcnkoYyA9PiB0eXBlb2YgYyA9PT0gJ3N0cmluZycpKSB7XG5cdFx0XHRcdHJldHVybiBub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShhY2N1bS5qb2luKCcnKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBub2RlX2J1ZmZlci5CdWZmZXIuY29uY2F0KGFjY3VtLCBhY2N1bUJ5dGVzKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhyb3cgbmV3IEZldGNoRXJyb3IoYENvdWxkIG5vdCBjcmVhdGUgQnVmZmVyIGZyb20gcmVzcG9uc2UgYm9keSBmb3IgJHtkYXRhLnVybH06ICR7ZXJyb3IubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyb3IpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRmV0Y2hFcnJvcihgUHJlbWF0dXJlIGNsb3NlIG9mIHNlcnZlciByZXNwb25zZSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtkYXRhLnVybH1gKTtcblx0fVxufVxuXG4vKipcbiAqIENsb25lIGJvZHkgZ2l2ZW4gUmVzL1JlcSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAgIE1peGVkICAgaW5zdGFuY2UgICAgICAgUmVzcG9uc2Ugb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAgU3RyaW5nICBoaWdoV2F0ZXJNYXJrICBoaWdoV2F0ZXJNYXJrIGZvciBib3RoIFBhc3NUaHJvdWdoIGJvZHkgc3RyZWFtc1xuICogQHJldHVybiAgTWl4ZWRcbiAqL1xuY29uc3QgY2xvbmUgPSAoaW5zdGFuY2UsIGhpZ2hXYXRlck1hcmspID0+IHtcblx0bGV0IHAxO1xuXHRsZXQgcDI7XG5cdGxldCB7Ym9keX0gPSBpbnN0YW5jZVtJTlRFUk5BTFMkMl07XG5cblx0Ly8gRG9uJ3QgYWxsb3cgY2xvbmluZyBhIHVzZWQgYm9keVxuXHRpZiAoaW5zdGFuY2UuYm9keVVzZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjbG9uZSBib2R5IGFmdGVyIGl0IGlzIHVzZWQnKTtcblx0fVxuXG5cdC8vIENoZWNrIHRoYXQgYm9keSBpcyBhIHN0cmVhbSBhbmQgbm90IGZvcm0tZGF0YSBvYmplY3Rcblx0Ly8gbm90ZTogd2UgY2FuJ3QgY2xvbmUgdGhlIGZvcm0tZGF0YSBvYmplY3Qgd2l0aG91dCBoYXZpbmcgaXQgYXMgYSBkZXBlbmRlbmN5XG5cdGlmICgoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkgJiYgKHR5cGVvZiBib2R5LmdldEJvdW5kYXJ5ICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdC8vIFRlZSBpbnN0YW5jZSBib2R5XG5cdFx0cDEgPSBuZXcgU3RyZWFtLlBhc3NUaHJvdWdoKHtoaWdoV2F0ZXJNYXJrfSk7XG5cdFx0cDIgPSBuZXcgU3RyZWFtLlBhc3NUaHJvdWdoKHtoaWdoV2F0ZXJNYXJrfSk7XG5cdFx0Ym9keS5waXBlKHAxKTtcblx0XHRib2R5LnBpcGUocDIpO1xuXHRcdC8vIFNldCBpbnN0YW5jZSBib2R5IHRvIHRlZWQgYm9keSBhbmQgcmV0dXJuIHRoZSBvdGhlciB0ZWVkIGJvZHlcblx0XHRpbnN0YW5jZVtJTlRFUk5BTFMkMl0uc3RyZWFtID0gcDE7XG5cdFx0Ym9keSA9IHAyO1xuXHR9XG5cblx0cmV0dXJuIGJvZHk7XG59O1xuXG5jb25zdCBnZXROb25TcGVjRm9ybURhdGFCb3VuZGFyeSA9IG5vZGVfdXRpbC5kZXByZWNhdGUoXG5cdGJvZHkgPT4gYm9keS5nZXRCb3VuZGFyeSgpLFxuXHQnZm9ybS1kYXRhIGRvZXNuXFwndCBmb2xsb3cgdGhlIHNwZWMgYW5kIHJlcXVpcmVzIHNwZWNpYWwgdHJlYXRtZW50LiBVc2UgYWx0ZXJuYXRpdmUgcGFja2FnZScsXG5cdCdodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMTY3J1xuKTtcblxuLyoqXG4gKiBQZXJmb3JtcyB0aGUgb3BlcmF0aW9uIFwiZXh0cmFjdCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb20gfG9iamVjdHxcIiBhc1xuICogc3BlY2lmaWVkIGluIHRoZSBzcGVjaWZpY2F0aW9uOlxuICogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGluc3RhbmNlLmJvZHkgaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge2FueX0gYm9keSBBbnkgb3B0aW9ucy5ib2R5IGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cbiAqL1xuY29uc3QgZXh0cmFjdENvbnRlbnRUeXBlID0gKGJvZHksIHJlcXVlc3QpID0+IHtcblx0Ly8gQm9keSBpcyBudWxsIG9yIHVuZGVmaW5lZFxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBzdHJpbmdcblx0aWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jztcblx0fVxuXG5cdC8vIEJvZHkgaXMgYSBVUkxTZWFyY2hQYXJhbXNcblx0aWYgKGlzVVJMU2VhcmNoUGFyYW1ldGVycyhib2R5KSkge1xuXHRcdHJldHVybiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBibG9iXG5cdGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHRyZXR1cm4gYm9keS50eXBlIHx8IG51bGw7XG5cdH1cblxuXHQvLyBCb2R5IGlzIGEgQnVmZmVyIChCdWZmZXIsIEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldylcblx0aWYgKG5vZGVfYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihib2R5KSB8fCBub2RlX3V0aWwudHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihib2R5KSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmIChib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRyZXR1cm4gYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PSR7cmVxdWVzdFtJTlRFUk5BTFMkMl0uYm91bmRhcnl9YDtcblx0fVxuXG5cdC8vIERldGVjdCBmb3JtIGRhdGEgaW5wdXQgZnJvbSBmb3JtLWRhdGEgbW9kdWxlXG5cdGlmIChib2R5ICYmIHR5cGVvZiBib2R5LmdldEJvdW5kYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGBtdWx0aXBhcnQvZm9ybS1kYXRhO2JvdW5kYXJ5PSR7Z2V0Tm9uU3BlY0Zvcm1EYXRhQm91bmRhcnkoYm9keSl9YDtcblx0fVxuXG5cdC8vIEJvZHkgaXMgc3RyZWFtIC0gY2FuJ3QgcmVhbGx5IGRvIG11Y2ggYWJvdXQgdGhpc1xuXHRpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gQm9keSBjb25zdHJ1Y3RvciBkZWZhdWx0cyBvdGhlciB0aGluZ3MgdG8gc3RyaW5nXG5cdHJldHVybiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jztcbn07XG5cbi8qKlxuICogVGhlIEZldGNoIFN0YW5kYXJkIHRyZWF0cyB0aGlzIGFzIGlmIFwidG90YWwgYnl0ZXNcIiBpcyBhIHByb3BlcnR5IG9uIHRoZSBib2R5LlxuICogRm9yIHVzLCB3ZSBoYXZlIHRvIGV4cGxpY2l0bHkgZ2V0IGl0IHdpdGggYSBmdW5jdGlvbi5cbiAqXG4gKiByZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktdG90YWwtYnl0ZXNcbiAqXG4gKiBAcGFyYW0ge2FueX0gb2JqLmJvZHkgQm9keSBvYmplY3QgZnJvbSB0aGUgQm9keSBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtudW1iZXIgfCBudWxsfVxuICovXG5jb25zdCBnZXRUb3RhbEJ5dGVzID0gcmVxdWVzdCA9PiB7XG5cdGNvbnN0IHtib2R5fSA9IHJlcXVlc3RbSU5URVJOQUxTJDJdO1xuXG5cdC8vIEJvZHkgaXMgbnVsbCBvciB1bmRlZmluZWRcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdC8vIEJvZHkgaXMgQmxvYlxuXHRpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0cmV0dXJuIGJvZHkuc2l6ZTtcblx0fVxuXG5cdC8vIEJvZHkgaXMgQnVmZmVyXG5cdGlmIChub2RlX2J1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcblx0XHRyZXR1cm4gYm9keS5sZW5ndGg7XG5cdH1cblxuXHQvLyBEZXRlY3QgZm9ybSBkYXRhIGlucHV0IGZyb20gZm9ybS1kYXRhIG1vZHVsZVxuXHRpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5nZXRMZW5ndGhTeW5jID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGJvZHkuaGFzS25vd25MZW5ndGggJiYgYm9keS5oYXNLbm93bkxlbmd0aCgpID8gYm9keS5nZXRMZW5ndGhTeW5jKCkgOiBudWxsO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBzdHJlYW1cblx0cmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgQm9keSB0byBhIE5vZGUuanMgV3JpdGFibGVTdHJlYW0gKGUuZy4gaHR0cC5SZXF1ZXN0KSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJlYW0uV3JpdGFibGV9IGRlc3QgVGhlIHN0cmVhbSB0byB3cml0ZSB0by5cbiAqIEBwYXJhbSBvYmouYm9keSBCb2R5IG9iamVjdCBmcm9tIHRoZSBCb2R5IGluc3RhbmNlLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmNvbnN0IHdyaXRlVG9TdHJlYW0gPSBhc3luYyAoZGVzdCwge2JvZHl9KSA9PiB7XG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0Ly8gQm9keSBpcyBudWxsXG5cdFx0ZGVzdC5lbmQoKTtcblx0fSBlbHNlIHtcblx0XHQvLyBCb2R5IGlzIHN0cmVhbVxuXHRcdGF3YWl0IHBpcGVsaW5lKGJvZHksIGRlc3QpO1xuXHR9XG59O1xuXG4vKipcbiAqIEhlYWRlcnMuanNcbiAqXG4gKiBIZWFkZXJzIGNsYXNzIG9mZmVycyBjb252ZW5pZW50IGhlbHBlcnNcbiAqL1xuXG4vKiBjOCBpZ25vcmUgbmV4dCA5ICovXG5jb25zdCB2YWxpZGF0ZUhlYWRlck5hbWUgPSB0eXBlb2YgaHR0cC52YWxpZGF0ZUhlYWRlck5hbWUgPT09ICdmdW5jdGlvbicgP1xuXHRodHRwLnZhbGlkYXRlSGVhZGVyTmFtZSA6XG5cdG5hbWUgPT4ge1xuXHRcdGlmICghL15bXFxeYFxcLVxcdyEjJCUmJyorLnx+XSskLy50ZXN0KG5hbWUpKSB7XG5cdFx0XHRjb25zdCBlcnJvciA9IG5ldyBUeXBlRXJyb3IoYEhlYWRlciBuYW1lIG11c3QgYmUgYSB2YWxpZCBIVFRQIHRva2VuIFske25hbWV9XWApO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yLCAnY29kZScsIHt2YWx1ZTogJ0VSUl9JTlZBTElEX0hUVFBfVE9LRU4nfSk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH07XG5cbi8qIGM4IGlnbm9yZSBuZXh0IDkgKi9cbmNvbnN0IHZhbGlkYXRlSGVhZGVyVmFsdWUgPSB0eXBlb2YgaHR0cC52YWxpZGF0ZUhlYWRlclZhbHVlID09PSAnZnVuY3Rpb24nID9cblx0aHR0cC52YWxpZGF0ZUhlYWRlclZhbHVlIDpcblx0KG5hbWUsIHZhbHVlKSA9PiB7XG5cdFx0aWYgKC9bXlxcdFxcdTAwMjAtXFx1MDA3RVxcdTAwODAtXFx1MDBGRl0vLnRlc3QodmFsdWUpKSB7XG5cdFx0XHRjb25zdCBlcnJvciA9IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBjb250ZW50IFtcIiR7bmFtZX1cIl1gKTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ2NvZGUnLCB7dmFsdWU6ICdFUlJfSU5WQUxJRF9DSEFSJ30pO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtIZWFkZXJzIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IEl0ZXJhYmxlPHJlYWRvbmx5IFtzdHJpbmcsIHN0cmluZ10+IHwgSXRlcmFibGU8SXRlcmFibGU8c3RyaW5nPj59IEhlYWRlcnNJbml0XG4gKi9cblxuLyoqXG4gKiBUaGlzIEZldGNoIEFQSSBpbnRlcmZhY2UgYWxsb3dzIHlvdSB0byBwZXJmb3JtIHZhcmlvdXMgYWN0aW9ucyBvbiBIVFRQIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGhlYWRlcnMuXG4gKiBUaGVzZSBhY3Rpb25zIGluY2x1ZGUgcmV0cmlldmluZywgc2V0dGluZywgYWRkaW5nIHRvLCBhbmQgcmVtb3ZpbmcuXG4gKiBBIEhlYWRlcnMgb2JqZWN0IGhhcyBhbiBhc3NvY2lhdGVkIGhlYWRlciBsaXN0LCB3aGljaCBpcyBpbml0aWFsbHkgZW1wdHkgYW5kIGNvbnNpc3RzIG9mIHplcm8gb3IgbW9yZSBuYW1lIGFuZCB2YWx1ZSBwYWlycy5cbiAqIFlvdSBjYW4gYWRkIHRvIHRoaXMgdXNpbmcgbWV0aG9kcyBsaWtlIGFwcGVuZCgpIChzZWUgRXhhbXBsZXMuKVxuICogSW4gYWxsIG1ldGhvZHMgb2YgdGhpcyBpbnRlcmZhY2UsIGhlYWRlciBuYW1lcyBhcmUgbWF0Y2hlZCBieSBjYXNlLWluc2Vuc2l0aXZlIGJ5dGUgc2VxdWVuY2UuXG4gKlxuICovXG5jbGFzcyBIZWFkZXJzIGV4dGVuZHMgVVJMU2VhcmNoUGFyYW1zIHtcblx0LyoqXG5cdCAqIEhlYWRlcnMgY2xhc3Ncblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7SGVhZGVyc0luaXR9IFtpbml0XSAtIFJlc3BvbnNlIGhlYWRlcnNcblx0ICovXG5cdGNvbnN0cnVjdG9yKGluaXQpIHtcblx0XHQvLyBWYWxpZGF0ZSBhbmQgbm9ybWFsaXplIGluaXQgb2JqZWN0IGluIFtuYW1lLCB2YWx1ZShzKV1bXVxuXHRcdC8qKiBAdHlwZSB7c3RyaW5nW11bXX0gKi9cblx0XHRsZXQgcmVzdWx0ID0gW107XG5cdFx0aWYgKGluaXQgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG5cdFx0XHRjb25zdCByYXcgPSBpbml0LnJhdygpO1xuXHRcdFx0Zm9yIChjb25zdCBbbmFtZSwgdmFsdWVzXSBvZiBPYmplY3QuZW50cmllcyhyYXcpKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKC4uLnZhbHVlcy5tYXAodmFsdWUgPT4gW25hbWUsIHZhbHVlXSkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoaW5pdCA9PSBudWxsKSA7IGVsc2UgaWYgKHR5cGVvZiBpbml0ID09PSAnb2JqZWN0JyAmJiAhbm9kZV91dGlsLnR5cGVzLmlzQm94ZWRQcmltaXRpdmUoaW5pdCkpIHtcblx0XHRcdGNvbnN0IG1ldGhvZCA9IGluaXRbU3ltYm9sLml0ZXJhdG9yXTtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRcdGlmIChtZXRob2QgPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBSZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz5cblx0XHRcdFx0cmVzdWx0LnB1c2goLi4uT2JqZWN0LmVudHJpZXMoaW5pdCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBtZXRob2QgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdIZWFkZXIgcGFpcnMgbXVzdCBiZSBpdGVyYWJsZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+XG5cdFx0XHRcdC8vIE5vdGU6IHBlciBzcGVjIHdlIGhhdmUgdG8gZmlyc3QgZXhoYXVzdCB0aGUgbGlzdHMgdGhlbiBwcm9jZXNzIHRoZW1cblx0XHRcdFx0cmVzdWx0ID0gWy4uLmluaXRdXG5cdFx0XHRcdFx0Lm1hcChwYWlyID0+IHtcblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0dHlwZW9mIHBhaXIgIT09ICdvYmplY3QnIHx8IG5vZGVfdXRpbC50eXBlcy5pc0JveGVkUHJpbWl0aXZlKHBhaXIpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBoZWFkZXIgcGFpciBtdXN0IGJlIGFuIGl0ZXJhYmxlIG9iamVjdCcpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gWy4uLnBhaXJdO1xuXHRcdFx0XHRcdH0pLm1hcChwYWlyID0+IHtcblx0XHRcdFx0XHRcdGlmIChwYWlyLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYSBuYW1lL3ZhbHVlIHR1cGxlJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBbLi4ucGFpcl07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnSGVhZGVyc1xcJzogVGhlIHByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvZiB0eXBlIFxcJyhzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4gb3IgcmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+KScpO1xuXHRcdH1cblxuXHRcdC8vIFZhbGlkYXRlIGFuZCBsb3dlcmNhc2Vcblx0XHRyZXN1bHQgPVxuXHRcdFx0cmVzdWx0Lmxlbmd0aCA+IDAgP1xuXHRcdFx0XHRyZXN1bHQubWFwKChbbmFtZSwgdmFsdWVdKSA9PiB7XG5cdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuXHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyVmFsdWUobmFtZSwgU3RyaW5nKHZhbHVlKSk7XG5cdFx0XHRcdFx0cmV0dXJuIFtTdHJpbmcobmFtZSkudG9Mb3dlckNhc2UoKSwgU3RyaW5nKHZhbHVlKV07XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXG5cdFx0c3VwZXIocmVzdWx0KTtcblxuXHRcdC8vIFJldHVybmluZyBhIFByb3h5IHRoYXQgd2lsbCBsb3dlcmNhc2Uga2V5IG5hbWVzLCB2YWxpZGF0ZSBwYXJhbWV0ZXJzIGFuZCBzb3J0IGtleXNcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG5cdFx0cmV0dXJuIG5ldyBQcm94eSh0aGlzLCB7XG5cdFx0XHRnZXQodGFyZ2V0LCBwLCByZWNlaXZlcikge1xuXHRcdFx0XHRzd2l0Y2ggKHApIHtcblx0XHRcdFx0XHRjYXNlICdhcHBlbmQnOlxuXHRcdFx0XHRcdGNhc2UgJ3NldCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gKG5hbWUsIHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcblx0XHRcdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJWYWx1ZShuYW1lLCBTdHJpbmcodmFsdWUpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbcF0uY2FsbChcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXQsXG5cdFx0XHRcdFx0XHRcdFx0U3RyaW5nKG5hbWUpLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHRcdFx0U3RyaW5nKHZhbHVlKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGNhc2UgJ2RlbGV0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAnaGFzJzpcblx0XHRcdFx0XHRjYXNlICdnZXRBbGwnOlxuXHRcdFx0XHRcdFx0cmV0dXJuIG5hbWUgPT4ge1xuXHRcdFx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlW3BdLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRcdFN0cmluZyhuYW1lKS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Y2FzZSAna2V5cyc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXQuc29ydCgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFNldChVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmtleXMuY2FsbCh0YXJnZXQpKS5rZXlzKCk7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHAsIHJlY2VpdmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdC8qIGM4IGlnbm9yZSBuZXh0ICovXG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcyk7XG5cdH1cblxuXHRnZXQobmFtZSkge1xuXHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMuZ2V0QWxsKG5hbWUpO1xuXHRcdGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRsZXQgdmFsdWUgPSB2YWx1ZXMuam9pbignLCAnKTtcblx0XHRpZiAoL15jb250ZW50LWVuY29kaW5nJC9pLnRlc3QobmFtZSkpIHtcblx0XHRcdHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnID0gdW5kZWZpbmVkKSB7XG5cdFx0Zm9yIChjb25zdCBuYW1lIG9mIHRoaXMua2V5cygpKSB7XG5cdFx0XHRSZWZsZWN0LmFwcGx5KGNhbGxiYWNrLCB0aGlzQXJnLCBbdGhpcy5nZXQobmFtZSksIG5hbWUsIHRoaXNdKTtcblx0XHR9XG5cdH1cblxuXHQqIHZhbHVlcygpIHtcblx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5rZXlzKCkpIHtcblx0XHRcdHlpZWxkIHRoaXMuZ2V0KG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7KCkgPT4gSXRlcmFibGVJdGVyYXRvcjxbc3RyaW5nLCBzdHJpbmddPn1cblx0ICovXG5cdCogZW50cmllcygpIHtcblx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5rZXlzKCkpIHtcblx0XHRcdHlpZWxkIFtuYW1lLCB0aGlzLmdldChuYW1lKV07XG5cdFx0fVxuXHR9XG5cblx0W1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZW50cmllcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE5vZGUtZmV0Y2ggbm9uLXNwZWMgbWV0aG9kXG5cdCAqIHJldHVybmluZyBhbGwgaGVhZGVycyBhbmQgdGhlaXIgdmFsdWVzIGFzIGFycmF5XG5cdCAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT59XG5cdCAqL1xuXHRyYXcoKSB7XG5cdFx0cmV0dXJuIFsuLi50aGlzLmtleXMoKV0ucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuXHRcdFx0cmVzdWx0W2tleV0gPSB0aGlzLmdldEFsbChrZXkpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LCB7fSk7XG5cdH1cblxuXHQvKipcblx0ICogRm9yIGJldHRlciBjb25zb2xlLmxvZyhoZWFkZXJzKSBhbmQgYWxzbyB0byBjb252ZXJ0IEhlYWRlcnMgaW50byBOb2RlLmpzIFJlcXVlc3QgY29tcGF0aWJsZSBmb3JtYXRcblx0ICovXG5cdFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcblx0XHRyZXR1cm4gWy4uLnRoaXMua2V5cygpXS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG5cdFx0XHRjb25zdCB2YWx1ZXMgPSB0aGlzLmdldEFsbChrZXkpO1xuXHRcdFx0Ly8gSHR0cC5yZXF1ZXN0KCkgb25seSBzdXBwb3J0cyBzdHJpbmcgYXMgSG9zdCBoZWFkZXIuXG5cdFx0XHQvLyBUaGlzIGhhY2sgbWFrZXMgc3BlY2lmeWluZyBjdXN0b20gSG9zdCBoZWFkZXIgcG9zc2libGUuXG5cdFx0XHRpZiAoa2V5ID09PSAnaG9zdCcpIHtcblx0XHRcdFx0cmVzdWx0W2tleV0gPSB2YWx1ZXNbMF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRba2V5XSA9IHZhbHVlcy5sZW5ndGggPiAxID8gdmFsdWVzIDogdmFsdWVzWzBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sIHt9KTtcblx0fVxufVxuXG4vKipcbiAqIFJlLXNoYXBpbmcgb2JqZWN0IGZvciBXZWIgSURMIHRlc3RzXG4gKiBPbmx5IG5lZWQgdG8gZG8gaXQgZm9yIG92ZXJyaWRkZW4gbWV0aG9kc1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhcblx0SGVhZGVycy5wcm90b3R5cGUsXG5cdFsnZ2V0JywgJ2VudHJpZXMnLCAnZm9yRWFjaCcsICd2YWx1ZXMnXS5yZWR1Y2UoKHJlc3VsdCwgcHJvcGVydHkpID0+IHtcblx0XHRyZXN1bHRbcHJvcGVydHldID0ge2VudW1lcmFibGU6IHRydWV9O1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sIHt9KVxuKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBIZWFkZXJzIG9iamVjdCBmcm9tIGFuIGh0dHAuSW5jb21pbmdNZXNzYWdlLnJhd0hlYWRlcnMsIGlnbm9yaW5nIHRob3NlIHRoYXQgZG9cbiAqIG5vdCBjb25mb3JtIHRvIEhUVFAgZ3JhbW1hciBwcm9kdWN0aW9ucy5cbiAqIEBwYXJhbSB7aW1wb3J0KCdodHRwJykuSW5jb21pbmdNZXNzYWdlWydyYXdIZWFkZXJzJ119IGhlYWRlcnNcbiAqL1xuZnVuY3Rpb24gZnJvbVJhd0hlYWRlcnMoaGVhZGVycyA9IFtdKSB7XG5cdHJldHVybiBuZXcgSGVhZGVycyhcblx0XHRoZWFkZXJzXG5cdFx0XHQvLyBTcGxpdCBpbnRvIHBhaXJzXG5cdFx0XHQucmVkdWNlKChyZXN1bHQsIHZhbHVlLCBpbmRleCwgYXJyYXkpID0+IHtcblx0XHRcdFx0aWYgKGluZGV4ICUgMiA9PT0gMCkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGFycmF5LnNsaWNlKGluZGV4LCBpbmRleCArIDIpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9LCBbXSlcblx0XHRcdC5maWx0ZXIoKFtuYW1lLCB2YWx1ZV0pID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG5cdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJWYWx1ZShuYW1lLCBTdHJpbmcodmFsdWUpKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXG5cdCk7XG59XG5cbmNvbnN0IHJlZGlyZWN0U3RhdHVzID0gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcblxuLyoqXG4gKiBSZWRpcmVjdCBjb2RlIG1hdGNoaW5nXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGUgLSBTdGF0dXMgY29kZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNSZWRpcmVjdCA9IGNvZGUgPT4ge1xuXHRyZXR1cm4gcmVkaXJlY3RTdGF0dXMuaGFzKGNvZGUpO1xufTtcblxuLyoqXG4gKiBSZXNwb25zZS5qc1xuICpcbiAqIFJlc3BvbnNlIGNsYXNzIHByb3ZpZGVzIGNvbnRlbnQgZGVjb2RpbmdcbiAqL1xuXG5jb25zdCBJTlRFUk5BTFMkMSA9IFN5bWJvbCgnUmVzcG9uc2UgaW50ZXJuYWxzJyk7XG5cbi8qKlxuICogUmVzcG9uc2UgY2xhc3NcbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jbGFzc1xuICpcbiAqIEBwYXJhbSAgIFN0cmVhbSAgYm9keSAgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gICBPYmplY3QgIG9wdHMgIFJlc3BvbnNlIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuY2xhc3MgUmVzcG9uc2UgZXh0ZW5kcyBCb2R5IHtcblx0Y29uc3RydWN0b3IoYm9keSA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKGJvZHksIG9wdGlvbnMpO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcSwgbm8tbmVnYXRlZC1jb25kaXRpb25cblx0XHRjb25zdCBzdGF0dXMgPSBvcHRpb25zLnN0YXR1cyAhPSBudWxsID8gb3B0aW9ucy5zdGF0dXMgOiAyMDA7XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmIChib2R5ICE9PSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKGJvZHksIHRoaXMpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpc1tJTlRFUk5BTFMkMV0gPSB7XG5cdFx0XHR0eXBlOiAnZGVmYXVsdCcsXG5cdFx0XHR1cmw6IG9wdGlvbnMudXJsLFxuXHRcdFx0c3RhdHVzLFxuXHRcdFx0c3RhdHVzVGV4dDogb3B0aW9ucy5zdGF0dXNUZXh0IHx8ICcnLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdGNvdW50ZXI6IG9wdGlvbnMuY291bnRlcixcblx0XHRcdGhpZ2hXYXRlck1hcms6IG9wdGlvbnMuaGlnaFdhdGVyTWFya1xuXHRcdH07XG5cdH1cblxuXHRnZXQgdHlwZSgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0udHlwZTtcblx0fVxuXG5cdGdldCB1cmwoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLnVybCB8fCAnJztcblx0fVxuXG5cdGdldCBzdGF0dXMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLnN0YXR1cztcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZW5pZW5jZSBwcm9wZXJ0eSByZXByZXNlbnRpbmcgaWYgdGhlIHJlcXVlc3QgZW5kZWQgbm9ybWFsbHlcblx0ICovXG5cdGdldCBvaygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzID49IDIwMCAmJiB0aGlzW0lOVEVSTkFMUyQxXS5zdGF0dXMgPCAzMDA7XG5cdH1cblxuXHRnZXQgcmVkaXJlY3RlZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uY291bnRlciA+IDA7XG5cdH1cblxuXHRnZXQgc3RhdHVzVGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzVGV4dDtcblx0fVxuXG5cdGdldCBoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5oZWFkZXJzO1xuXHR9XG5cblx0Z2V0IGhpZ2hXYXRlck1hcmsoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLmhpZ2hXYXRlck1hcms7XG5cdH1cblxuXHQvKipcblx0ICogQ2xvbmUgdGhpcyByZXNwb25zZVxuXHQgKlxuXHQgKiBAcmV0dXJuICBSZXNwb25zZVxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBSZXNwb25zZShjbG9uZSh0aGlzLCB0aGlzLmhpZ2hXYXRlck1hcmspLCB7XG5cdFx0XHR0eXBlOiB0aGlzLnR5cGUsXG5cdFx0XHR1cmw6IHRoaXMudXJsLFxuXHRcdFx0c3RhdHVzOiB0aGlzLnN0YXR1cyxcblx0XHRcdHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdG9rOiB0aGlzLm9rLFxuXHRcdFx0cmVkaXJlY3RlZDogdGhpcy5yZWRpcmVjdGVkLFxuXHRcdFx0c2l6ZTogdGhpcy5zaXplLFxuXHRcdFx0aGlnaFdhdGVyTWFyazogdGhpcy5oaWdoV2F0ZXJNYXJrXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICBUaGUgVVJMIHRoYXQgdGhlIG5ldyByZXNwb25zZSBpcyB0byBvcmlnaW5hdGUgZnJvbS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1cyBBbiBvcHRpb25hbCBzdGF0dXMgY29kZSBmb3IgdGhlIHJlc3BvbnNlIChlLmcuLCAzMDIuKVxuXHQgKiBAcmV0dXJucyB7UmVzcG9uc2V9ICAgIEEgUmVzcG9uc2Ugb2JqZWN0LlxuXHQgKi9cblx0c3RhdGljIHJlZGlyZWN0KHVybCwgc3RhdHVzID0gMzAyKSB7XG5cdFx0aWYgKCFpc1JlZGlyZWN0KHN0YXR1cykpIHtcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSBcInJlZGlyZWN0XCIgb24gXCJyZXNwb25zZVwiOiBJbnZhbGlkIHN0YXR1cyBjb2RlJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG5cdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdGxvY2F0aW9uOiBuZXcgVVJMKHVybCkudG9TdHJpbmcoKVxuXHRcdFx0fSxcblx0XHRcdHN0YXR1c1xuXHRcdH0pO1xuXHR9XG5cblx0c3RhdGljIGVycm9yKCkge1xuXHRcdGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG5cdFx0cmVzcG9uc2VbSU5URVJOQUxTJDFdLnR5cGUgPSAnZXJyb3InO1xuXHRcdHJldHVybiByZXNwb25zZTtcblx0fVxuXG5cdHN0YXRpYyBqc29uKGRhdGEgPSB1bmRlZmluZWQsIGluaXQgPSB7fSkge1xuXHRcdGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcblxuXHRcdGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgaXMgbm90IEpTT04gc2VyaWFsaXphYmxlJyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQgJiYgaW5pdC5oZWFkZXJzKTtcblxuXHRcdGlmICghaGVhZGVycy5oYXMoJ2NvbnRlbnQtdHlwZScpKSB7XG5cdFx0XHRoZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIHtcblx0XHRcdC4uLmluaXQsXG5cdFx0XHRoZWFkZXJzXG5cdFx0fSk7XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuICdSZXNwb25zZSc7XG5cdH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UucHJvdG90eXBlLCB7XG5cdHR5cGU6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0dXJsOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHN0YXR1czoge2VudW1lcmFibGU6IHRydWV9LFxuXHRvazoge2VudW1lcmFibGU6IHRydWV9LFxuXHRyZWRpcmVjdGVkOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHN0YXR1c1RleHQ6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0aGVhZGVyczoge2VudW1lcmFibGU6IHRydWV9LFxuXHRjbG9uZToge2VudW1lcmFibGU6IHRydWV9XG59KTtcblxuY29uc3QgZ2V0U2VhcmNoID0gcGFyc2VkVVJMID0+IHtcblx0aWYgKHBhcnNlZFVSTC5zZWFyY2gpIHtcblx0XHRyZXR1cm4gcGFyc2VkVVJMLnNlYXJjaDtcblx0fVxuXG5cdGNvbnN0IGxhc3RPZmZzZXQgPSBwYXJzZWRVUkwuaHJlZi5sZW5ndGggLSAxO1xuXHRjb25zdCBoYXNoID0gcGFyc2VkVVJMLmhhc2ggfHwgKHBhcnNlZFVSTC5ocmVmW2xhc3RPZmZzZXRdID09PSAnIycgPyAnIycgOiAnJyk7XG5cdHJldHVybiBwYXJzZWRVUkwuaHJlZltsYXN0T2Zmc2V0IC0gaGFzaC5sZW5ndGhdID09PSAnPycgPyAnPycgOiAnJztcbn07XG5cbi8qKlxuICogQGV4dGVybmFsIFVSTFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTHxVUkx9XG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIHV0aWxzL3JlZmVycmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3N0cmlwLXVybHxSZWZlcnJlciBQb2xpY3kgwqc4LjQuIFN0cmlwIHVybCBmb3IgdXNlIGFzIGEgcmVmZXJyZXJ9XG4gKiBAcGFyYW0ge3N0cmluZ30gVVJMXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcmlnaW5Pbmx5PWZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyKHVybCwgb3JpZ2luT25seSA9IGZhbHNlKSB7XG5cdC8vIDEuIElmIHVybCBpcyBudWxsLCByZXR1cm4gbm8gcmVmZXJyZXIuXG5cdGlmICh1cmwgPT0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXHR9XG5cblx0dXJsID0gbmV3IFVSTCh1cmwpO1xuXG5cdC8vIDIuIElmIHVybCdzIHNjaGVtZSBpcyBhIGxvY2FsIHNjaGVtZSwgdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG5cdGlmICgvXihhYm91dHxibG9ifGRhdGEpOiQvLnRlc3QodXJsLnByb3RvY29sKSkge1xuXHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXHR9XG5cblx0Ly8gMy4gU2V0IHVybCdzIHVzZXJuYW1lIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG5cdHVybC51c2VybmFtZSA9ICcnO1xuXG5cdC8vIDQuIFNldCB1cmwncyBwYXNzd29yZCB0byBudWxsLlxuXHQvLyBOb3RlOiBgbnVsbGAgYXBwZWFycyB0byBiZSBhIG1pc3Rha2UgYXMgdGhpcyBhY3R1YWxseSByZXN1bHRzIGluIHRoZSBwYXNzd29yZCBiZWluZyBgXCJudWxsXCJgLlxuXHR1cmwucGFzc3dvcmQgPSAnJztcblxuXHQvLyA1LiBTZXQgdXJsJ3MgZnJhZ21lbnQgdG8gbnVsbC5cblx0Ly8gTm90ZTogYG51bGxgIGFwcGVhcnMgdG8gYmUgYSBtaXN0YWtlIGFzIHRoaXMgYWN0dWFsbHkgcmVzdWx0cyBpbiB0aGUgZnJhZ21lbnQgYmVpbmcgYFwiI251bGxcImAuXG5cdHVybC5oYXNoID0gJyc7XG5cblx0Ly8gNi4gSWYgdGhlIG9yaWdpbi1vbmx5IGZsYWcgaXMgdHJ1ZSwgdGhlbjpcblx0aWYgKG9yaWdpbk9ubHkpIHtcblx0XHQvLyA2LjEuIFNldCB1cmwncyBwYXRoIHRvIG51bGwuXG5cdFx0Ly8gTm90ZTogYG51bGxgIGFwcGVhcnMgdG8gYmUgYSBtaXN0YWtlIGFzIHRoaXMgYWN0dWFsbHkgcmVzdWx0cyBpbiB0aGUgcGF0aCBiZWluZyBgXCIvbnVsbFwiYC5cblx0XHR1cmwucGF0aG5hbWUgPSAnJztcblxuXHRcdC8vIDYuMi4gU2V0IHVybCdzIHF1ZXJ5IHRvIG51bGwuXG5cdFx0Ly8gTm90ZTogYG51bGxgIGFwcGVhcnMgdG8gYmUgYSBtaXN0YWtlIGFzIHRoaXMgYWN0dWFsbHkgcmVzdWx0cyBpbiB0aGUgcXVlcnkgYmVpbmcgYFwiP251bGxcImAuXG5cdFx0dXJsLnNlYXJjaCA9ICcnO1xuXHR9XG5cblx0Ly8gNy4gUmV0dXJuIHVybC5cblx0cmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZW51bWRlZi1yZWZlcnJlcnBvbGljeXxlbnVtIFJlZmVycmVyUG9saWN5fVxuICovXG5jb25zdCBSZWZlcnJlclBvbGljeSA9IG5ldyBTZXQoW1xuXHQnJyxcblx0J25vLXJlZmVycmVyJyxcblx0J25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJyxcblx0J3NhbWUtb3JpZ2luJyxcblx0J29yaWdpbicsXG5cdCdzdHJpY3Qtb3JpZ2luJyxcblx0J29yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicsXG5cdCdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcblx0J3Vuc2FmZS11cmwnXG5dKTtcblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGVmYXVsdC1yZWZlcnJlci1wb2xpY3l8ZGVmYXVsdCByZWZlcnJlciBwb2xpY3l9XG4gKi9cbmNvbnN0IERFRkFVTFRfUkVGRVJSRVJfUE9MSUNZID0gJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nO1xuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNyZWZlcnJlci1wb2xpY2llc3xSZWZlcnJlciBQb2xpY3kgwqczLiBSZWZlcnJlciBQb2xpY2llc31cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWZlcnJlclBvbGljeVxuICogQHJldHVybnMge3N0cmluZ30gcmVmZXJyZXJQb2xpY3lcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSkge1xuXHRpZiAoIVJlZmVycmVyUG9saWN5LmhhcyhyZWZlcnJlclBvbGljeSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHJlZmVycmVyUG9saWN5OiAke3JlZmVycmVyUG9saWN5fWApO1xuXHR9XG5cblx0cmV0dXJuIHJlZmVycmVyUG9saWN5O1xufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc2VjdXJlLWNvbnRleHRzLyNpcy1vcmlnaW4tdHJ1c3R3b3J0aHl8UmVmZXJyZXIgUG9saWN5IMKnMy4yLiBJcyBvcmlnaW4gcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHk/fVxuICogQHBhcmFtIHtleHRlcm5hbDpVUkx9IHVybFxuICogQHJldHVybnMgYHRydWVgOiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIsIGBmYWxzZWA6IFwiTm90IFRydXN0d29ydGh5XCJcbiAqL1xuZnVuY3Rpb24gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5KHVybCkge1xuXHQvLyAxLiBJZiBvcmlnaW4gaXMgYW4gb3BhcXVlIG9yaWdpbiwgcmV0dXJuIFwiTm90IFRydXN0d29ydGh5XCIuXG5cdC8vIE5vdCBhcHBsaWNhYmxlXG5cblx0Ly8gMi4gQXNzZXJ0OiBvcmlnaW4gaXMgYSB0dXBsZSBvcmlnaW4uXG5cdC8vIE5vdCBmb3IgaW1wbGVtZW50YXRpb25zXG5cblx0Ly8gMy4gSWYgb3JpZ2luJ3Mgc2NoZW1lIGlzIGVpdGhlciBcImh0dHBzXCIgb3IgXCJ3c3NcIiwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0aWYgKC9eKGh0dHB8d3MpczokLy50ZXN0KHVybC5wcm90b2NvbCkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDQuIElmIG9yaWdpbidzIGhvc3QgY29tcG9uZW50IG1hdGNoZXMgb25lIG9mIHRoZSBDSURSIG5vdGF0aW9ucyAxMjcuMC4wLjAvOCBvciA6OjEvMTI4IFtSRkM0NjMyXSwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0Y29uc3QgaG9zdElwID0gdXJsLmhvc3QucmVwbGFjZSgvKF5cXFspfChdJCkvZywgJycpO1xuXHRjb25zdCBob3N0SVBWZXJzaW9uID0gbm9kZV9uZXQuaXNJUChob3N0SXApO1xuXG5cdGlmIChob3N0SVBWZXJzaW9uID09PSA0ICYmIC9eMTI3XFwuLy50ZXN0KGhvc3RJcCkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChob3N0SVBWZXJzaW9uID09PSA2ICYmIC9eKCgoMCs6KXs3fSl8KDo6KDArOil7MCw2fSkpMCoxJC8udGVzdChob3N0SXApKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyA1LiBJZiBvcmlnaW4ncyBob3N0IGNvbXBvbmVudCBpcyBcImxvY2FsaG9zdFwiIG9yIGZhbGxzIHdpdGhpbiBcIi5sb2NhbGhvc3RcIiwgYW5kIHRoZSB1c2VyIGFnZW50IGNvbmZvcm1zIHRvIHRoZSBuYW1lIHJlc29sdXRpb24gcnVsZXMgaW4gW2xldC1sb2NhbGhvc3QtYmUtbG9jYWxob3N0XSwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0Ly8gV2UgYXJlIHJldHVybmluZyBGQUxTRSBoZXJlIGJlY2F1c2Ugd2UgY2Fubm90IGVuc3VyZSBjb25mb3JtYW5jZSB0b1xuXHQvLyBsZXQtbG9jYWxob3N0LWJlLWxvYWxob3N0IChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtd2VzdC1sZXQtbG9jYWxob3N0LWJlLWxvY2FsaG9zdClcblx0aWYgKHVybC5ob3N0ID09PSAnbG9jYWxob3N0JyB8fCB1cmwuaG9zdC5lbmRzV2l0aCgnLmxvY2FsaG9zdCcpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gNi4gSWYgb3JpZ2luJ3Mgc2NoZW1lIGNvbXBvbmVudCBpcyBmaWxlLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAodXJsLnByb3RvY29sID09PSAnZmlsZTonKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyA3LiBJZiBvcmlnaW4ncyBzY2hlbWUgY29tcG9uZW50IGlzIG9uZSB3aGljaCB0aGUgdXNlciBhZ2VudCBjb25zaWRlcnMgdG8gYmUgYXV0aGVudGljYXRlZCwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0Ly8gTm90IHN1cHBvcnRlZFxuXG5cdC8vIDguIElmIG9yaWdpbiBoYXMgYmVlbiBjb25maWd1cmVkIGFzIGEgdHJ1c3R3b3J0aHkgb3JpZ2luLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHQvLyBOb3Qgc3VwcG9ydGVkXG5cblx0Ly8gOS4gUmV0dXJuIFwiTm90IFRydXN0d29ydGh5XCIuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXNlY3VyZS1jb250ZXh0cy8jaXMtdXJsLXRydXN0d29ydGh5fFJlZmVycmVyIFBvbGljeSDCpzMuMy4gSXMgdXJsIHBvdGVudGlhbGx5IHRydXN0d29ydGh5P31cbiAqIEBwYXJhbSB7ZXh0ZXJuYWw6VVJMfSB1cmxcbiAqIEByZXR1cm5zIGB0cnVlYDogXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLCBgZmFsc2VgOiBcIk5vdCBUcnVzdHdvcnRoeVwiXG4gKi9cbmZ1bmN0aW9uIGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwpIHtcblx0Ly8gMS4gSWYgdXJsIGlzIFwiYWJvdXQ6YmxhbmtcIiBvciBcImFib3V0OnNyY2RvY1wiLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAoL15hYm91dDooYmxhbmt8c3JjZG9jKSQvLnRlc3QodXJsKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gMi4gSWYgdXJsJ3Mgc2NoZW1lIGlzIFwiZGF0YVwiLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAodXJsLnByb3RvY29sID09PSAnZGF0YTonKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBOb3RlOiBUaGUgb3JpZ2luIG9mIGJsb2I6IGFuZCBmaWxlc3lzdGVtOiBVUkxzIGlzIHRoZSBvcmlnaW4gb2YgdGhlIGNvbnRleHQgaW4gd2hpY2ggdGhleSB3ZXJlXG5cdC8vIGNyZWF0ZWQuIFRoZXJlZm9yZSwgYmxvYnMgY3JlYXRlZCBpbiBhIHRydXN0d29ydGh5IG9yaWdpbiB3aWxsIHRoZW1zZWx2ZXMgYmUgcG90ZW50aWFsbHlcblx0Ly8gdHJ1c3R3b3J0aHkuXG5cdGlmICgvXihibG9ifGZpbGVzeXN0ZW0pOiQvLnRlc3QodXJsLnByb3RvY29sKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gMy4gUmV0dXJuIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIMKnMy4yIElzIG9yaWdpbiBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeT8gb24gdXJsJ3Mgb3JpZ2luLlxuXHRyZXR1cm4gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5KHVybCk7XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHJlZmVycmVyVVJMIHRvIGVuZm9yY2UgYW55IGV4dHJhIHNlY3VyaXR5IHBvbGljeSBjb25zaWRlcmF0aW9ucy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNkZXRlcm1pbmUtcmVxdWVzdHMtcmVmZXJyZXJ8UmVmZXJyZXIgUG9saWN5IMKnOC4zLiBEZXRlcm1pbmUgcmVxdWVzdCdzIFJlZmVycmVyfSwgc3RlcCA3XG4gKiBAY2FsbGJhY2sgbW9kdWxlOnV0aWxzL3JlZmVycmVyfnJlZmVycmVyVVJMQ2FsbGJhY2tcbiAqIEBwYXJhbSB7ZXh0ZXJuYWw6VVJMfSByZWZlcnJlclVSTFxuICogQHJldHVybnMge2V4dGVybmFsOlVSTH0gbW9kaWZpZWQgcmVmZXJyZXJVUkxcbiAqL1xuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSByZWZlcnJlck9yaWdpbiB0byBlbmZvcmNlIGFueSBleHRyYSBzZWN1cml0eSBwb2xpY3kgY29uc2lkZXJhdGlvbnMuXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyfFJlZmVycmVyIFBvbGljeSDCpzguMy4gRGV0ZXJtaW5lIHJlcXVlc3QncyBSZWZlcnJlcn0sIHN0ZXAgN1xuICogQGNhbGxiYWNrIG1vZHVsZTp1dGlscy9yZWZlcnJlcn5yZWZlcnJlck9yaWdpbkNhbGxiYWNrXG4gKiBAcGFyYW0ge2V4dGVybmFsOlVSTH0gcmVmZXJyZXJPcmlnaW5cbiAqIEByZXR1cm5zIHtleHRlcm5hbDpVUkx9IG1vZGlmaWVkIHJlZmVycmVyT3JpZ2luXG4gKi9cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyfFJlZmVycmVyIFBvbGljeSDCpzguMy4gRGV0ZXJtaW5lIHJlcXVlc3QncyBSZWZlcnJlcn1cbiAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICogQHBhcmFtIHtvYmplY3R9IG9cbiAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3JlZmVycmVyfnJlZmVycmVyVVJMQ2FsbGJhY2t9IG8ucmVmZXJyZXJVUkxDYWxsYmFja1xuICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcmVmZXJyZXJ+cmVmZXJyZXJPcmlnaW5DYWxsYmFja30gby5yZWZlcnJlck9yaWdpbkNhbGxiYWNrXG4gKiBAcmV0dXJucyB7ZXh0ZXJuYWw6VVJMfSBSZXF1ZXN0J3MgcmVmZXJyZXJcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihyZXF1ZXN0LCB7cmVmZXJyZXJVUkxDYWxsYmFjaywgcmVmZXJyZXJPcmlnaW5DYWxsYmFja30gPSB7fSkge1xuXHQvLyBUaGVyZSBhcmUgMiBub3RlcyBpbiB0aGUgc3BlY2lmaWNhdGlvbiBhYm91dCBpbnZhbGlkIHByZS1jb25kaXRpb25zLiAgV2UgcmV0dXJuIG51bGwsIGhlcmUsIGZvclxuXHQvLyB0aGVzZSBjYXNlczpcblx0Ly8gPiBOb3RlOiBJZiByZXF1ZXN0J3MgcmVmZXJyZXIgaXMgXCJuby1yZWZlcnJlclwiLCBGZXRjaCB3aWxsIG5vdCBjYWxsIGludG8gdGhpcyBhbGdvcml0aG0uXG5cdC8vID4gTm90ZTogSWYgcmVxdWVzdCdzIHJlZmVycmVyIHBvbGljeSBpcyB0aGUgZW1wdHkgc3RyaW5nLCBGZXRjaCB3aWxsIG5vdCBjYWxsIGludG8gdGhpc1xuXHQvLyA+IGFsZ29yaXRobS5cblx0aWYgKHJlcXVlc3QucmVmZXJyZXIgPT09ICduby1yZWZlcnJlcicgfHwgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9PT0gJycpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIDEuIExldCBwb2xpY3kgYmUgcmVxdWVzdCdzIGFzc29jaWF0ZWQgcmVmZXJyZXIgcG9saWN5LlxuXHRjb25zdCBwb2xpY3kgPSByZXF1ZXN0LnJlZmVycmVyUG9saWN5O1xuXG5cdC8vIDIuIExldCBlbnZpcm9ubWVudCBiZSByZXF1ZXN0J3MgY2xpZW50LlxuXHQvLyBub3QgYXBwbGljYWJsZSB0byBub2RlLmpzXG5cblx0Ly8gMy4gU3dpdGNoIG9uIHJlcXVlc3QncyByZWZlcnJlcjpcblx0aWYgKHJlcXVlc3QucmVmZXJyZXIgPT09ICdhYm91dDpjbGllbnQnKSB7XG5cdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cdH1cblxuXHQvLyBcImEgVVJMXCI6IExldCByZWZlcnJlclNvdXJjZSBiZSByZXF1ZXN0J3MgcmVmZXJyZXIuXG5cdGNvbnN0IHJlZmVycmVyU291cmNlID0gcmVxdWVzdC5yZWZlcnJlcjtcblxuXHQvLyA0LiBMZXQgcmVxdWVzdCdzIHJlZmVycmVyVVJMIGJlIHRoZSByZXN1bHQgb2Ygc3RyaXBwaW5nIHJlZmVycmVyU291cmNlIGZvciB1c2UgYXMgYSByZWZlcnJlci5cblx0bGV0IHJlZmVycmVyVVJMID0gc3RyaXBVUkxGb3JVc2VBc0FSZWZlcnJlcihyZWZlcnJlclNvdXJjZSk7XG5cblx0Ly8gNS4gTGV0IHJlZmVycmVyT3JpZ2luIGJlIHRoZSByZXN1bHQgb2Ygc3RyaXBwaW5nIHJlZmVycmVyU291cmNlIGZvciB1c2UgYXMgYSByZWZlcnJlciwgd2l0aCB0aGVcblx0Ly8gICAgb3JpZ2luLW9ubHkgZmxhZyBzZXQgdG8gdHJ1ZS5cblx0bGV0IHJlZmVycmVyT3JpZ2luID0gc3RyaXBVUkxGb3JVc2VBc0FSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSk7XG5cblx0Ly8gNi4gSWYgdGhlIHJlc3VsdCBvZiBzZXJpYWxpemluZyByZWZlcnJlclVSTCBpcyBhIHN0cmluZyB3aG9zZSBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIDQwOTYsIHNldFxuXHQvLyAgICByZWZlcnJlclVSTCB0byByZWZlcnJlck9yaWdpbi5cblx0aWYgKHJlZmVycmVyVVJMLnRvU3RyaW5nKCkubGVuZ3RoID4gNDA5Nikge1xuXHRcdHJlZmVycmVyVVJMID0gcmVmZXJyZXJPcmlnaW47XG5cdH1cblxuXHQvLyA3LiBUaGUgdXNlciBhZ2VudCBNQVkgYWx0ZXIgcmVmZXJyZXJVUkwgb3IgcmVmZXJyZXJPcmlnaW4gYXQgdGhpcyBwb2ludCB0byBlbmZvcmNlIGFyYml0cmFyeVxuXHQvLyAgICBwb2xpY3kgY29uc2lkZXJhdGlvbnMgaW4gdGhlIGludGVyZXN0cyBvZiBtaW5pbWl6aW5nIGRhdGEgbGVha2FnZS4gRm9yIGV4YW1wbGUsIHRoZSB1c2VyXG5cdC8vICAgIGFnZW50IGNvdWxkIHN0cmlwIHRoZSBVUkwgZG93biB0byBhbiBvcmlnaW4sIG1vZGlmeSBpdHMgaG9zdCwgcmVwbGFjZSBpdCB3aXRoIGFuIGVtcHR5XG5cdC8vICAgIHN0cmluZywgZXRjLlxuXHRpZiAocmVmZXJyZXJVUkxDYWxsYmFjaykge1xuXHRcdHJlZmVycmVyVVJMID0gcmVmZXJyZXJVUkxDYWxsYmFjayhyZWZlcnJlclVSTCk7XG5cdH1cblxuXHRpZiAocmVmZXJyZXJPcmlnaW5DYWxsYmFjaykge1xuXHRcdHJlZmVycmVyT3JpZ2luID0gcmVmZXJyZXJPcmlnaW5DYWxsYmFjayhyZWZlcnJlck9yaWdpbik7XG5cdH1cblxuXHQvLyA4LkV4ZWN1dGUgdGhlIHN0YXRlbWVudHMgY29ycmVzcG9uZGluZyB0byB0aGUgdmFsdWUgb2YgcG9saWN5OlxuXHRjb25zdCBjdXJyZW50VVJMID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG5cblx0c3dpdGNoIChwb2xpY3kpIHtcblx0XHRjYXNlICduby1yZWZlcnJlcic6XG5cdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblxuXHRcdGNhc2UgJ29yaWdpbic6XG5cdFx0XHRyZXR1cm4gcmVmZXJyZXJPcmlnaW47XG5cblx0XHRjYXNlICd1bnNhZmUtdXJsJzpcblx0XHRcdHJldHVybiByZWZlcnJlclVSTDtcblxuXHRcdGNhc2UgJ3N0cmljdC1vcmlnaW4nOlxuXHRcdFx0Ly8gMS4gSWYgcmVmZXJyZXJVUkwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgYW5kIHJlcXVlc3QncyBjdXJyZW50IFVSTCBpcyBub3QgYVxuXHRcdFx0Ly8gICAgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cblx0XHRcdGlmIChpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkocmVmZXJyZXJVUkwpICYmICFpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoY3VycmVudFVSTCkpIHtcblx0XHRcdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDIuIFJldHVybiByZWZlcnJlck9yaWdpbi5cblx0XHRcdHJldHVybiByZWZlcnJlck9yaWdpbi50b1N0cmluZygpO1xuXG5cdFx0Y2FzZSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6XG5cdFx0XHQvLyAxLiBJZiB0aGUgb3JpZ2luIG9mIHJlZmVycmVyVVJMIGFuZCB0aGUgb3JpZ2luIG9mIHJlcXVlc3QncyBjdXJyZW50IFVSTCBhcmUgdGhlIHNhbWUsIHRoZW5cblx0XHRcdC8vICAgIHJldHVybiByZWZlcnJlclVSTC5cblx0XHRcdGlmIChyZWZlcnJlclVSTC5vcmlnaW4gPT09IGN1cnJlbnRVUkwub3JpZ2luKSB7XG5cdFx0XHRcdHJldHVybiByZWZlcnJlclVSTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gMi4gSWYgcmVmZXJyZXJVUkwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgYW5kIHJlcXVlc3QncyBjdXJyZW50IFVSTCBpcyBub3QgYVxuXHRcdFx0Ly8gICAgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cblx0XHRcdGlmIChpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkocmVmZXJyZXJVUkwpICYmICFpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoY3VycmVudFVSTCkpIHtcblx0XHRcdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDMuIFJldHVybiByZWZlcnJlck9yaWdpbi5cblx0XHRcdHJldHVybiByZWZlcnJlck9yaWdpbjtcblxuXHRcdGNhc2UgJ3NhbWUtb3JpZ2luJzpcblx0XHRcdC8vIDEuIElmIHRoZSBvcmlnaW4gb2YgcmVmZXJyZXJVUkwgYW5kIHRoZSBvcmlnaW4gb2YgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGFyZSB0aGUgc2FtZSwgdGhlblxuXHRcdFx0Ly8gICAgcmV0dXJuIHJlZmVycmVyVVJMLlxuXHRcdFx0aWYgKHJlZmVycmVyVVJMLm9yaWdpbiA9PT0gY3VycmVudFVSTC5vcmlnaW4pIHtcblx0XHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAyLiBSZXR1cm4gbm8gcmVmZXJyZXIuXG5cdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblxuXHRcdGNhc2UgJ29yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6XG5cdFx0XHQvLyAxLiBJZiB0aGUgb3JpZ2luIG9mIHJlZmVycmVyVVJMIGFuZCB0aGUgb3JpZ2luIG9mIHJlcXVlc3QncyBjdXJyZW50IFVSTCBhcmUgdGhlIHNhbWUsIHRoZW5cblx0XHRcdC8vICAgIHJldHVybiByZWZlcnJlclVSTC5cblx0XHRcdGlmIChyZWZlcnJlclVSTC5vcmlnaW4gPT09IGN1cnJlbnRVUkwub3JpZ2luKSB7XG5cdFx0XHRcdHJldHVybiByZWZlcnJlclVSTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIHJlZmVycmVyT3JpZ2luLlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyT3JpZ2luO1xuXG5cdFx0Y2FzZSAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnOlxuXHRcdFx0Ly8gMS4gSWYgcmVmZXJyZXJVUkwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgYW5kIHJlcXVlc3QncyBjdXJyZW50IFVSTCBpcyBub3QgYVxuXHRcdFx0Ly8gICAgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cblx0XHRcdGlmIChpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkocmVmZXJyZXJVUkwpICYmICFpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoY3VycmVudFVSTCkpIHtcblx0XHRcdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDIuIFJldHVybiByZWZlcnJlclVSTC5cblx0XHRcdHJldHVybiByZWZlcnJlclVSTDtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHJlZmVycmVyUG9saWN5OiAke3BvbGljeX1gKTtcblx0fVxufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNwYXJzZS1yZWZlcnJlci1wb2xpY3ktZnJvbS1oZWFkZXJ8UmVmZXJyZXIgUG9saWN5IMKnOC4xLiBQYXJzZSBhIHJlZmVycmVyIHBvbGljeSBmcm9tIGEgUmVmZXJyZXItUG9saWN5IGhlYWRlcn1cbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVycyBSZXNwb25zZSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBwb2xpY3lcbiAqL1xuZnVuY3Rpb24gcGFyc2VSZWZlcnJlclBvbGljeUZyb21IZWFkZXIoaGVhZGVycykge1xuXHQvLyAxLiBMZXQgcG9saWN5LXRva2VucyBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzIGdpdmVuIGBSZWZlcnJlci1Qb2xpY3lgXG5cdC8vICAgIGFuZCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG5cdGNvbnN0IHBvbGljeVRva2VucyA9IChoZWFkZXJzLmdldCgncmVmZXJyZXItcG9saWN5JykgfHwgJycpLnNwbGl0KC9bLFxcc10rLyk7XG5cblx0Ly8gMi4gTGV0IHBvbGljeSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuXHRsZXQgcG9saWN5ID0gJyc7XG5cblx0Ly8gMy4gRm9yIGVhY2ggdG9rZW4gaW4gcG9saWN5LXRva2VucywgaWYgdG9rZW4gaXMgYSByZWZlcnJlciBwb2xpY3kgYW5kIHRva2VuIGlzIG5vdCB0aGUgZW1wdHlcblx0Ly8gICAgc3RyaW5nLCB0aGVuIHNldCBwb2xpY3kgdG8gdG9rZW4uXG5cdC8vIE5vdGU6IFRoaXMgYWxnb3JpdGhtIGxvb3BzIG92ZXIgbXVsdGlwbGUgcG9saWN5IHZhbHVlcyB0byBhbGxvdyBkZXBsb3ltZW50IG9mIG5ldyBwb2xpY3lcblx0Ly8gdmFsdWVzIHdpdGggZmFsbGJhY2tzIGZvciBvbGRlciB1c2VyIGFnZW50cywgYXMgZGVzY3JpYmVkIGluIMKnIDExLjEgVW5rbm93biBQb2xpY3kgVmFsdWVzLlxuXHRmb3IgKGNvbnN0IHRva2VuIG9mIHBvbGljeVRva2Vucykge1xuXHRcdGlmICh0b2tlbiAmJiBSZWZlcnJlclBvbGljeS5oYXModG9rZW4pKSB7XG5cdFx0XHRwb2xpY3kgPSB0b2tlbjtcblx0XHR9XG5cdH1cblxuXHQvLyA0LiBSZXR1cm4gcG9saWN5LlxuXHRyZXR1cm4gcG9saWN5O1xufVxuXG4vKipcbiAqIFJlcXVlc3QuanNcbiAqXG4gKiBSZXF1ZXN0IGNsYXNzIGNvbnRhaW5zIHNlcnZlciBvbmx5IG9wdGlvbnNcbiAqXG4gKiBBbGwgc3BlYyBhbGdvcml0aG0gc3RlcCBudW1iZXJzIGFyZSBiYXNlZCBvbiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy9jb21taXQtc25hcHNob3RzL2FlNzE2ODIyY2IzYTYxODQzMjI2Y2QwOTBlZWZjNjU4OTQ0NmMxZDIvLlxuICovXG5cbmNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbCgnUmVxdWVzdCBpbnRlcm5hbHMnKTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBpbnN0YW5jZSBvZiBSZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSAgeyp9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNSZXF1ZXN0ID0gb2JqZWN0ID0+IHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiBvYmplY3RbSU5URVJOQUxTXSA9PT0gJ29iamVjdCdcblx0KTtcbn07XG5cbmNvbnN0IGRvQmFkRGF0YVdhcm4gPSBub2RlX3V0aWwuZGVwcmVjYXRlKCgpID0+IHt9LFxuXHQnLmRhdGEgaXMgbm90IGEgdmFsaWQgUmVxdWVzdEluaXQgcHJvcGVydHksIHVzZSAuYm9keSBpbnN0ZWFkJyxcblx0J2h0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzEwMDAgKHJlcXVlc3QpJyk7XG5cbi8qKlxuICogUmVxdWVzdCBjbGFzc1xuICpcbiAqIFJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3QtY2xhc3NcbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgIGlucHV0ICBVcmwgb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAgT2JqZWN0ICBpbml0ICAgQ3VzdG9tIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuY2xhc3MgUmVxdWVzdCBleHRlbmRzIEJvZHkge1xuXHRjb25zdHJ1Y3RvcihpbnB1dCwgaW5pdCA9IHt9KSB7XG5cdFx0bGV0IHBhcnNlZFVSTDtcblxuXHRcdC8vIE5vcm1hbGl6ZSBpbnB1dCBhbmQgZm9yY2UgVVJMIHRvIGJlIGVuY29kZWQgYXMgVVRGLTggKGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzI0NSlcblx0XHRpZiAoaXNSZXF1ZXN0KGlucHV0KSkge1xuXHRcdFx0cGFyc2VkVVJMID0gbmV3IFVSTChpbnB1dC51cmwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXJzZWRVUkwgPSBuZXcgVVJMKGlucHV0KTtcblx0XHRcdGlucHV0ID0ge307XG5cdFx0fVxuXG5cdFx0aWYgKHBhcnNlZFVSTC51c2VybmFtZSAhPT0gJycgfHwgcGFyc2VkVVJMLnBhc3N3b3JkICE9PSAnJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgJHtwYXJzZWRVUkx9IGlzIGFuIHVybCB3aXRoIGVtYmVkZGVkIGNyZWRlbnRpYWxzLmApO1xuXHRcdH1cblxuXHRcdGxldCBtZXRob2QgPSBpbml0Lm1ldGhvZCB8fCBpbnB1dC5tZXRob2QgfHwgJ0dFVCc7XG5cdFx0aWYgKC9eKGRlbGV0ZXxnZXR8aGVhZHxvcHRpb25zfHBvc3R8cHV0KSQvaS50ZXN0KG1ldGhvZCkpIHtcblx0XHRcdG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuXHRcdH1cblxuXHRcdGlmICghaXNSZXF1ZXN0KGluaXQpICYmICdkYXRhJyBpbiBpbml0KSB7XG5cdFx0XHRkb0JhZERhdGFXYXJuKCk7XG5cdFx0fVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdGlmICgoaW5pdC5ib2R5ICE9IG51bGwgfHwgKGlzUmVxdWVzdChpbnB1dCkgJiYgaW5wdXQuYm9keSAhPT0gbnVsbCkpICYmXG5cdFx0XHQobWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdIRUFEJykpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVlc3Qgd2l0aCBHRVQvSEVBRCBtZXRob2QgY2Fubm90IGhhdmUgYm9keScpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlucHV0Qm9keSA9IGluaXQuYm9keSA/XG5cdFx0XHRpbml0LmJvZHkgOlxuXHRcdFx0KGlzUmVxdWVzdChpbnB1dCkgJiYgaW5wdXQuYm9keSAhPT0gbnVsbCA/XG5cdFx0XHRcdGNsb25lKGlucHV0KSA6XG5cdFx0XHRcdG51bGwpO1xuXG5cdFx0c3VwZXIoaW5wdXRCb2R5LCB7XG5cdFx0XHRzaXplOiBpbml0LnNpemUgfHwgaW5wdXQuc2l6ZSB8fCAwXG5cdFx0fSk7XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzIHx8IGlucHV0LmhlYWRlcnMgfHwge30pO1xuXG5cdFx0aWYgKGlucHV0Qm9keSAhPT0gbnVsbCAmJiAhaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpKSB7XG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IGV4dHJhY3RDb250ZW50VHlwZShpbnB1dEJvZHksIHRoaXMpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHNpZ25hbCA9IGlzUmVxdWVzdChpbnB1dCkgP1xuXHRcdFx0aW5wdXQuc2lnbmFsIDpcblx0XHRcdG51bGw7XG5cdFx0aWYgKCdzaWduYWwnIGluIGluaXQpIHtcblx0XHRcdHNpZ25hbCA9IGluaXQuc2lnbmFsO1xuXHRcdH1cblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRpZiAoc2lnbmFsICE9IG51bGwgJiYgIWlzQWJvcnRTaWduYWwoc2lnbmFsKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgc2lnbmFsIHRvIGJlIGFuIGluc3RhbmNlb2YgQWJvcnRTaWduYWwgb3IgRXZlbnRUYXJnZXQnKTtcblx0XHR9XG5cblx0XHQvLyDCpzUuNCwgUmVxdWVzdCBjb25zdHJ1Y3RvciBzdGVwcywgc3RlcCAxNS4xXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdGxldCByZWZlcnJlciA9IGluaXQucmVmZXJyZXIgPT0gbnVsbCA/IGlucHV0LnJlZmVycmVyIDogaW5pdC5yZWZlcnJlcjtcblx0XHRpZiAocmVmZXJyZXIgPT09ICcnKSB7XG5cdFx0XHQvLyDCpzUuNCwgUmVxdWVzdCBjb25zdHJ1Y3RvciBzdGVwcywgc3RlcCAxNS4yXG5cdFx0XHRyZWZlcnJlciA9ICduby1yZWZlcnJlcic7XG5cdFx0fSBlbHNlIGlmIChyZWZlcnJlcikge1xuXHRcdFx0Ly8gwqc1LjQsIFJlcXVlc3QgY29uc3RydWN0b3Igc3RlcHMsIHN0ZXAgMTUuMy4xLCAxNS4zLjJcblx0XHRcdGNvbnN0IHBhcnNlZFJlZmVycmVyID0gbmV3IFVSTChyZWZlcnJlcik7XG5cdFx0XHQvLyDCpzUuNCwgUmVxdWVzdCBjb25zdHJ1Y3RvciBzdGVwcywgc3RlcCAxNS4zLjMsIDE1LjMuNFxuXHRcdFx0cmVmZXJyZXIgPSAvXmFib3V0OihcXC9cXC8pP2NsaWVudCQvLnRlc3QocGFyc2VkUmVmZXJyZXIpID8gJ2NsaWVudCcgOiBwYXJzZWRSZWZlcnJlcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVmZXJyZXIgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0dGhpc1tJTlRFUk5BTFNdID0ge1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0cmVkaXJlY3Q6IGluaXQucmVkaXJlY3QgfHwgaW5wdXQucmVkaXJlY3QgfHwgJ2ZvbGxvdycsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0cGFyc2VkVVJMLFxuXHRcdFx0c2lnbmFsLFxuXHRcdFx0cmVmZXJyZXJcblx0XHR9O1xuXG5cdFx0Ly8gTm9kZS1mZXRjaC1vbmx5IG9wdGlvbnNcblx0XHR0aGlzLmZvbGxvdyA9IGluaXQuZm9sbG93ID09PSB1bmRlZmluZWQgPyAoaW5wdXQuZm9sbG93ID09PSB1bmRlZmluZWQgPyAyMCA6IGlucHV0LmZvbGxvdykgOiBpbml0LmZvbGxvdztcblx0XHR0aGlzLmNvbXByZXNzID0gaW5pdC5jb21wcmVzcyA9PT0gdW5kZWZpbmVkID8gKGlucHV0LmNvbXByZXNzID09PSB1bmRlZmluZWQgPyB0cnVlIDogaW5wdXQuY29tcHJlc3MpIDogaW5pdC5jb21wcmVzcztcblx0XHR0aGlzLmNvdW50ZXIgPSBpbml0LmNvdW50ZXIgfHwgaW5wdXQuY291bnRlciB8fCAwO1xuXHRcdHRoaXMuYWdlbnQgPSBpbml0LmFnZW50IHx8IGlucHV0LmFnZW50O1xuXHRcdHRoaXMuaGlnaFdhdGVyTWFyayA9IGluaXQuaGlnaFdhdGVyTWFyayB8fCBpbnB1dC5oaWdoV2F0ZXJNYXJrIHx8IDE2Mzg0O1xuXHRcdHRoaXMuaW5zZWN1cmVIVFRQUGFyc2VyID0gaW5pdC5pbnNlY3VyZUhUVFBQYXJzZXIgfHwgaW5wdXQuaW5zZWN1cmVIVFRQUGFyc2VyIHx8IGZhbHNlO1xuXG5cdFx0Ly8gwqc1LjQsIFJlcXVlc3QgY29uc3RydWN0b3Igc3RlcHMsIHN0ZXAgMTYuXG5cdFx0Ly8gRGVmYXVsdCBpcyBlbXB0eSBzdHJpbmcgcGVyIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJlcXVlc3QtcmVmZXJyZXItcG9saWN5XG5cdFx0dGhpcy5yZWZlcnJlclBvbGljeSA9IGluaXQucmVmZXJyZXJQb2xpY3kgfHwgaW5wdXQucmVmZXJyZXJQb2xpY3kgfHwgJyc7XG5cdH1cblxuXHQvKiogQHJldHVybnMge3N0cmluZ30gKi9cblx0Z2V0IG1ldGhvZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLm1ldGhvZDtcblx0fVxuXG5cdC8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuXHRnZXQgdXJsKCkge1xuXHRcdHJldHVybiBub2RlX3VybC5mb3JtYXQodGhpc1tJTlRFUk5BTFNdLnBhcnNlZFVSTCk7XG5cdH1cblxuXHQvKiogQHJldHVybnMge0hlYWRlcnN9ICovXG5cdGdldCBoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uaGVhZGVycztcblx0fVxuXG5cdGdldCByZWRpcmVjdCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnJlZGlyZWN0O1xuXHR9XG5cblx0LyoqIEByZXR1cm5zIHtBYm9ydFNpZ25hbH0gKi9cblx0Z2V0IHNpZ25hbCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnNpZ25hbDtcblx0fVxuXG5cdC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdC1yZWZlcnJlclxuXHRnZXQgcmVmZXJyZXIoKSB7XG5cdFx0aWYgKHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlciA9PT0gJ25vLXJlZmVycmVyJykge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzW0lOVEVSTkFMU10ucmVmZXJyZXIgPT09ICdjbGllbnQnKSB7XG5cdFx0XHRyZXR1cm4gJ2Fib3V0OmNsaWVudCc7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlcikge1xuXHRcdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlci50b1N0cmluZygpO1xuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHRnZXQgcmVmZXJyZXJQb2xpY3koKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlclBvbGljeTtcblx0fVxuXG5cdHNldCByZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSkge1xuXHRcdHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlclBvbGljeSA9IHZhbGlkYXRlUmVmZXJyZXJQb2xpY3kocmVmZXJyZXJQb2xpY3kpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsb25lIHRoaXMgcmVxdWVzdFxuXHQgKlxuXHQgKiBAcmV0dXJuICBSZXF1ZXN0XG5cdCAqL1xuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IFJlcXVlc3QodGhpcyk7XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuICdSZXF1ZXN0Jztcblx0fVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXF1ZXN0LnByb3RvdHlwZSwge1xuXHRtZXRob2Q6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0dXJsOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGhlYWRlcnM6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0cmVkaXJlY3Q6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0Y2xvbmU6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c2lnbmFsOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHJlZmVycmVyOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHJlZmVycmVyUG9saWN5OiB7ZW51bWVyYWJsZTogdHJ1ZX1cbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBSZXF1ZXN0IHRvIE5vZGUuanMgaHR0cCByZXF1ZXN0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0IC0gQSBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcmV0dXJuIFRoZSBvcHRpb25zIG9iamVjdCB0byBiZSBwYXNzZWQgdG8gaHR0cC5yZXF1ZXN0XG4gKi9cbmNvbnN0IGdldE5vZGVSZXF1ZXN0T3B0aW9ucyA9IHJlcXVlc3QgPT4ge1xuXHRjb25zdCB7cGFyc2VkVVJMfSA9IHJlcXVlc3RbSU5URVJOQUxTXTtcblx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlcXVlc3RbSU5URVJOQUxTXS5oZWFkZXJzKTtcblxuXHQvLyBGZXRjaCBzdGVwIDEuM1xuXHRpZiAoIWhlYWRlcnMuaGFzKCdBY2NlcHQnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnKi8qJyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcHMgMi40LTIuN1xuXHRsZXQgY29udGVudExlbmd0aFZhbHVlID0gbnVsbDtcblx0aWYgKHJlcXVlc3QuYm9keSA9PT0gbnVsbCAmJiAvXihwb3N0fHB1dCkkL2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcblx0XHRjb250ZW50TGVuZ3RoVmFsdWUgPSAnMCc7XG5cdH1cblxuXHRpZiAocmVxdWVzdC5ib2R5ICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgdG90YWxCeXRlcyA9IGdldFRvdGFsQnl0ZXMocmVxdWVzdCk7XG5cdFx0Ly8gU2V0IENvbnRlbnQtTGVuZ3RoIGlmIHRvdGFsQnl0ZXMgaXMgYSBudW1iZXIgKHRoYXQgaXMgbm90IE5hTilcblx0XHRpZiAodHlwZW9mIHRvdGFsQnl0ZXMgPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNOYU4odG90YWxCeXRlcykpIHtcblx0XHRcdGNvbnRlbnRMZW5ndGhWYWx1ZSA9IFN0cmluZyh0b3RhbEJ5dGVzKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY29udGVudExlbmd0aFZhbHVlKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0NvbnRlbnQtTGVuZ3RoJywgY29udGVudExlbmd0aFZhbHVlKTtcblx0fVxuXG5cdC8vIDQuMS4gTWFpbiBmZXRjaCwgc3RlcCAyLjZcblx0Ly8gPiBJZiByZXF1ZXN0J3MgcmVmZXJyZXIgcG9saWN5IGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3QncyByZWZlcnJlciBwb2xpY3kgdG8gdGhlXG5cdC8vID4gZGVmYXVsdCByZWZlcnJlciBwb2xpY3kuXG5cdGlmIChyZXF1ZXN0LnJlZmVycmVyUG9saWN5ID09PSAnJykge1xuXHRcdHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSBERUZBVUxUX1JFRkVSUkVSX1BPTElDWTtcblx0fVxuXG5cdC8vIDQuMS4gTWFpbiBmZXRjaCwgc3RlcCAyLjdcblx0Ly8gPiBJZiByZXF1ZXN0J3MgcmVmZXJyZXIgaXMgbm90IFwibm8tcmVmZXJyZXJcIiwgc2V0IHJlcXVlc3QncyByZWZlcnJlciB0byB0aGUgcmVzdWx0IG9mIGludm9raW5nXG5cdC8vID4gZGV0ZXJtaW5lIHJlcXVlc3QncyByZWZlcnJlci5cblx0aWYgKHJlcXVlc3QucmVmZXJyZXIgJiYgcmVxdWVzdC5yZWZlcnJlciAhPT0gJ25vLXJlZmVycmVyJykge1xuXHRcdHJlcXVlc3RbSU5URVJOQUxTXS5yZWZlcnJlciA9IGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIocmVxdWVzdCk7XG5cdH0gZWxzZSB7XG5cdFx0cmVxdWVzdFtJTlRFUk5BTFNdLnJlZmVycmVyID0gJ25vLXJlZmVycmVyJztcblx0fVxuXG5cdC8vIDQuNS4gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoLCBzdGVwIDYuOVxuXHQvLyA+IElmIGh0dHBSZXF1ZXN0J3MgcmVmZXJyZXIgaXMgYSBVUkwsIHRoZW4gYXBwZW5kIGBSZWZlcmVyYC9odHRwUmVxdWVzdCdzIHJlZmVycmVyLCBzZXJpYWxpemVkXG5cdC8vID4gIGFuZCBpc29tb3JwaGljIGVuY29kZWQsIHRvIGh0dHBSZXF1ZXN0J3MgaGVhZGVyIGxpc3QuXG5cdGlmIChyZXF1ZXN0W0lOVEVSTkFMU10ucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcblx0XHRoZWFkZXJzLnNldCgnUmVmZXJlcicsIHJlcXVlc3QucmVmZXJyZXIpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXAgMi4xMVxuXHRpZiAoIWhlYWRlcnMuaGFzKCdVc2VyLUFnZW50JykpIHtcblx0XHRoZWFkZXJzLnNldCgnVXNlci1BZ2VudCcsICdub2RlLWZldGNoJyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcCAyLjE1XG5cdGlmIChyZXF1ZXN0LmNvbXByZXNzICYmICFoZWFkZXJzLmhhcygnQWNjZXB0LUVuY29kaW5nJykpIHtcblx0XHRoZWFkZXJzLnNldCgnQWNjZXB0LUVuY29kaW5nJywgJ2d6aXAsIGRlZmxhdGUsIGJyJyk7XG5cdH1cblxuXHRsZXQge2FnZW50fSA9IHJlcXVlc3Q7XG5cdGlmICh0eXBlb2YgYWdlbnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRhZ2VudCA9IGFnZW50KHBhcnNlZFVSTCk7XG5cdH1cblxuXHRpZiAoIWhlYWRlcnMuaGFzKCdDb25uZWN0aW9uJykgJiYgIWFnZW50KSB7XG5cdFx0aGVhZGVycy5zZXQoJ0Nvbm5lY3Rpb24nLCAnY2xvc2UnKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDQuMlxuXHQvLyBjaHVua2VkIGVuY29kaW5nIGlzIGhhbmRsZWQgYnkgTm9kZS5qc1xuXG5cdGNvbnN0IHNlYXJjaCA9IGdldFNlYXJjaChwYXJzZWRVUkwpO1xuXG5cdC8vIFBhc3MgdGhlIGZ1bGwgVVJMIGRpcmVjdGx5IHRvIHJlcXVlc3QoKSwgYnV0IG92ZXJ3cml0ZSB0aGUgZm9sbG93aW5nXG5cdC8vIG9wdGlvbnM6XG5cdGNvbnN0IG9wdGlvbnMgPSB7XG5cdFx0Ly8gT3ZlcndyaXRlIHNlYXJjaCB0byByZXRhaW4gdHJhaWxpbmcgPyAoaXNzdWUgIzc3Nilcblx0XHRwYXRoOiBwYXJzZWRVUkwucGF0aG5hbWUgKyBzZWFyY2gsXG5cdFx0Ly8gVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBub3QgZXhwcmVzc2VkIGluIHRoZSBVUkxcblx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuXHRcdGhlYWRlcnM6IGhlYWRlcnNbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSxcblx0XHRpbnNlY3VyZUhUVFBQYXJzZXI6IHJlcXVlc3QuaW5zZWN1cmVIVFRQUGFyc2VyLFxuXHRcdGFnZW50XG5cdH07XG5cblx0cmV0dXJuIHtcblx0XHQvKiogQHR5cGUge1VSTH0gKi9cblx0XHRwYXJzZWRVUkwsXG5cdFx0b3B0aW9uc1xuXHR9O1xufTtcblxuLyoqXG4gKiBBYm9ydEVycm9yIGludGVyZmFjZSBmb3IgY2FuY2VsbGVkIHJlcXVlc3RzXG4gKi9cbmNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBGZXRjaEJhc2VFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHR5cGUgPSAnYWJvcnRlZCcpIHtcblx0XHRzdXBlcihtZXNzYWdlLCB0eXBlKTtcblx0fVxufVxuXG4vKiEgbm9kZS1kb21leGNlcHRpb24uIE1JVCBMaWNlbnNlLiBKaW1teSBXw6RydGluZyA8aHR0cHM6Ly9qaW1teS53YXJ0aW5nLnNlL29wZW5zb3VyY2U+ICovXG5cbmlmICghZ2xvYmFsVGhpcy5ET01FeGNlcHRpb24pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IE1lc3NhZ2VDaGFubmVsIH0gPSByZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpLFxuICAgIHBvcnQgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MSxcbiAgICBhYiA9IG5ldyBBcnJheUJ1ZmZlcigpO1xuICAgIHBvcnQucG9zdE1lc3NhZ2UoYWIsIFthYiwgYWJdKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdET01FeGNlcHRpb24nICYmIChcbiAgICAgIGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uID0gZXJyLmNvbnN0cnVjdG9yXG4gICAgKTtcbiAgfVxufVxuXG52YXIgbm9kZURvbWV4Y2VwdGlvbiA9IGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uO1xuXG4vKipcbiAqIEluZGV4LmpzXG4gKlxuICogYSByZXF1ZXN0IEFQSSBjb21wYXRpYmxlIHdpdGggd2luZG93LmZldGNoXG4gKlxuICogQWxsIHNwZWMgYWxnb3JpdGhtIHN0ZXAgbnVtYmVycyBhcmUgYmFzZWQgb24gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvY29tbWl0LXNuYXBzaG90cy9hZTcxNjgyMmNiM2E2MTg0MzIyNmNkMDkwZWVmYzY1ODk0NDZjMWQyLy5cbiAqL1xuXG5jb25zdCBzdXBwb3J0ZWRTY2hlbWFzID0gbmV3IFNldChbJ2RhdGE6JywgJ2h0dHA6JywgJ2h0dHBzOiddKTtcblxuLyoqXG4gKiBGZXRjaCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmcgfCBVUkwgfCBpbXBvcnQoJy4vcmVxdWVzdCcpLmRlZmF1bHR9IHVybCAtIEFic29sdXRlIHVybCBvciBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcGFyYW0gICB7Kn0gW29wdGlvbnNfXSAtIEZldGNoIG9wdGlvbnNcbiAqIEByZXR1cm4gIHtQcm9taXNlPGltcG9ydCgnLi9yZXNwb25zZScpLmRlZmF1bHQ+fVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaCh1cmwsIG9wdGlvbnNfKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0Ly8gQnVpbGQgcmVxdWVzdCBvYmplY3Rcblx0XHRjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCBvcHRpb25zXyk7XG5cdFx0Y29uc3Qge3BhcnNlZFVSTCwgb3B0aW9uc30gPSBnZXROb2RlUmVxdWVzdE9wdGlvbnMocmVxdWVzdCk7XG5cdFx0aWYgKCFzdXBwb3J0ZWRTY2hlbWFzLmhhcyhwYXJzZWRVUkwucHJvdG9jb2wpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBub2RlLWZldGNoIGNhbm5vdCBsb2FkICR7dXJsfS4gVVJMIHNjaGVtZSBcIiR7cGFyc2VkVVJMLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpfVwiIGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG5cdFx0fVxuXG5cdFx0aWYgKHBhcnNlZFVSTC5wcm90b2NvbCA9PT0gJ2RhdGE6Jykge1xuXHRcdFx0Y29uc3QgZGF0YSA9IGRhdGFVcmlUb0J1ZmZlcihyZXF1ZXN0LnVybCk7XG5cdFx0XHRjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShkYXRhLCB7aGVhZGVyczogeydDb250ZW50LVR5cGUnOiBkYXRhLnR5cGVGdWxsfX0pO1xuXHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gV3JhcCBodHRwLnJlcXVlc3QgaW50byBmZXRjaFxuXHRcdGNvbnN0IHNlbmQgPSAocGFyc2VkVVJMLnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzIDogaHR0cCkucmVxdWVzdDtcblx0XHRjb25zdCB7c2lnbmFsfSA9IHJlcXVlc3Q7XG5cdFx0bGV0IHJlc3BvbnNlID0gbnVsbDtcblxuXHRcdGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgQWJvcnRFcnJvcignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nKTtcblx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRpZiAocmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIFN0cmVhbS5SZWFkYWJsZSkge1xuXHRcdFx0XHRyZXF1ZXN0LmJvZHkuZGVzdHJveShlcnJvcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghcmVzcG9uc2UgfHwgIXJlc3BvbnNlLmJvZHkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZS5ib2R5LmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXHRcdH07XG5cblx0XHRpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0XHRhYm9ydCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGFib3J0QW5kRmluYWxpemUgPSAoKSA9PiB7XG5cdFx0XHRhYm9ydCgpO1xuXHRcdFx0ZmluYWxpemUoKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2VuZCByZXF1ZXN0XG5cdFx0Y29uc3QgcmVxdWVzdF8gPSBzZW5kKHBhcnNlZFVSTC50b1N0cmluZygpLCBvcHRpb25zKTtcblxuXHRcdGlmIChzaWduYWwpIHtcblx0XHRcdHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZpbmFsaXplID0gKCkgPT4ge1xuXHRcdFx0cmVxdWVzdF8uYWJvcnQoKTtcblx0XHRcdGlmIChzaWduYWwpIHtcblx0XHRcdFx0c2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJlcXVlc3RfLm9uKCdlcnJvcicsIGVycm9yID0+IHtcblx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgcmVxdWVzdCB0byAke3JlcXVlc3QudXJsfSBmYWlsZWQsIHJlYXNvbjogJHtlcnJvci5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlcnJvcikpO1xuXHRcdFx0ZmluYWxpemUoKTtcblx0XHR9KTtcblxuXHRcdGZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nKHJlcXVlc3RfLCBlcnJvciA9PiB7XG5cdFx0XHRpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYm9keSkge1xuXHRcdFx0XHRyZXNwb25zZS5ib2R5LmRlc3Ryb3koZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0LyogYzggaWdub3JlIG5leHQgMTggKi9cblx0XHRpZiAocHJvY2Vzcy52ZXJzaW9uIDwgJ3YxNCcpIHtcblx0XHRcdC8vIEJlZm9yZSBOb2RlLmpzIDE0LCBwaXBlbGluZSgpIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgYXN5bmMgaXRlcmF0b3JzIGFuZCBkb2VzIG5vdCBhbHdheXNcblx0XHRcdC8vIHByb3Blcmx5IGhhbmRsZSB3aGVuIHRoZSBzb2NrZXQgY2xvc2UvZW5kIGV2ZW50cyBhcmUgb3V0IG9mIG9yZGVyLlxuXHRcdFx0cmVxdWVzdF8ub24oJ3NvY2tldCcsIHMgPT4ge1xuXHRcdFx0XHRsZXQgZW5kZWRXaXRoRXZlbnRzQ291bnQ7XG5cdFx0XHRcdHMucHJlcGVuZExpc3RlbmVyKCdlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdFx0ZW5kZWRXaXRoRXZlbnRzQ291bnQgPSBzLl9ldmVudHNDb3VudDtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHMucHJlcGVuZExpc3RlbmVyKCdjbG9zZScsIGhhZEVycm9yID0+IHtcblx0XHRcdFx0XHQvLyBpZiBlbmQgaGFwcGVuZWQgYmVmb3JlIGNsb3NlIGJ1dCB0aGUgc29ja2V0IGRpZG4ndCBlbWl0IGFuIGVycm9yLCBkbyBpdCBub3dcblx0XHRcdFx0XHRpZiAocmVzcG9uc2UgJiYgZW5kZWRXaXRoRXZlbnRzQ291bnQgPCBzLl9ldmVudHNDb3VudCAmJiAhaGFkRXJyb3IpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdQcmVtYXR1cmUgY2xvc2UnKTtcblx0XHRcdFx0XHRcdGVycm9yLmNvZGUgPSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnO1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UuYm9keS5lbWl0KCdlcnJvcicsIGVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmVxdWVzdF8ub24oJ3Jlc3BvbnNlJywgcmVzcG9uc2VfID0+IHtcblx0XHRcdHJlcXVlc3RfLnNldFRpbWVvdXQoMCk7XG5cdFx0XHRjb25zdCBoZWFkZXJzID0gZnJvbVJhd0hlYWRlcnMocmVzcG9uc2VfLnJhd0hlYWRlcnMpO1xuXG5cdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNVxuXHRcdFx0aWYgKGlzUmVkaXJlY3QocmVzcG9uc2VfLnN0YXR1c0NvZGUpKSB7XG5cdFx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1LjJcblx0XHRcdFx0Y29uc3QgbG9jYXRpb24gPSBoZWFkZXJzLmdldCgnTG9jYXRpb24nKTtcblxuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS4zXG5cdFx0XHRcdGxldCBsb2NhdGlvblVSTCA9IG51bGw7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0bG9jYXRpb25VUkwgPSBsb2NhdGlvbiA9PT0gbnVsbCA/IG51bGwgOiBuZXcgVVJMKGxvY2F0aW9uLCByZXF1ZXN0LnVybCk7XG5cdFx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRcdC8vIGVycm9yIGhlcmUgY2FuIG9ubHkgYmUgaW52YWxpZCBVUkwgaW4gTG9jYXRpb246IGhlYWRlclxuXHRcdFx0XHRcdC8vIGRvIG5vdCB0aHJvdyB3aGVuIG9wdGlvbnMucmVkaXJlY3QgPT0gbWFudWFsXG5cdFx0XHRcdFx0Ly8gbGV0IHRoZSB1c2VyIGV4dHJhY3QgdGhlIGVycm9ybmVvdXMgcmVkaXJlY3QgVVJMXG5cdFx0XHRcdFx0aWYgKHJlcXVlc3QucmVkaXJlY3QgIT09ICdtYW51YWwnKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYHVyaSByZXF1ZXN0ZWQgcmVzcG9uZHMgd2l0aCBhbiBpbnZhbGlkIHJlZGlyZWN0IFVSTDogJHtsb2NhdGlvbn1gLCAnaW52YWxpZC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuNVxuXHRcdFx0XHRzd2l0Y2ggKHJlcXVlc3QucmVkaXJlY3QpIHtcblx0XHRcdFx0XHRjYXNlICdlcnJvcic6XG5cdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYHVyaSByZXF1ZXN0ZWQgcmVzcG9uZHMgd2l0aCBhIHJlZGlyZWN0LCByZWRpcmVjdCBtb2RlIGlzIHNldCB0byBlcnJvcjogJHtyZXF1ZXN0LnVybH1gLCAnbm8tcmVkaXJlY3QnKSk7XG5cdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdGNhc2UgJ21hbnVhbCc6XG5cdFx0XHRcdFx0XHQvLyBOb3RoaW5nIHRvIGRvXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdmb2xsb3cnOiB7XG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMlxuXHRcdFx0XHRcdFx0aWYgKGxvY2F0aW9uVVJMID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgNVxuXHRcdFx0XHRcdFx0aWYgKHJlcXVlc3QuY291bnRlciA+PSByZXF1ZXN0LmZvbGxvdykge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYG1heGltdW0gcmVkaXJlY3QgcmVhY2hlZCBhdDogJHtyZXF1ZXN0LnVybH1gLCAnbWF4LXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCA2IChjb3VudGVyIGluY3JlbWVudClcblx0XHRcdFx0XHRcdC8vIENyZWF0ZSBhIG5ldyBSZXF1ZXN0IG9iamVjdC5cblx0XHRcdFx0XHRcdGNvbnN0IHJlcXVlc3RPcHRpb25zID0ge1xuXHRcdFx0XHRcdFx0XHRoZWFkZXJzOiBuZXcgSGVhZGVycyhyZXF1ZXN0LmhlYWRlcnMpLFxuXHRcdFx0XHRcdFx0XHRmb2xsb3c6IHJlcXVlc3QuZm9sbG93LFxuXHRcdFx0XHRcdFx0XHRjb3VudGVyOiByZXF1ZXN0LmNvdW50ZXIgKyAxLFxuXHRcdFx0XHRcdFx0XHRhZ2VudDogcmVxdWVzdC5hZ2VudCxcblx0XHRcdFx0XHRcdFx0Y29tcHJlc3M6IHJlcXVlc3QuY29tcHJlc3MsXG5cdFx0XHRcdFx0XHRcdG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG5cdFx0XHRcdFx0XHRcdGJvZHk6IGNsb25lKHJlcXVlc3QpLFxuXHRcdFx0XHRcdFx0XHRzaWduYWw6IHJlcXVlc3Quc2lnbmFsLFxuXHRcdFx0XHRcdFx0XHRzaXplOiByZXF1ZXN0LnNpemUsXG5cdFx0XHRcdFx0XHRcdHJlZmVycmVyOiByZXF1ZXN0LnJlZmVycmVyLFxuXHRcdFx0XHRcdFx0XHRyZWZlcnJlclBvbGljeTogcmVxdWVzdC5yZWZlcnJlclBvbGljeVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0Ly8gd2hlbiBmb3J3YXJkaW5nIHNlbnNpdGl2ZSBoZWFkZXJzIGxpa2UgXCJBdXRob3JpemF0aW9uXCIsXG5cdFx0XHRcdFx0XHQvLyBcIldXVy1BdXRoZW50aWNhdGVcIiwgYW5kIFwiQ29va2llXCIgdG8gdW50cnVzdGVkIHRhcmdldHMsXG5cdFx0XHRcdFx0XHQvLyBoZWFkZXJzIHdpbGwgYmUgaWdub3JlZCB3aGVuIGZvbGxvd2luZyBhIHJlZGlyZWN0IHRvIGEgZG9tYWluXG5cdFx0XHRcdFx0XHQvLyB0aGF0IGlzIG5vdCBhIHN1YmRvbWFpbiBtYXRjaCBvciBleGFjdCBtYXRjaCBvZiB0aGUgaW5pdGlhbCBkb21haW4uXG5cdFx0XHRcdFx0XHQvLyBGb3IgZXhhbXBsZSwgYSByZWRpcmVjdCBmcm9tIFwiZm9vLmNvbVwiIHRvIGVpdGhlciBcImZvby5jb21cIiBvciBcInN1Yi5mb28uY29tXCJcblx0XHRcdFx0XHRcdC8vIHdpbGwgZm9yd2FyZCB0aGUgc2Vuc2l0aXZlIGhlYWRlcnMsIGJ1dCBhIHJlZGlyZWN0IHRvIFwiYmFyLmNvbVwiIHdpbGwgbm90LlxuXHRcdFx0XHRcdFx0Ly8gaGVhZGVycyB3aWxsIGFsc28gYmUgaWdub3JlZCB3aGVuIGZvbGxvd2luZyBhIHJlZGlyZWN0IHRvIGEgZG9tYWluIHVzaW5nXG5cdFx0XHRcdFx0XHQvLyBhIGRpZmZlcmVudCBwcm90b2NvbC4gRm9yIGV4YW1wbGUsIGEgcmVkaXJlY3QgZnJvbSBcImh0dHBzOi8vZm9vLmNvbVwiIHRvIFwiaHR0cDovL2Zvby5jb21cIlxuXHRcdFx0XHRcdFx0Ly8gd2lsbCBub3QgZm9yd2FyZCB0aGUgc2Vuc2l0aXZlIGhlYWRlcnNcblx0XHRcdFx0XHRcdGlmICghaXNEb21haW5PclN1YmRvbWFpbihyZXF1ZXN0LnVybCwgbG9jYXRpb25VUkwpIHx8ICFpc1NhbWVQcm90b2NvbChyZXF1ZXN0LnVybCwgbG9jYXRpb25VUkwpKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoY29uc3QgbmFtZSBvZiBbJ2F1dGhvcml6YXRpb24nLCAnd3d3LWF1dGhlbnRpY2F0ZScsICdjb29raWUnLCAnY29va2llMiddKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuaGVhZGVycy5kZWxldGUobmFtZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDlcblx0XHRcdFx0XHRcdGlmIChyZXNwb25zZV8uc3RhdHVzQ29kZSAhPT0gMzAzICYmIHJlcXVlc3QuYm9keSAmJiBvcHRpb25zXy5ib2R5IGluc3RhbmNlb2YgU3RyZWFtLlJlYWRhYmxlKSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcignQ2Fubm90IGZvbGxvdyByZWRpcmVjdCB3aXRoIGJvZHkgYmVpbmcgYSByZWFkYWJsZSBzdHJlYW0nLCAndW5zdXBwb3J0ZWQtcmVkaXJlY3QnKSk7XG5cdFx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDExXG5cdFx0XHRcdFx0XHRpZiAocmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDMwMyB8fCAoKHJlc3BvbnNlXy5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDMwMikgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdQT1NUJykpIHtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRpb25zLmJvZHkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRpb25zLmhlYWRlcnMuZGVsZXRlKCdjb250ZW50LWxlbmd0aCcpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMTRcblx0XHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlUmVmZXJyZXJQb2xpY3kgPSBwYXJzZVJlZmVycmVyUG9saWN5RnJvbUhlYWRlcihoZWFkZXJzKTtcblx0XHRcdFx0XHRcdGlmIChyZXNwb25zZVJlZmVycmVyUG9saWN5KSB7XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRpb25zLnJlZmVycmVyUG9saWN5ID0gcmVzcG9uc2VSZWZlcnJlclBvbGljeTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDE1XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGZldGNoKG5ldyBSZXF1ZXN0KGxvY2F0aW9uVVJMLCByZXF1ZXN0T3B0aW9ucykpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcihgUmVkaXJlY3Qgb3B0aW9uICcke3JlcXVlc3QucmVkaXJlY3R9JyBpcyBub3QgYSB2YWxpZCB2YWx1ZSBvZiBSZXF1ZXN0UmVkaXJlY3RgKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUHJlcGFyZSByZXNwb25zZVxuXHRcdFx0aWYgKHNpZ25hbCkge1xuXHRcdFx0XHRyZXNwb25zZV8ub25jZSgnZW5kJywgKCkgPT4ge1xuXHRcdFx0XHRcdHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGJvZHkgPSBTdHJlYW0ucGlwZWxpbmUocmVzcG9uc2VfLCBuZXcgU3RyZWFtLlBhc3NUaHJvdWdoKCksIGVycm9yID0+IHtcblx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMjkzNzZcblx0XHRcdC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cblx0XHRcdGlmIChwcm9jZXNzLnZlcnNpb24gPCAndjEyLjEwJykge1xuXHRcdFx0XHRyZXNwb25zZV8ub24oJ2Fib3J0ZWQnLCBhYm9ydEFuZEZpbmFsaXplKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmVzcG9uc2VPcHRpb25zID0ge1xuXHRcdFx0XHR1cmw6IHJlcXVlc3QudXJsLFxuXHRcdFx0XHRzdGF0dXM6IHJlc3BvbnNlXy5zdGF0dXNDb2RlLFxuXHRcdFx0XHRzdGF0dXNUZXh0OiByZXNwb25zZV8uc3RhdHVzTWVzc2FnZSxcblx0XHRcdFx0aGVhZGVycyxcblx0XHRcdFx0c2l6ZTogcmVxdWVzdC5zaXplLFxuXHRcdFx0XHRjb3VudGVyOiByZXF1ZXN0LmNvdW50ZXIsXG5cdFx0XHRcdGhpZ2hXYXRlck1hcms6IHJlcXVlc3QuaGlnaFdhdGVyTWFya1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgMTIuMS4xLjNcblx0XHRcdGNvbnN0IGNvZGluZ3MgPSBoZWFkZXJzLmdldCgnQ29udGVudC1FbmNvZGluZycpO1xuXG5cdFx0XHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCAxMi4xLjEuNDogaGFuZGxlIGNvbnRlbnQgY29kaW5nc1xuXG5cdFx0XHQvLyBpbiBmb2xsb3dpbmcgc2NlbmFyaW9zIHdlIGlnbm9yZSBjb21wcmVzc2lvbiBzdXBwb3J0XG5cdFx0XHQvLyAxLiBjb21wcmVzc2lvbiBzdXBwb3J0IGlzIGRpc2FibGVkXG5cdFx0XHQvLyAyLiBIRUFEIHJlcXVlc3Rcblx0XHRcdC8vIDMuIG5vIENvbnRlbnQtRW5jb2RpbmcgaGVhZGVyXG5cdFx0XHQvLyA0LiBubyBjb250ZW50IHJlc3BvbnNlICgyMDQpXG5cdFx0XHQvLyA1LiBjb250ZW50IG5vdCBtb2RpZmllZCByZXNwb25zZSAoMzA0KVxuXHRcdFx0aWYgKCFyZXF1ZXN0LmNvbXByZXNzIHx8IHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcgfHwgY29kaW5ncyA9PT0gbnVsbCB8fCByZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMjA0IHx8IHJlc3BvbnNlXy5zdGF0dXNDb2RlID09PSAzMDQpIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIE5vZGUgdjYrXG5cdFx0XHQvLyBCZSBsZXNzIHN0cmljdCB3aGVuIGRlY29kaW5nIGNvbXByZXNzZWQgcmVzcG9uc2VzLCBzaW5jZSBzb21ldGltZXNcblx0XHRcdC8vIHNlcnZlcnMgc2VuZCBzbGlnaHRseSBpbnZhbGlkIHJlc3BvbnNlcyB0aGF0IGFyZSBzdGlsbCBhY2NlcHRlZFxuXHRcdFx0Ly8gYnkgY29tbW9uIGJyb3dzZXJzLlxuXHRcdFx0Ly8gQWx3YXlzIHVzaW5nIFpfU1lOQ19GTFVTSCBpcyB3aGF0IGNVUkwgZG9lcy5cblx0XHRcdGNvbnN0IHpsaWJPcHRpb25zID0ge1xuXHRcdFx0XHRmbHVzaDogemxpYi5aX1NZTkNfRkxVU0gsXG5cdFx0XHRcdGZpbmlzaEZsdXNoOiB6bGliLlpfU1lOQ19GTFVTSFxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gRm9yIGd6aXBcblx0XHRcdGlmIChjb2RpbmdzID09PSAnZ3ppcCcgfHwgY29kaW5ncyA9PT0gJ3gtZ3ppcCcpIHtcblx0XHRcdFx0Ym9keSA9IFN0cmVhbS5waXBlbGluZShib2R5LCB6bGliLmNyZWF0ZUd1bnppcCh6bGliT3B0aW9ucyksIGVycm9yID0+IHtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIGRlZmxhdGVcblx0XHRcdGlmIChjb2RpbmdzID09PSAnZGVmbGF0ZScgfHwgY29kaW5ncyA9PT0gJ3gtZGVmbGF0ZScpIHtcblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBpbmZhbW91cyByYXcgZGVmbGF0ZSByZXNwb25zZSBmcm9tIG9sZCBzZXJ2ZXJzXG5cdFx0XHRcdC8vIGEgaGFjayBmb3Igb2xkIElJUyBhbmQgQXBhY2hlIHNlcnZlcnNcblx0XHRcdFx0Y29uc3QgcmF3ID0gU3RyZWFtLnBpcGVsaW5lKHJlc3BvbnNlXywgbmV3IFN0cmVhbS5QYXNzVGhyb3VnaCgpLCBlcnJvciA9PiB7XG5cdFx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJhdy5vbmNlKCdkYXRhJywgY2h1bmsgPT4ge1xuXHRcdFx0XHRcdC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM3NTE5ODI4XG5cdFx0XHRcdFx0aWYgKChjaHVua1swXSAmIDB4MEYpID09PSAweDA4KSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gU3RyZWFtLnBpcGVsaW5lKGJvZHksIHpsaWIuY3JlYXRlSW5mbGF0ZSgpLCBlcnJvciA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gU3RyZWFtLnBpcGVsaW5lKGJvZHksIHpsaWIuY3JlYXRlSW5mbGF0ZVJhdygpLCBlcnJvciA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyYXcub25jZSgnZW5kJywgKCkgPT4ge1xuXHRcdFx0XHRcdC8vIFNvbWUgb2xkIElJUyBzZXJ2ZXJzIHJldHVybiB6ZXJvLWxlbmd0aCBPSyBkZWZsYXRlIHJlc3BvbnNlcywgc29cblx0XHRcdFx0XHQvLyAnZGF0YScgaXMgbmV2ZXIgZW1pdHRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvcHVsbC85MDNcblx0XHRcdFx0XHRpZiAoIXJlc3BvbnNlKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZU9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgYnJcblx0XHRcdGlmIChjb2RpbmdzID09PSAnYnInKSB7XG5cdFx0XHRcdGJvZHkgPSBTdHJlYW0ucGlwZWxpbmUoYm9keSwgemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKCksIGVycm9yID0+IHtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCB1c2UgcmVzcG9uc2UgYXMtaXNcblx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHR9KTtcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG5cdFx0d3JpdGVUb1N0cmVhbShyZXF1ZXN0XywgcmVxdWVzdCkuY2F0Y2gocmVqZWN0KTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nKHJlcXVlc3QsIGVycm9yQ2FsbGJhY2spIHtcblx0Y29uc3QgTEFTVF9DSFVOSyA9IG5vZGVfYnVmZmVyLkJ1ZmZlci5mcm9tKCcwXFxyXFxuXFxyXFxuJyk7XG5cblx0bGV0IGlzQ2h1bmtlZFRyYW5zZmVyID0gZmFsc2U7XG5cdGxldCBwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCA9IGZhbHNlO1xuXHRsZXQgcHJldmlvdXNDaHVuaztcblxuXHRyZXF1ZXN0Lm9uKCdyZXNwb25zZScsIHJlc3BvbnNlID0+IHtcblx0XHRjb25zdCB7aGVhZGVyc30gPSByZXNwb25zZTtcblx0XHRpc0NodW5rZWRUcmFuc2ZlciA9IGhlYWRlcnNbJ3RyYW5zZmVyLWVuY29kaW5nJ10gPT09ICdjaHVua2VkJyAmJiAhaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcblx0fSk7XG5cblx0cmVxdWVzdC5vbignc29ja2V0Jywgc29ja2V0ID0+IHtcblx0XHRjb25zdCBvblNvY2tldENsb3NlID0gKCkgPT4ge1xuXHRcdFx0aWYgKGlzQ2h1bmtlZFRyYW5zZmVyICYmICFwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCkge1xuXHRcdFx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJyk7XG5cdFx0XHRcdGVycm9yLmNvZGUgPSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrKGVycm9yKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qgb25EYXRhID0gYnVmID0+IHtcblx0XHRcdHByb3Blckxhc3RDaHVua1JlY2VpdmVkID0gbm9kZV9idWZmZXIuQnVmZmVyLmNvbXBhcmUoYnVmLnNsaWNlKC01KSwgTEFTVF9DSFVOSykgPT09IDA7XG5cblx0XHRcdC8vIFNvbWV0aW1lcyBmaW5hbCAwLWxlbmd0aCBjaHVuayBhbmQgZW5kIG9mIG1lc3NhZ2UgY29kZSBhcmUgaW4gc2VwYXJhdGUgcGFja2V0c1xuXHRcdFx0aWYgKCFwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCAmJiBwcmV2aW91c0NodW5rKSB7XG5cdFx0XHRcdHByb3Blckxhc3RDaHVua1JlY2VpdmVkID0gKFxuXHRcdFx0XHRcdG5vZGVfYnVmZmVyLkJ1ZmZlci5jb21wYXJlKHByZXZpb3VzQ2h1bmsuc2xpY2UoLTMpLCBMQVNUX0NIVU5LLnNsaWNlKDAsIDMpKSA9PT0gMCAmJlxuXHRcdFx0XHRcdG5vZGVfYnVmZmVyLkJ1ZmZlci5jb21wYXJlKGJ1Zi5zbGljZSgtMiksIExBU1RfQ0hVTksuc2xpY2UoMykpID09PSAwXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHByZXZpb3VzQ2h1bmsgPSBidWY7XG5cdFx0fTtcblxuXHRcdHNvY2tldC5wcmVwZW5kTGlzdGVuZXIoJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSk7XG5cdFx0c29ja2V0Lm9uKCdkYXRhJywgb25EYXRhKTtcblxuXHRcdHJlcXVlc3Qub24oJ2Nsb3NlJywgKCkgPT4ge1xuXHRcdFx0c29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpO1xuXHRcdFx0c29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKTtcblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQGF1dGhvciBUb3J1IE5hZ2FzaGltYSA8aHR0cHM6Ly9naXRodWIuY29tL215c3RpY2F0ZWE+XG4gKiBAY29weXJpZ2h0IDIwMTUgVG9ydSBOYWdhc2hpbWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTZWUgTElDRU5TRSBmaWxlIGluIHJvb3QgZGlyZWN0b3J5IGZvciBmdWxsIGxpY2Vuc2UuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gUHJpdmF0ZURhdGFcbiAqIEBwcm9wZXJ0eSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQuXG4gKiBAcHJvcGVydHkge3t0eXBlOnN0cmluZ319IGV2ZW50IFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnRQaGFzZSBUaGUgY3VycmVudCBldmVudCBwaGFzZS5cbiAqIEBwcm9wZXJ0eSB7RXZlbnRUYXJnZXR8bnVsbH0gY3VycmVudFRhcmdldCBUaGUgY3VycmVudCBldmVudCB0YXJnZXQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbmNlbGVkIFRoZSBmbGFnIHRvIHByZXZlbnQgZGVmYXVsdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3RvcHBlZCBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBpbW1lZGlhdGVTdG9wcGVkIFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24gaW1tZWRpYXRlbHkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufG51bGx9IHBhc3NpdmVMaXN0ZW5lciBUaGUgbGlzdGVuZXIgaWYgdGhlIGN1cnJlbnQgbGlzdGVuZXIgaXMgcGFzc2l2ZS4gT3RoZXJ3aXNlIHRoaXMgaXMgbnVsbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lU3RhbXAgVGhlIHVuaXggdGltZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBQcml2YXRlIGRhdGEgZm9yIGV2ZW50IHdyYXBwZXJzLlxuICogQHR5cGUge1dlYWtNYXA8RXZlbnQsIFByaXZhdGVEYXRhPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBDYWNoZSBmb3Igd3JhcHBlciBjbGFzc2VzLlxuICogQHR5cGUge1dlYWtNYXA8T2JqZWN0LCBGdW5jdGlvbj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3cmFwcGVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogR2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCBvYmplY3QgdG8gZ2V0IHByaXZhdGUgZGF0YS5cbiAqIEByZXR1cm5zIHtQcml2YXRlRGF0YX0gVGhlIHByaXZhdGUgZGF0YSBvZiB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwZChldmVudCkge1xuICAgIGNvbnN0IHJldHYgPSBwcml2YXRlRGF0YS5nZXQoZXZlbnQpO1xuICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICByZXR2ICE9IG51bGwsXG4gICAgICAgIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50IG9iamVjdCwgYnV0IGdvdFwiLFxuICAgICAgICBldmVudFxuICAgICk7XG4gICAgcmV0dXJuIHJldHZcbn1cblxuLyoqXG4gKiBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI3NldC10aGUtY2FuY2VsZWQtZmxhZ1xuICogQHBhcmFtIGRhdGEge1ByaXZhdGVEYXRhfSBwcml2YXRlIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHNldENhbmNlbEZsYWcoZGF0YSkge1xuICAgIGlmIChkYXRhLnBhc3NpdmVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlVuYWJsZSB0byBwcmV2ZW50RGVmYXVsdCBpbnNpZGUgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBpbnZvY2F0aW9uLlwiLFxuICAgICAgICAgICAgICAgIGRhdGEucGFzc2l2ZUxpc3RlbmVyXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIWRhdGEuZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBkYXRhLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQucHJldmVudERlZmF1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbi8qKlxuICogVGhlIGV2ZW50IHdyYXBwZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2YgdGhpcyBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50IHRvIHdyYXAuXG4gKi9cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIHByaXZhdGVEYXRhLnNldCh0aGlzLCB7XG4gICAgICAgIGV2ZW50VGFyZ2V0LFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnRQaGFzZTogMixcbiAgICAgICAgY3VycmVudFRhcmdldDogZXZlbnRUYXJnZXQsXG4gICAgICAgIGNhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAgc3RvcHBlZDogZmFsc2UsXG4gICAgICAgIGltbWVkaWF0ZVN0b3BwZWQ6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlTGlzdGVuZXI6IG51bGwsXG4gICAgICAgIHRpbWVTdGFtcDogZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCksXG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNVbmZvcmdlYWJsZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzVHJ1c3RlZFwiLCB7IHZhbHVlOiBmYWxzZSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnNcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIShrZXkgaW4gdGhpcykpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gU2hvdWxkIGJlIGVudW1lcmFibGUsIGJ1dCBjbGFzcyBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZS5cbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudC50eXBlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAgZ2V0IHRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jdXJyZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtFdmVudFRhcmdldFtdfSBUaGUgY29tcG9zZWQgcGF0aCBvZiB0aGlzIGV2ZW50LlxuICAgICAqL1xuICAgIGNvbXBvc2VkUGF0aCgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRhcmdldCA9IHBkKHRoaXMpLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3VycmVudFRhcmdldF1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgb2YgTk9ORS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBOT05FKCkge1xuICAgICAgICByZXR1cm4gMFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBDQVBUVVJJTkdfUEhBU0UuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQ0FQVFVSSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBBVF9UQVJHRVQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQVRfVEFSR0VUKCkge1xuICAgICAgICByZXR1cm4gMlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBCVUJCTElOR19QSEFTRS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBCVUJCTElOR19QSEFTRSgpIHtcbiAgICAgICAgcmV0dXJuIDNcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGV2ZW50UGhhc2UoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFBoYXNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcyk7XG5cbiAgICAgICAgZGF0YS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcyk7XG5cbiAgICAgICAgZGF0YS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YS5pbW1lZGlhdGVTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGJ1YmJsaW5nLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBidWJibGVzKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5idWJibGVzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBjYW5jZWxhYmxlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjYW5jZWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5jYW5jZWxhYmxlKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgdGhpcyBldmVudC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgc2V0Q2FuY2VsRmxhZyhwZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGluZGljYXRlIGNhbmNlbGxhdGlvbiBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgZGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmNhbmNlbGVkXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGNvbXBvc2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjb21wb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuY29tcG9zZWQpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB1bml4IHRpbWUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB0aW1lU3RhbXAoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS50aW1lU3RhbXBcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCBzcmNFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gc3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCBjYW5jZWxCdWJibGUoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5zdG9wcGVkXG4gICAgfSxcbiAgICBzZXQgY2FuY2VsQnViYmxlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKTtcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuY2FuY2VsQnViYmxlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgZGF0YS5ldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGluZGljYXRlIGNhbmNlbGxhdGlvbiBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCByZXR1cm5WYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuICFwZCh0aGlzKS5jYW5jZWxlZFxuICAgIH0sXG4gICAgc2V0IHJldHVyblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHNldENhbmNlbEZsYWcocGQodGhpcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhpcyBldmVudCBvYmplY3QuIEJ1dCBkbyBub3RoaW5nIHVuZGVyIGV2ZW50IGRpc3BhdGNoaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIFRoZSBmbGFnIHRvIGJlIHBvc3NpYmxlIHRvIGJ1YmJsZSB1cC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjYW5jZWxhYmxlPWZhbHNlXSBUaGUgZmxhZyB0byBiZSBwb3NzaWJsZSB0byBjYW5jZWwuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBpbml0RXZlbnQoKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfSxcbn07XG5cbi8vIGBjb25zdHJ1Y3RvcmAgaXMgbm90IGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHtcbiAgICB2YWx1ZTogRXZlbnQsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxufSk7XG5cbi8vIEVuc3VyZSBgZXZlbnQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnRgIGlzIGB0cnVlYC5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnQucHJvdG90eXBlLCB3aW5kb3cuRXZlbnQucHJvdG90eXBlKTtcblxuICAgIC8vIE1ha2UgYXNzb2NpYXRpb24gZm9yIHdyYXBwZXJzLlxuICAgIHdyYXBwZXJzLnNldCh3aW5kb3cuRXZlbnQucHJvdG90eXBlLCBFdmVudCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIHJlZGlyZWN0IGEgZ2l2ZW4gcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWUgdG8gZGVmaW5lIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byByZWRpcmVjdCB0aGUgcHJvcGVydHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3Ioa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50W2tleV1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICBwZCh0aGlzKS5ldmVudFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGNhbGwgYSBnaXZlbiBtZXRob2QgcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWUgdG8gZGVmaW5lIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byBjYWxsIHRoZSBtZXRob2QgcHJvcGVydHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVDYWxsRGVzY3JpcHRvcihrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gcGQodGhpcykuZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRba2V5XS5hcHBseShldmVudCwgYXJndW1lbnRzKVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBuZXcgd3JhcHBlciBjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IEJhc2VFdmVudCBUaGUgYmFzZSB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBwcm90b3R5cGUgb2YgdGhlIG9yaWdpbmFsIGV2ZW50LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgZGVmaW5lZCB3cmFwcGVyIGNsYXNzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lV3JhcHBlcihCYXNlRXZlbnQsIHByb3RvKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3RvKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJhc2VFdmVudFxuICAgIH1cblxuICAgIC8qKiBDdXN0b21FdmVudCAqL1xuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgICAgICBCYXNlRXZlbnQuY2FsbCh0aGlzLCBldmVudFRhcmdldCwgZXZlbnQpO1xuICAgIH1cblxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUV2ZW50LnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogQ3VzdG9tRXZlbnQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICB9KTtcblxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghKGtleSBpbiBCYXNlRXZlbnQucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGtleSk7XG4gICAgICAgICAgICBjb25zdCBpc0Z1bmMgPSB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgaXNGdW5jXG4gICAgICAgICAgICAgICAgICAgID8gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50XG59XG5cbi8qKlxuICogR2V0IHRoZSB3cmFwcGVyIGNsYXNzIG9mIGEgZ2l2ZW4gcHJvdG90eXBlLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBwcm90b3R5cGUgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIGdldCBpdHMgd3JhcHBlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIHdyYXBwZXIgY2xhc3MuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRXcmFwcGVyKHByb3RvKSB7XG4gICAgaWYgKHByb3RvID09IG51bGwgfHwgcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50XG4gICAgfVxuXG4gICAgbGV0IHdyYXBwZXIgPSB3cmFwcGVycy5nZXQocHJvdG8pO1xuICAgIGlmICh3cmFwcGVyID09IG51bGwpIHtcbiAgICAgICAgd3JhcHBlciA9IGRlZmluZVdyYXBwZXIoZ2V0V3JhcHBlcihPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pKSwgcHJvdG8pO1xuICAgICAgICB3cmFwcGVycy5zZXQocHJvdG8sIHdyYXBwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlclxufVxuXG4vKipcbiAqIFdyYXAgYSBnaXZlbiBldmVudCB0byBtYW5hZ2VtZW50IGEgZGlzcGF0Y2hpbmcuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoaXMgZGlzcGF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHRvIHdyYXAuXG4gKiBAcmV0dXJucyB7RXZlbnR9IFRoZSB3cmFwcGVyIGluc3RhbmNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIGNvbnN0IFdyYXBwZXIgPSBnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkpO1xuICAgIHJldHVybiBuZXcgV3JhcHBlcihldmVudFRhcmdldCwgZXZlbnQpXG59XG5cbi8qKlxuICogR2V0IHRoZSBpbW1lZGlhdGVTdG9wcGVkIGZsYWcgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGZsYWcgdG8gc3RvcCBwcm9wYWdhdGlvbiBpbW1lZGlhdGVseS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU3RvcHBlZChldmVudCkge1xuICAgIHJldHVybiBwZChldmVudCkuaW1tZWRpYXRlU3RvcHBlZFxufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCBldmVudCBwaGFzZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHNldCBjdXJyZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBldmVudFBoYXNlIE5ldyBldmVudCBwaGFzZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0RXZlbnRQaGFzZShldmVudCwgZXZlbnRQaGFzZSkge1xuICAgIHBkKGV2ZW50KS5ldmVudFBoYXNlID0gZXZlbnRQaGFzZTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgdGFyZ2V0IG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtFdmVudFRhcmdldHxudWxsfSBjdXJyZW50VGFyZ2V0IE5ldyBjdXJyZW50IHRhcmdldC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0Q3VycmVudFRhcmdldChldmVudCwgY3VycmVudFRhcmdldCkge1xuICAgIHBkKGV2ZW50KS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbn1cblxuLyoqXG4gKiBTZXQgYSBwYXNzaXZlIGxpc3RlbmVyIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgTmV3IHBhc3NpdmUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFBhc3NpdmVMaXN0ZW5lcihldmVudCwgcGFzc2l2ZUxpc3RlbmVyKSB7XG4gICAgcGQoZXZlbnQpLnBhc3NpdmVMaXN0ZW5lciA9IHBhc3NpdmVMaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBMaXN0ZW5lck5vZGVcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiBAcHJvcGVydHkgezF8MnwzfSBsaXN0ZW5lclR5cGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGFzc2l2ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBvbmNlXG4gKiBAcHJvcGVydHkge0xpc3RlbmVyTm9kZXxudWxsfSBuZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogQHR5cGUge1dlYWtNYXA8b2JqZWN0LCBNYXA8c3RyaW5nLCBMaXN0ZW5lck5vZGU+Pn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGxpc3RlbmVyc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIExpc3RlbmVyIHR5cGVzXG5jb25zdCBDQVBUVVJFID0gMTtcbmNvbnN0IEJVQkJMRSA9IDI7XG5jb25zdCBBVFRSSUJVVEUgPSAzO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3Qgb3Igbm90LlxuICogQHBhcmFtIHthbnl9IHggVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG59XG5cbi8qKlxuICogR2V0IGxpc3RlbmVycy5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgdG8gZ2V0LlxuICogQHJldHVybnMge01hcDxzdHJpbmcsIExpc3RlbmVyTm9kZT59IFRoZSBsaXN0ZW5lcnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZlbnRUYXJnZXQpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNNYXAuZ2V0KGV2ZW50VGFyZ2V0KTtcbiAgICBpZiAobGlzdGVuZXJzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50VGFyZ2V0IG9iamVjdCwgYnV0IGdvdCBhbm90aGVyIHZhbHVlLlwiXG4gICAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RlbmVyc1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgdGhlIGV2ZW50IGF0dHJpYnV0ZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBnZXQgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyVHlwZSA9PT0gQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmxpc3RlbmVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHNldChsaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiICYmICFpc09iamVjdChsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcblxuICAgICAgICAgICAgLy8gVHJhdmVyc2UgdG8gdGhlIHRhaWwgd2hpbGUgcmVtb3Zpbmcgb2xkIHZhbHVlLlxuICAgICAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXJUeXBlID09PSBBVFRSSUJVVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIG5ldyB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclR5cGU6IEFUVFJJQlVURSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ld05vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBhbiBldmVudCBhdHRyaWJ1dGUgKGUuZy4gYGV2ZW50VGFyZ2V0Lm9uY2xpY2tgKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFRhcmdldFByb3RvdHlwZSBUaGUgZXZlbnQgdGFyZ2V0IHByb3RvdHlwZSB0byBkZWZpbmUgYW4gZXZlbnQgYXR0cmJpdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGRlZmluZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZShldmVudFRhcmdldFByb3RvdHlwZSwgZXZlbnROYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICBldmVudFRhcmdldFByb3RvdHlwZSxcbiAgICAgICAgYG9uJHtldmVudE5hbWV9YCxcbiAgICAgICAgZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSlcbiAgICApO1xufVxuXG4vKipcbiAqIERlZmluZSBhIGN1c3RvbSBFdmVudFRhcmdldCB3aXRoIGV2ZW50IGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBldmVudE5hbWVzIEV2ZW50IG5hbWVzIGZvciBldmVudCBhdHRyaWJ1dGVzLlxuICogQHJldHVybnMge0V2ZW50VGFyZ2V0fSBUaGUgY3VzdG9tIEV2ZW50VGFyZ2V0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoZXZlbnROYW1lcykge1xuICAgIC8qKiBDdXN0b21FdmVudFRhcmdldCAqL1xuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50VGFyZ2V0KCkge1xuICAgICAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogQ3VzdG9tRXZlbnRUYXJnZXQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZShDdXN0b21FdmVudFRhcmdldC5wcm90b3R5cGUsIGV2ZW50TmFtZXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBDdXN0b21FdmVudFRhcmdldFxufVxuXG4vKipcbiAqIEV2ZW50VGFyZ2V0LlxuICpcbiAqIC0gVGhpcyBpcyBjb25zdHJ1Y3RvciBpZiBubyBhcmd1bWVudHMuXG4gKiAtIFRoaXMgaXMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgQ3VzdG9tRXZlbnRUYXJnZXQgY29uc3RydWN0b3IgaWYgdGhlcmUgYXJlIGFyZ3VtZW50cy5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgY2xhc3MgQSBleHRlbmRzIEV2ZW50VGFyZ2V0IHt9XG4gKiAgICAgY2xhc3MgQiBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiKSB7fVxuICogICAgIGNsYXNzIEMgZXh0ZW5kcyBFdmVudFRhcmdldChcIm1lc3NhZ2VcIiwgXCJlcnJvclwiKSB7fVxuICogICAgIGNsYXNzIEQgZXh0ZW5kcyBFdmVudFRhcmdldChbXCJtZXNzYWdlXCIsIFwiZXJyb3JcIl0pIHt9XG4gKi9cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIGxpc3RlbmVyc01hcC5zZXQodGhpcywgbmV3IE1hcCgpKTtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoYXJndW1lbnRzWzBdKVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0eXBlc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQodHlwZXMpXG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIilcbiAgICAvKmVzbGludC1lbmFibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbn1cblxuLy8gU2hvdWxkIGJlIGVudW1lcmFibGUsIGJ1dCBjbGFzcyBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZS5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBBZGQgYSBnaXZlbiBsaXN0ZW5lciB0byB0aGlzIGV2ZW50IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx7Y2FwdHVyZT86Ym9vbGVhbixwYXNzaXZlPzpib29sZWFuLG9uY2U/OmJvb2xlYW59fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoaXMgbGlzdGVuZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIgJiYgIWlzT2JqZWN0KGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidsaXN0ZW5lcicgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0LlwiKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBvcHRpb25zSXNPYmogPSBpc09iamVjdChvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IG9wdGlvbnNJc09ialxuICAgICAgICAgICAgPyBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSlcbiAgICAgICAgICAgIDogQm9vbGVhbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJUeXBlID0gY2FwdHVyZSA/IENBUFRVUkUgOiBCVUJCTEU7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgIGxpc3RlbmVyVHlwZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IG9wdGlvbnNJc09iaiAmJiBCb29sZWFuKG9wdGlvbnMucGFzc2l2ZSksXG4gICAgICAgICAgICBvbmNlOiBvcHRpb25zSXNPYmogJiYgQm9vbGVhbihvcHRpb25zLm9uY2UpLFxuICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTZXQgaXQgYXMgdGhlIGZpcnN0IG5vZGUgaWYgdGhlIGZpcnN0IG5vZGUgaXMgbnVsbC5cbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhdmVyc2UgdG8gdGhlIHRhaWwgd2hpbGUgY2hlY2tpbmcgZHVwbGljYXRpb24uLlxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJlxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXJUeXBlID09PSBsaXN0ZW5lclR5cGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBpZ25vcmUgZHVwbGljYXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgaXQuXG4gICAgICAgIHByZXYubmV4dCA9IG5ld05vZGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGdpdmVuIGxpc3RlbmVyIGZyb20gdGhpcyBldmVudCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58e2NhcHR1cmU/OmJvb2xlYW4scGFzc2l2ZT86Ym9vbGVhbixvbmNlPzpib29sZWFufX0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGlzIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBpc09iamVjdChvcHRpb25zKVxuICAgICAgICAgICAgPyBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSlcbiAgICAgICAgICAgIDogQm9vbGVhbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJUeXBlID0gY2FwdHVyZSA/IENBUFRVUkUgOiBCVUJCTEU7XG5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lclR5cGUgPT09IGxpc3RlbmVyVHlwZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhIGdpdmVuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIGV2ZW50IHRvIGRpc3BhdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgZmFsc2VgIGlmIGNhbmNlbGVkLlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50ID09IG51bGwgfHwgdHlwZW9mIGV2ZW50LnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXZlbnQudHlwZVwiIHNob3VsZCBiZSBhIHN0cmluZy4nKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbGlzdGVuZXJzIGFyZW4ndCByZWdpc3RlcmVkLCB0ZXJtaW5hdGUuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gZXZlbnQudHlwZTtcbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5jZSB3ZSBjYW5ub3QgcmV3cml0ZSBzZXZlcmFsIHByb3BlcnRpZXMsIHNvIHdyYXAgb2JqZWN0LlxuICAgICAgICBjb25zdCB3cmFwcGVkRXZlbnQgPSB3cmFwRXZlbnQodGhpcywgZXZlbnQpO1xuXG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBwcm9jZXNzIGNhcHR1cmluZyBwaGFzZSBhbmQgYnViYmxpbmcgcGhhc2UuXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgcGFydGljaXBhdGluZyBpbiBhIHRyZWUuXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgbGlzdGVuZXIgaWYgaXQncyBvbmNlXG4gICAgICAgICAgICBpZiAobm9kZS5vbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxsIHRoaXMgbGlzdGVuZXJcbiAgICAgICAgICAgIHNldFBhc3NpdmVMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICB3cmFwcGVkRXZlbnQsXG4gICAgICAgICAgICAgICAgbm9kZS5wYXNzaXZlID8gbm9kZS5saXN0ZW5lciA6IG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUubGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIuY2FsbCh0aGlzLCB3cmFwcGVkRXZlbnQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lclR5cGUgIT09IEFUVFJJQlVURSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlLmxpc3RlbmVyLmhhbmRsZUV2ZW50ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIuaGFuZGxlRXZlbnQod3JhcHBlZEV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQnJlYWsgaWYgYGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbmAgd2FzIGNhbGxlZC5cbiAgICAgICAgICAgIGlmIChpc1N0b3BwZWQod3JhcHBlZEV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UGFzc2l2ZUxpc3RlbmVyKHdyYXBwZWRFdmVudCwgbnVsbCk7XG4gICAgICAgIHNldEV2ZW50UGhhc2Uod3JhcHBlZEV2ZW50LCAwKTtcbiAgICAgICAgc2V0Q3VycmVudFRhcmdldCh3cmFwcGVkRXZlbnQsIG51bGwpO1xuXG4gICAgICAgIHJldHVybiAhd3JhcHBlZEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcbiAgICB9LFxufTtcblxuLy8gYGNvbnN0cnVjdG9yYCBpcyBub3QgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFRhcmdldC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwge1xuICAgIHZhbHVlOiBFdmVudFRhcmdldCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG59KTtcblxuLy8gRW5zdXJlIGBldmVudFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudFRhcmdldGAgaXMgYHRydWVgLlxuaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2Ygd2luZG93LkV2ZW50VGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiXG4pIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlKTtcbn1cblxuLyoqXG4gKiBAYXV0aG9yIFRvcnUgTmFnYXNoaW1hIDxodHRwczovL2dpdGh1Yi5jb20vbXlzdGljYXRlYT5cbiAqIFNlZSBMSUNFTlNFIGZpbGUgaW4gcm9vdCBkaXJlY3RvcnkgZm9yIGZ1bGwgbGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFRoZSBzaWduYWwgY2xhc3MuXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jYWJvcnRzaWduYWxcbiAqL1xuY2xhc3MgQWJvcnRTaWduYWwgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgLyoqXG4gICAgICogQWJvcnRTaWduYWwgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWJvcnRTaWduYWwgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGBBYm9ydFNpZ25hbGAncyBgQWJvcnRDb250cm9sbGVyYCBoYXMgc2lnbmFsZWQgdG8gYWJvcnQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgYWJvcnRlZCgpIHtcbiAgICAgICAgY29uc3QgYWJvcnRlZCA9IGFib3J0ZWRGbGFncy5nZXQodGhpcyk7XG4gICAgICAgIGlmICh0eXBlb2YgYWJvcnRlZCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkICd0aGlzJyB0byBiZSBhbiAnQWJvcnRTaWduYWwnIG9iamVjdCwgYnV0IGdvdCAke3RoaXMgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiB0aGlzfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYm9ydGVkO1xuICAgIH1cbn1cbmRlZmluZUV2ZW50QXR0cmlidXRlKEFib3J0U2lnbmFsLnByb3RvdHlwZSwgXCJhYm9ydFwiKTtcbi8qKlxuICogQ3JlYXRlIGFuIEFib3J0U2lnbmFsIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWJvcnRTaWduYWwoKSB7XG4gICAgY29uc3Qgc2lnbmFsID0gT2JqZWN0LmNyZWF0ZShBYm9ydFNpZ25hbC5wcm90b3R5cGUpO1xuICAgIEV2ZW50VGFyZ2V0LmNhbGwoc2lnbmFsKTtcbiAgICBhYm9ydGVkRmxhZ3Muc2V0KHNpZ25hbCwgZmFsc2UpO1xuICAgIHJldHVybiBzaWduYWw7XG59XG4vKipcbiAqIEFib3J0IGEgZ2l2ZW4gc2lnbmFsLlxuICovXG5mdW5jdGlvbiBhYm9ydFNpZ25hbChzaWduYWwpIHtcbiAgICBpZiAoYWJvcnRlZEZsYWdzLmdldChzaWduYWwpICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFib3J0ZWRGbGFncy5zZXQoc2lnbmFsLCB0cnVlKTtcbiAgICBzaWduYWwuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiYWJvcnRcIiB9KTtcbn1cbi8qKlxuICogQWJvcnRlZCBmbGFnIGZvciBlYWNoIGluc3RhbmNlcy5cbiAqL1xuY29uc3QgYWJvcnRlZEZsYWdzID0gbmV3IFdlYWtNYXAoKTtcbi8vIFByb3BlcnRpZXMgc2hvdWxkIGJlIGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBYm9ydFNpZ25hbC5wcm90b3R5cGUsIHtcbiAgICBhYm9ydGVkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbn0pO1xuLy8gYHRvU3RyaW5nKClgIHNob3VsZCByZXR1cm4gYFwiW29iamVjdCBBYm9ydFNpZ25hbF1cImBcbmlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gXCJzeW1ib2xcIikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYm9ydFNpZ25hbC5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBcIkFib3J0U2lnbmFsXCIsXG4gICAgfSk7XG59XG5cbi8qKlxuICogVGhlIEFib3J0Q29udHJvbGxlci5cbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNhYm9ydGNvbnRyb2xsZXJcbiAqL1xuY2xhc3MgQWJvcnRDb250cm9sbGVyJDEge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzaWduYWxzLnNldCh0aGlzLCBjcmVhdGVBYm9ydFNpZ25hbCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYEFib3J0U2lnbmFsYCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgIHJldHVybiBnZXRTaWduYWwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0IGFuZCBzaWduYWwgdG8gYW55IG9ic2VydmVycyB0aGF0IHRoZSBhc3NvY2lhdGVkIGFjdGl2aXR5IGlzIHRvIGJlIGFib3J0ZWQuXG4gICAgICovXG4gICAgYWJvcnQoKSB7XG4gICAgICAgIGFib3J0U2lnbmFsKGdldFNpZ25hbCh0aGlzKSk7XG4gICAgfVxufVxuLyoqXG4gKiBBc3NvY2lhdGVkIHNpZ25hbHMuXG4gKi9cbmNvbnN0IHNpZ25hbHMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBHZXQgdGhlIGFzc29jaWF0ZWQgc2lnbmFsIG9mIGEgZ2l2ZW4gY29udHJvbGxlci5cbiAqL1xuZnVuY3Rpb24gZ2V0U2lnbmFsKGNvbnRyb2xsZXIpIHtcbiAgICBjb25zdCBzaWduYWwgPSBzaWduYWxzLmdldChjb250cm9sbGVyKTtcbiAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgJ3RoaXMnIHRvIGJlIGFuICdBYm9ydENvbnRyb2xsZXInIG9iamVjdCwgYnV0IGdvdCAke2NvbnRyb2xsZXIgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBjb250cm9sbGVyfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmFsO1xufVxuLy8gUHJvcGVydGllcyBzaG91bGQgYmUgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFib3J0Q29udHJvbGxlciQxLnByb3RvdHlwZSwge1xuICAgIHNpZ25hbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxufSk7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09IFwic3ltYm9sXCIpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJvcnRDb250cm9sbGVyJDEucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogXCJBYm9ydENvbnRyb2xsZXJcIixcbiAgICB9KTtcbn1cblxuZXhwb3J0cy5BYm9ydENvbnRyb2xsZXIgPSBBYm9ydENvbnRyb2xsZXIkMTtcbmV4cG9ydHMuQWJvcnRFcnJvciA9IEFib3J0RXJyb3I7XG5leHBvcnRzLkZldGNoRXJyb3IgPSBGZXRjaEVycm9yO1xuZXhwb3J0cy5GaWxlID0gRmlsZSQxO1xuZXhwb3J0cy5Gb3JtRGF0YSA9IEZvcm1EYXRhO1xuZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gUmVzcG9uc2U7XG5leHBvcnRzLl9CbG9iID0gX0Jsb2IkMTtcbmV4cG9ydHMuZmV0Y2ggPSBmZXRjaDtcbmV4cG9ydHMuaXNSZWRpcmVjdCA9IGlzUmVkaXJlY3Q7XG5leHBvcnRzLm5vZGVEb21leGNlcHRpb24gPSBub2RlRG9tZXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbImh0dHAiLCJyZXF1aXJlIiwiaHR0cHMiLCJ6bGliIiwiU3RyZWFtIiwibm9kZV9idWZmZXIiLCJub2RlX3V0aWwiLCJub2RlX3VybCIsIm5vZGVfbmV0IiwiZGF0YVVyaVRvQnVmZmVyIiwidXJpIiwidGVzdCIsIlR5cGVFcnJvciIsInJlcGxhY2UiLCJmaXJzdENvbW1hIiwiaW5kZXhPZiIsIm1ldGEiLCJzdWJzdHJpbmciLCJzcGxpdCIsImNoYXJzZXQiLCJiYXNlNjQiLCJ0eXBlIiwidHlwZUZ1bGwiLCJpIiwibGVuZ3RoIiwiZW5jb2RpbmciLCJkYXRhIiwidW5lc2NhcGUiLCJidWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsInBvbnlmaWxsX2VzMjAxOCIsImV4cG9ydHMiLCJoYXNSZXF1aXJlZFBvbnlmaWxsX2VzMjAxOCIsInJlcXVpcmVQb255ZmlsbF9lczIwMTgiLCJtb2R1bGUiLCJmYWN0b3J5IiwiU3ltYm9sUG9seWZpbGwiLCJTeW1ib2wiLCJpdGVyYXRvciIsImRlc2NyaXB0aW9uIiwibm9vcCIsInVuZGVmaW5lZCIsImdldEdsb2JhbHMiLCJnbG9iYWxzIiwidHlwZUlzT2JqZWN0IiwieCIsInJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbiIsIm9yaWdpbmFsUHJvbWlzZSIsIlByb21pc2UiLCJvcmlnaW5hbFByb21pc2VUaGVuIiwicHJvdG90eXBlIiwidGhlbiIsIm9yaWdpbmFsUHJvbWlzZVJlc29sdmUiLCJyZXNvbHZlIiwiYmluZCIsIm9yaWdpbmFsUHJvbWlzZVJlamVjdCIsInJlamVjdCIsIm5ld1Byb21pc2UiLCJleGVjdXRvciIsInByb21pc2VSZXNvbHZlZFdpdGgiLCJ2YWx1ZSIsInByb21pc2VSZWplY3RlZFdpdGgiLCJyZWFzb24iLCJQZXJmb3JtUHJvbWlzZVRoZW4iLCJwcm9taXNlIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiY2FsbCIsInVwb25Qcm9taXNlIiwidXBvbkZ1bGZpbGxtZW50IiwidXBvblJlamVjdGlvbiIsInRyYW5zZm9ybVByb21pc2VXaXRoIiwiZnVsZmlsbG1lbnRIYW5kbGVyIiwicmVqZWN0aW9uSGFuZGxlciIsInNldFByb21pc2VJc0hhbmRsZWRUb1RydWUiLCJxdWV1ZU1pY3JvdGFzayIsImdsb2JhbFF1ZXVlTWljcm90YXNrIiwicmVzb2x2ZWRQcm9taXNlIiwiZm4iLCJyZWZsZWN0Q2FsbCIsIkYiLCJWIiwiYXJncyIsIkZ1bmN0aW9uIiwiYXBwbHkiLCJwcm9taXNlQ2FsbCIsIlFVRVVFX01BWF9BUlJBWV9TSVpFIiwiU2ltcGxlUXVldWUiLCJjb25zdHJ1Y3RvciIsIl9jdXJzb3IiLCJfc2l6ZSIsIl9mcm9udCIsIl9lbGVtZW50cyIsIl9uZXh0IiwiX2JhY2siLCJwdXNoIiwiZWxlbWVudCIsIm9sZEJhY2siLCJuZXdCYWNrIiwic2hpZnQiLCJvbGRGcm9udCIsIm5ld0Zyb250Iiwib2xkQ3Vyc29yIiwibmV3Q3Vyc29yIiwiZWxlbWVudHMiLCJmb3JFYWNoIiwiY2FsbGJhY2siLCJub2RlIiwicGVlayIsImZyb250IiwiY3Vyc29yIiwiUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSIsInJlYWRlciIsInN0cmVhbSIsIl9vd25lclJlYWRhYmxlU3RyZWFtIiwiX3JlYWRlciIsIl9zdGF0ZSIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkIiwiX3N0b3JlZEVycm9yIiwiUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsIiwiUmVhZGFibGVTdHJlYW1DYW5jZWwiLCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCIsInJlYWRlckxvY2tFeGNlcHRpb24iLCJuYW1lIiwiX2Nsb3NlZFByb21pc2UiLCJfY2xvc2VkUHJvbWlzZV9yZXNvbHZlIiwiX2Nsb3NlZFByb21pc2VfcmVqZWN0IiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlIiwiQWJvcnRTdGVwcyIsIkVycm9yU3RlcHMiLCJDYW5jZWxTdGVwcyIsIlB1bGxTdGVwcyIsIk51bWJlcklzRmluaXRlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJNYXRoVHJ1bmMiLCJNYXRoIiwidHJ1bmMiLCJ2IiwiY2VpbCIsImZsb29yIiwiaXNEaWN0aW9uYXJ5IiwiYXNzZXJ0RGljdGlvbmFyeSIsIm9iaiIsImNvbnRleHQiLCJhc3NlcnRGdW5jdGlvbiIsImlzT2JqZWN0IiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCIsInBvc2l0aW9uIiwiYXNzZXJ0UmVxdWlyZWRGaWVsZCIsImZpZWxkIiwiY29udmVydFVucmVzdHJpY3RlZERvdWJsZSIsImNlbnNvck5lZ2F0aXZlWmVybyIsImludGVnZXJQYXJ0IiwiY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJNQVhfU0FGRV9JTlRFR0VSIiwiYXNzZXJ0UmVhZGFibGVTdHJlYW0iLCJJc1JlYWRhYmxlU3RyZWFtIiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3QiLCJyZWFkUmVxdWVzdCIsIl9yZWFkUmVxdWVzdHMiLCJSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdCIsImNodW5rIiwiZG9uZSIsIl9jbG9zZVN0ZXBzIiwiX2NodW5rU3RlcHMiLCJSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyIsIlJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlciIsIklzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwiSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCIsImNsb3NlZCIsImRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwiY2FuY2VsIiwicmVhZCIsInJlc29sdmVQcm9taXNlIiwicmVqZWN0UHJvbWlzZSIsIl9lcnJvclN0ZXBzIiwiZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQiLCJyZWxlYXNlTG9jayIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJlbnVtZXJhYmxlIiwidG9TdHJpbmdUYWciLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImhhc093blByb3BlcnR5IiwiX2Rpc3R1cmJlZCIsIl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIiLCJBc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsIiwicHJldmVudENhbmNlbCIsIl9vbmdvaW5nUHJvbWlzZSIsIl9pc0ZpbmlzaGVkIiwiX3ByZXZlbnRDYW5jZWwiLCJuZXh0IiwibmV4dFN0ZXBzIiwiX25leHRTdGVwcyIsInJldHVybiIsInJldHVyblN0ZXBzIiwiX3JldHVyblN0ZXBzIiwicmVzdWx0IiwiUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwiSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IiLCJzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbiIsIl9hc3luY0l0ZXJhdG9ySW1wbCIsInNldFByb3RvdHlwZU9mIiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciIsImltcGwiLCJjcmVhdGUiLCJfYSIsIk51bWJlcklzTmFOIiwiaXNOYU4iLCJDcmVhdGVBcnJheUZyb21MaXN0Iiwic2xpY2UiLCJDb3B5RGF0YUJsb2NrQnl0ZXMiLCJkZXN0IiwiZGVzdE9mZnNldCIsInNyYyIsInNyY09mZnNldCIsIm4iLCJVaW50OEFycmF5Iiwic2V0IiwiVHJhbnNmZXJBcnJheUJ1ZmZlciIsIk8iLCJJc0RldGFjaGVkQnVmZmVyIiwiQXJyYXlCdWZmZXJTbGljZSIsImJlZ2luIiwiZW5kIiwiQXJyYXlCdWZmZXIiLCJJc05vbk5lZ2F0aXZlTnVtYmVyIiwiQ2xvbmVBc1VpbnQ4QXJyYXkiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIkRlcXVldWVWYWx1ZSIsImNvbnRhaW5lciIsInBhaXIiLCJfcXVldWUiLCJfcXVldWVUb3RhbFNpemUiLCJzaXplIiwiRW5xdWV1ZVZhbHVlV2l0aFNpemUiLCJJbmZpbml0eSIsIlJhbmdlRXJyb3IiLCJQZWVrUXVldWVWYWx1ZSIsIlJlc2V0UXVldWUiLCJSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IiwidmlldyIsIklzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsImJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbiIsIl92aWV3IiwicmVzcG9uZCIsImJ5dGVzV3JpdHRlbiIsIl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kIiwicmVzcG9uZFdpdGhOZXdWaWV3IiwiaXNWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIiLCJieW9iUmVxdWVzdCIsIklzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsImJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdCIsImRlc2lyZWRTaXplIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplIiwiY2xvc2UiLCJfY2xvc2VSZXF1ZXN0ZWQiLCJzdGF0ZSIsIl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlIiwiZW5xdWV1ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlIiwiZXJyb3IiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zIiwiX2NhbmNlbEFsZ29yaXRobSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMiLCJlbnRyeSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluIiwiYXV0b0FsbG9jYXRlQ2h1bmtTaXplIiwiX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSIsImJ1ZmZlckUiLCJwdWxsSW50b0Rlc2NyaXB0b3IiLCJidWZmZXJCeXRlTGVuZ3RoIiwiYnl0ZXNGaWxsZWQiLCJlbGVtZW50U2l6ZSIsInZpZXdDb25zdHJ1Y3RvciIsInJlYWRlclR5cGUiLCJfcGVuZGluZ1B1bGxJbnRvcyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkIiwiY29udHJvbGxlciIsInNob3VsZFB1bGwiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwiLCJfcHVsbGluZyIsIl9wdWxsQWdhaW4iLCJwdWxsUHJvbWlzZSIsIl9wdWxsQWxnb3JpdGhtIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IiLCJmaWxsZWRWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IiLCJSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3QiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlIiwiY3VycmVudEFsaWduZWRCeXRlcyIsIm1heEJ5dGVzVG9Db3B5IiwibWluIiwibWF4Qnl0ZXNGaWxsZWQiLCJtYXhBbGlnbmVkQnl0ZXMiLCJ0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nIiwicmVhZHkiLCJxdWV1ZSIsImhlYWRPZlF1ZXVlIiwiYnl0ZXNUb0NvcHkiLCJkZXN0U3RhcnQiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IiLCJSZWFkYWJsZVN0cmVhbUNsb3NlIiwiX2J5b2JSZXF1ZXN0IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50byIsInJlYWRJbnRvUmVxdWVzdCIsIkRhdGFWaWV3IiwiQllURVNfUEVSX0VMRU1FTlQiLCJjdG9yIiwiUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3QiLCJlbXB0eVZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUiLCJmaXJzdERlc2NyaXB0b3IiLCJSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZSIsInJlbWFpbmRlclNpemUiLCJyZW1haW5kZXIiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsIiwiZGVzY3JpcHRvciIsIl9zdGFydGVkIiwiZmlyc3RQZW5kaW5nUHVsbEludG8iLCJ0cmFuc2ZlcnJlZEJ1ZmZlciIsInRyYW5zZmVycmVkVmlldyIsIlJlYWRhYmxlU3RyZWFtRXJyb3IiLCJTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QiLCJfc3RyYXRlZ3lIV00iLCJ2aWV3Qnl0ZUxlbmd0aCIsIlNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsInN0YXJ0QWxnb3JpdGhtIiwicHVsbEFsZ29yaXRobSIsImNhbmNlbEFsZ29yaXRobSIsImhpZ2hXYXRlck1hcmsiLCJzdGFydFJlc3VsdCIsInIiLCJTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSIsInVuZGVybHlpbmdCeXRlU291cmNlIiwic3RhcnQiLCJwdWxsIiwicmVxdWVzdCIsIkFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCJfcmVhZEludG9SZXF1ZXN0cyIsIklzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwiYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkIiwiRXh0cmFjdEhpZ2hXYXRlck1hcmsiLCJzdHJhdGVneSIsImRlZmF1bHRIV00iLCJFeHRyYWN0U2l6ZUFsZ29yaXRobSIsImNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kiLCJpbml0IiwiY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUiLCJjb252ZXJ0VW5kZXJseWluZ1NpbmsiLCJvcmlnaW5hbCIsImFib3J0Iiwid3JpdGUiLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrIiwiYXNzZXJ0V3JpdGFibGVTdHJlYW0iLCJJc1dyaXRhYmxlU3RyZWFtIiwiaXNBYm9ydFNpZ25hbCIsImFib3J0ZWQiLCJzdXBwb3J0c0Fib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImNyZWF0ZUFib3J0Q29udHJvbGxlciIsIldyaXRhYmxlU3RyZWFtIiwicmF3VW5kZXJseWluZ1NpbmsiLCJyYXdTdHJhdGVneSIsInVuZGVybHlpbmdTaW5rIiwiSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtIiwic2l6ZUFsZ29yaXRobSIsIlNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayIsImxvY2tlZCIsInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMiIsIklzV3JpdGFibGVTdHJlYW1Mb2NrZWQiLCJXcml0YWJsZVN0cmVhbUFib3J0IiwiV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQiLCJXcml0YWJsZVN0cmVhbUNsb3NlIiwiZ2V0V3JpdGVyIiwiQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsIkNyZWF0ZVdyaXRhYmxlU3RyZWFtIiwid3JpdGVBbGdvcml0aG0iLCJjbG9zZUFsZ29yaXRobSIsImFib3J0QWxnb3JpdGhtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIlNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIl93cml0ZXIiLCJfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyIiwiX3dyaXRlUmVxdWVzdHMiLCJfaW5GbGlnaHRXcml0ZVJlcXVlc3QiLCJfY2xvc2VSZXF1ZXN0IiwiX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0IiwiX3BlbmRpbmdBYm9ydFJlcXVlc3QiLCJfYmFja3ByZXNzdXJlIiwiX2Fib3J0UmVhc29uIiwiX2Fib3J0Q29udHJvbGxlciIsIl9wcm9taXNlIiwid2FzQWxyZWFkeUVycm9yaW5nIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwiX3JlYXNvbiIsIl93YXNBbHJlYWR5RXJyb3JpbmciLCJXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3JpbmciLCJjbG9zZVJlcXVlc3QiLCJ3cml0ZXIiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSIsIldyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0Iiwid3JpdGVSZXF1ZXN0IiwiV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbiIsIldyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3JpbmciLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCIsIldyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQiLCJzdG9yZWRFcnJvciIsIldyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQiLCJhYm9ydFJlcXVlc3QiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVXaXRoRXJyb3IiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2UiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3IiLCJXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodCIsIldyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCIsIldyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlIiwiYmFja3ByZXNzdXJlIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0IiwiX293bmVyV3JpdGFibGVTdHJlYW0iLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkIiwiSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIiLCJkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsImRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUiLCJfcmVhZHlQcm9taXNlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQiLCJfY2xvc2VkUHJvbWlzZVN0YXRlIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQiLCJfcmVhZHlQcm9taXNlU3RhdGUiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0IiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSIsInJlbGVhc2VkRXJyb3IiLCJjaHVua1NpemUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlIiwiY2xvc2VTZW50aW5lbCIsImFib3J0UmVhc29uIiwiSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIiLCJzaWduYWwiLCJfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwiX2Fib3J0QWxnb3JpdGhtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIl9zdHJhdGVneVNpemVBbGdvcml0aG0iLCJfd3JpdGVBbGdvcml0aG0iLCJfY2xvc2VBbGdvcml0aG0iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlIiwic3RhcnRQcm9taXNlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkIiwiY2h1bmtTaXplRSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkIiwiZW5xdWV1ZUUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZSIsInNpbmtDbG9zZVByb21pc2UiLCJzaW5rV3JpdGVQcm9taXNlIiwiX3JlYWR5UHJvbWlzZV9yZXNvbHZlIiwiX3JlYWR5UHJvbWlzZV9yZWplY3QiLCJOYXRpdmVET01FeGNlcHRpb24iLCJET01FeGNlcHRpb24iLCJpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yIiwiY3JlYXRlRE9NRXhjZXB0aW9uUG9seWZpbGwiLCJtZXNzYWdlIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIndyaXRhYmxlIiwiRE9NRXhjZXB0aW9uJDEiLCJSZWFkYWJsZVN0cmVhbVBpcGVUbyIsInNvdXJjZSIsInByZXZlbnRDbG9zZSIsInByZXZlbnRBYm9ydCIsInNodXR0aW5nRG93biIsImN1cnJlbnRXcml0ZSIsImFjdGlvbnMiLCJzaHV0ZG93bldpdGhBY3Rpb24iLCJhbGwiLCJtYXAiLCJhY3Rpb24iLCJhZGRFdmVudExpc3RlbmVyIiwicGlwZUxvb3AiLCJyZXNvbHZlTG9vcCIsInJlamVjdExvb3AiLCJwaXBlU3RlcCIsInJlc29sdmVSZWFkIiwicmVqZWN0UmVhZCIsImlzT3JCZWNvbWVzRXJyb3JlZCIsInNodXRkb3duIiwiaXNPckJlY29tZXNDbG9zZWQiLCJkZXN0Q2xvc2VkIiwid2FpdEZvcldyaXRlc1RvRmluaXNoIiwib2xkQ3VycmVudFdyaXRlIiwib3JpZ2luYWxJc0Vycm9yIiwib3JpZ2luYWxFcnJvciIsImRvVGhlUmVzdCIsImZpbmFsaXplIiwibmV3RXJyb3IiLCJpc0Vycm9yIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0iLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUiLCJTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSIsInVuZGVybHlpbmdTb3VyY2UiLCJSZWFkYWJsZVN0cmVhbVRlZSIsImNsb25lRm9yQnJhbmNoMiIsIlJlYWRhYmxlQnl0ZVN0cmVhbVRlZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZSIsInJlYWRpbmciLCJyZWFkQWdhaW4iLCJjYW5jZWxlZDEiLCJjYW5jZWxlZDIiLCJyZWFzb24xIiwicmVhc29uMiIsImJyYW5jaDEiLCJicmFuY2gyIiwicmVzb2x2ZUNhbmNlbFByb21pc2UiLCJjYW5jZWxQcm9taXNlIiwiY2h1bmsxIiwiY2h1bmsyIiwiY2FuY2VsMUFsZ29yaXRobSIsImNvbXBvc2l0ZVJlYXNvbiIsImNhbmNlbFJlc3VsdCIsImNhbmNlbDJBbGdvcml0aG0iLCJDcmVhdGVSZWFkYWJsZVN0cmVhbSIsInJlYWRBZ2FpbkZvckJyYW5jaDEiLCJyZWFkQWdhaW5Gb3JCcmFuY2gyIiwiZm9yd2FyZFJlYWRlckVycm9yIiwidGhpc1JlYWRlciIsInB1bGxXaXRoRGVmYXVsdFJlYWRlciIsImNsb25lRSIsInB1bGwxQWxnb3JpdGhtIiwicHVsbDJBbGdvcml0aG0iLCJwdWxsV2l0aEJZT0JSZWFkZXIiLCJmb3JCcmFuY2gyIiwiYnlvYkJyYW5jaCIsIm90aGVyQnJhbmNoIiwiYnlvYkNhbmNlbGVkIiwib3RoZXJDYW5jZWxlZCIsImNsb25lZENodW5rIiwiQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtIiwiY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlIiwiY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrIiwiY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSIsImNvbnZlcnRSZWFkZXJPcHRpb25zIiwib3B0aW9ucyIsIm1vZGUiLCJjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlIiwiY29udmVydEl0ZXJhdG9yT3B0aW9ucyIsIkJvb2xlYW4iLCJjb252ZXJ0UGlwZU9wdGlvbnMiLCJhc3NlcnRBYm9ydFNpZ25hbCIsImNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpciIsInJlYWRhYmxlIiwiUmVhZGFibGVTdHJlYW0iLCJyYXdVbmRlcmx5aW5nU291cmNlIiwiSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtIiwic3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxIiwiZ2V0UmVhZGVyIiwicmF3T3B0aW9ucyIsInBpcGVUaHJvdWdoIiwicmF3VHJhbnNmb3JtIiwidHJhbnNmb3JtIiwicGlwZVRvIiwiZGVzdGluYXRpb24iLCJ0ZWUiLCJicmFuY2hlcyIsInZhbHVlcyIsImFzeW5jSXRlcmF0b3IiLCJzb3VyY2VDYW5jZWxQcm9taXNlIiwiY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQiLCJieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uIiwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSIsIl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayIsIklzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSIsImJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uIiwiY291bnRTaXplRnVuY3Rpb24iLCJDb3VudFF1ZXVpbmdTdHJhdGVneSIsIl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsiLCJJc0NvdW50UXVldWluZ1N0cmF0ZWd5IiwiY291bnRCcmFuZENoZWNrRXhjZXB0aW9uIiwiY29udmVydFRyYW5zZm9ybWVyIiwiZmx1c2giLCJyZWFkYWJsZVR5cGUiLCJ3cml0YWJsZVR5cGUiLCJjb252ZXJ0VHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrIiwiY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayIsImNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrIiwiVHJhbnNmb3JtU3RyZWFtIiwicmF3VHJhbnNmb3JtZXIiLCJyYXdXcml0YWJsZVN0cmF0ZWd5IiwicmF3UmVhZGFibGVTdHJhdGVneSIsIndyaXRhYmxlU3RyYXRlZ3kiLCJyZWFkYWJsZVN0cmF0ZWd5IiwidHJhbnNmb3JtZXIiLCJyZWFkYWJsZUhpZ2hXYXRlck1hcmsiLCJyZWFkYWJsZVNpemVBbGdvcml0aG0iLCJ3cml0YWJsZUhpZ2hXYXRlck1hcmsiLCJ3cml0YWJsZVNpemVBbGdvcml0aG0iLCJzdGFydFByb21pc2VfcmVzb2x2ZSIsIkluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0iLCJTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVRyYW5zZm9ybWVyIiwiX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIiLCJJc1RyYW5zZm9ybVN0cmVhbSIsInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24iLCJfcmVhZGFibGUiLCJfd3JpdGFibGUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUiLCJfYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSIsIl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUiLCJUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUiLCJUcmFuc2Zvcm1TdHJlYW1FcnJvciIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwicmVhZGFibGVDb250cm9sbGVyIiwiX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwidGVybWluYXRlIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUiLCJTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwidHJhbnNmb3JtQWxnb3JpdGhtIiwiZmx1c2hBbGdvcml0aG0iLCJfdHJhbnNmb3JtQWxnb3JpdGhtIiwiX2ZsdXNoQWxnb3JpdGhtIiwidHJhbnNmb3JtUmVzdWx0RSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybSIsInRyYW5zZm9ybVByb21pc2UiLCJiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlIiwiZmx1c2hQcm9taXNlIiwiUE9PTF9TSVpFJDEiLCJwcm9jZXNzIiwiZW1pdFdhcm5pbmciLCJhc3NpZ24iLCJCbG9iIiwicGFyYW1zIiwiYmxvYiIsImN0cmwiLCJhcnJheUJ1ZmZlciIsIlBPT0xfU0laRSIsInRvSXRlcmF0b3IiLCJwYXJ0cyIsImNsb25lIiwicGFydCIsImIiLCJfQmxvYiIsImVuZGluZ3MiLCJibG9iUGFydHMiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJTdHJpbmciLCJ0ZXh0IiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwic3RyIiwiZGVjb2RlIiwib2Zmc2V0IiwiaXQiLCJyZWxhdGl2ZVN0YXJ0IiwibWF4IiwicmVsYXRpdmVFbmQiLCJzcGFuIiwiYWRkZWQiLCJzdWJhcnJheSIsInRvTG93ZXJDYXNlIiwiaGFzSW5zdGFuY2UiLCJvYmplY3QiLCJfQmxvYiQxIiwiX0ZpbGUiLCJGaWxlIiwibGFzdE1vZGlmaWVkIiwiZmlsZUJpdHMiLCJmaWxlTmFtZSIsImFyZ3VtZW50cyIsIkRhdGUiLCJub3ciLCJGaWxlJDEiLCJ0IiwiaCIsInJhbmRvbSIsIm0iLCJmIiwiYSIsImMiLCJGb3JtRGF0YSIsImQiLCJlbnRyaWVzIiwibyIsInNvbWUiLCJhcHBlbmQiLCJkZWxldGUiLCJmaWx0ZXIiLCJnZXQiLCJsIiwiZ2V0QWxsIiwiaGFzIiwia2V5cyIsImZvcm1EYXRhVG9CbG9iIiwiQiIsInBhZFN0YXJ0IiwicCIsIkZldGNoQmFzZUVycm9yIiwiRmV0Y2hFcnJvciIsInN5c3RlbUVycm9yIiwiY29kZSIsImVycm5vIiwiZXJyb3JlZFN5c0NhbGwiLCJzeXNjYWxsIiwiTkFNRSIsImlzVVJMU2VhcmNoUGFyYW1ldGVycyIsInNvcnQiLCJpc0Jsb2IiLCJpc0RvbWFpbk9yU3ViZG9tYWluIiwib3JpZyIsIlVSTCIsImhvc3RuYW1lIiwiZW5kc1dpdGgiLCJpc1NhbWVQcm90b2NvbCIsInByb3RvY29sIiwicGlwZWxpbmUiLCJwcm9taXNpZnkiLCJJTlRFUk5BTFMkMiIsIkJvZHkiLCJib2R5IiwiYm91bmRhcnkiLCJ0b1N0cmluZyIsImlzQnVmZmVyIiwidHlwZXMiLCJpc0FueUFycmF5QnVmZmVyIiwiUmVhZGFibGUiLCJkaXN0dXJiZWQiLCJvbiIsImVycm9yXyIsInVybCIsImJvZHlVc2VkIiwiY29uc3VtZUJvZHkiLCJmb3JtRGF0YSIsImN0IiwiaGVhZGVycyIsInN0YXJ0c1dpdGgiLCJwYXJhbWV0ZXJzIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9Gb3JtRGF0YSIsImJ1ZiIsImpzb24iLCJKU09OIiwicGFyc2UiLCJkZXByZWNhdGUiLCJhbGxvYyIsImFjY3VtIiwiYWNjdW1CeXRlcyIsImRlc3Ryb3kiLCJyZWFkYWJsZUVuZGVkIiwiX3JlYWRhYmxlU3RhdGUiLCJlbmRlZCIsImV2ZXJ5Iiwiam9pbiIsImNvbmNhdCIsImluc3RhbmNlIiwicDEiLCJwMiIsImdldEJvdW5kYXJ5IiwiUGFzc1Rocm91Z2giLCJwaXBlIiwiZ2V0Tm9uU3BlY0Zvcm1EYXRhQm91bmRhcnkiLCJleHRyYWN0Q29udGVudFR5cGUiLCJnZXRUb3RhbEJ5dGVzIiwiZ2V0TGVuZ3RoU3luYyIsImhhc0tub3duTGVuZ3RoIiwid3JpdGVUb1N0cmVhbSIsInZhbGlkYXRlSGVhZGVyTmFtZSIsInZhbGlkYXRlSGVhZGVyVmFsdWUiLCJIZWFkZXJzIiwicmF3IiwiaXNCb3hlZFByaW1pdGl2ZSIsIm1ldGhvZCIsIlByb3h5IiwidGFyZ2V0IiwicmVjZWl2ZXIiLCJTZXQiLCJSZWZsZWN0IiwidGhpc0FyZyIsInJlZHVjZSIsImtleSIsImZvciIsInByb3BlcnR5IiwiZnJvbVJhd0hlYWRlcnMiLCJpbmRleCIsImFycmF5IiwicmVkaXJlY3RTdGF0dXMiLCJpc1JlZGlyZWN0IiwiSU5URVJOQUxTJDEiLCJSZXNwb25zZSIsInN0YXR1cyIsImNvbnRlbnRUeXBlIiwic3RhdHVzVGV4dCIsImNvdW50ZXIiLCJvayIsInJlZGlyZWN0ZWQiLCJyZWRpcmVjdCIsImxvY2F0aW9uIiwicmVzcG9uc2UiLCJzdHJpbmdpZnkiLCJnZXRTZWFyY2giLCJwYXJzZWRVUkwiLCJzZWFyY2giLCJsYXN0T2Zmc2V0IiwiaHJlZiIsImhhc2giLCJzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyIiwib3JpZ2luT25seSIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJwYXRobmFtZSIsIlJlZmVycmVyUG9saWN5IiwiREVGQVVMVF9SRUZFUlJFUl9QT0xJQ1kiLCJ2YWxpZGF0ZVJlZmVycmVyUG9saWN5IiwicmVmZXJyZXJQb2xpY3kiLCJpc09yaWdpblBvdGVudGlhbGx5VHJ1c3R3b3J0aHkiLCJob3N0SXAiLCJob3N0IiwiaG9zdElQVmVyc2lvbiIsImlzSVAiLCJpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkiLCJkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIiwicmVmZXJyZXJVUkxDYWxsYmFjayIsInJlZmVycmVyT3JpZ2luQ2FsbGJhY2siLCJyZWZlcnJlciIsInBvbGljeSIsInJlZmVycmVyU291cmNlIiwicmVmZXJyZXJVUkwiLCJyZWZlcnJlck9yaWdpbiIsImN1cnJlbnRVUkwiLCJvcmlnaW4iLCJwYXJzZVJlZmVycmVyUG9saWN5RnJvbUhlYWRlciIsInBvbGljeVRva2VucyIsInRva2VuIiwiSU5URVJOQUxTIiwiaXNSZXF1ZXN0IiwiZG9CYWREYXRhV2FybiIsIlJlcXVlc3QiLCJpbnB1dCIsInRvVXBwZXJDYXNlIiwiaW5wdXRCb2R5IiwicGFyc2VkUmVmZXJyZXIiLCJmb2xsb3ciLCJjb21wcmVzcyIsImFnZW50IiwiaW5zZWN1cmVIVFRQUGFyc2VyIiwiZm9ybWF0IiwiZ2V0Tm9kZVJlcXVlc3RPcHRpb25zIiwiY29udGVudExlbmd0aFZhbHVlIiwidG90YWxCeXRlcyIsInBhdGgiLCJBYm9ydEVycm9yIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0IiwicG9ydDEiLCJhYiIsInBvc3RNZXNzYWdlIiwiZXJyIiwibm9kZURvbWV4Y2VwdGlvbiIsInN1cHBvcnRlZFNjaGVtYXMiLCJmZXRjaCIsIm9wdGlvbnNfIiwic2VuZCIsImVtaXQiLCJhYm9ydEFuZEZpbmFsaXplIiwicmVxdWVzdF8iLCJmaXhSZXNwb25zZUNodW5rZWRUcmFuc2ZlckJhZEVuZGluZyIsInZlcnNpb24iLCJzIiwiZW5kZWRXaXRoRXZlbnRzQ291bnQiLCJwcmVwZW5kTGlzdGVuZXIiLCJfZXZlbnRzQ291bnQiLCJoYWRFcnJvciIsInJlc3BvbnNlXyIsInNldFRpbWVvdXQiLCJyYXdIZWFkZXJzIiwic3RhdHVzQ29kZSIsImxvY2F0aW9uVVJMIiwicmVxdWVzdE9wdGlvbnMiLCJyZXNwb25zZVJlZmVycmVyUG9saWN5Iiwib25jZSIsInJlc3BvbnNlT3B0aW9ucyIsInN0YXR1c01lc3NhZ2UiLCJjb2RpbmdzIiwiemxpYk9wdGlvbnMiLCJaX1NZTkNfRkxVU0giLCJmaW5pc2hGbHVzaCIsImNyZWF0ZUd1bnppcCIsImNyZWF0ZUluZmxhdGUiLCJjcmVhdGVJbmZsYXRlUmF3IiwiY3JlYXRlQnJvdGxpRGVjb21wcmVzcyIsImNhdGNoIiwiZXJyb3JDYWxsYmFjayIsIkxBU1RfQ0hVTksiLCJpc0NodW5rZWRUcmFuc2ZlciIsInByb3Blckxhc3RDaHVua1JlY2VpdmVkIiwicHJldmlvdXNDaHVuayIsInNvY2tldCIsIm9uU29ja2V0Q2xvc2UiLCJvbkRhdGEiLCJjb21wYXJlIiwicmVtb3ZlTGlzdGVuZXIiLCJwcml2YXRlRGF0YSIsIldlYWtNYXAiLCJ3cmFwcGVycyIsInBkIiwiZXZlbnQiLCJyZXR2IiwiY29uc29sZSIsImFzc2VydCIsInNldENhbmNlbEZsYWciLCJwYXNzaXZlTGlzdGVuZXIiLCJjYW5jZWxhYmxlIiwiY2FuY2VsZWQiLCJwcmV2ZW50RGVmYXVsdCIsIkV2ZW50IiwiZXZlbnRUYXJnZXQiLCJldmVudFBoYXNlIiwiY3VycmVudFRhcmdldCIsInN0b3BwZWQiLCJpbW1lZGlhdGVTdG9wcGVkIiwidGltZVN0YW1wIiwiZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yIiwiY29tcG9zZWRQYXRoIiwiTk9ORSIsIkNBUFRVUklOR19QSEFTRSIsIkFUX1RBUkdFVCIsIkJVQkJMSU5HX1BIQVNFIiwic3RvcFByb3BhZ2F0aW9uIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiYnViYmxlcyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjb21wb3NlZCIsInNyY0VsZW1lbnQiLCJjYW5jZWxCdWJibGUiLCJyZXR1cm5WYWx1ZSIsImluaXRFdmVudCIsImRlZmluZUNhbGxEZXNjcmlwdG9yIiwiZGVmaW5lV3JhcHBlciIsIkJhc2VFdmVudCIsInByb3RvIiwiQ3VzdG9tRXZlbnQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc0Z1bmMiLCJnZXRXcmFwcGVyIiwid3JhcHBlciIsIndyYXBFdmVudCIsIldyYXBwZXIiLCJpc1N0b3BwZWQiLCJzZXRFdmVudFBoYXNlIiwic2V0Q3VycmVudFRhcmdldCIsInNldFBhc3NpdmVMaXN0ZW5lciIsImxpc3RlbmVyc01hcCIsIkNBUFRVUkUiLCJCVUJCTEUiLCJBVFRSSUJVVEUiLCJnZXRMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IiLCJldmVudE5hbWUiLCJsaXN0ZW5lclR5cGUiLCJsaXN0ZW5lciIsInByZXYiLCJuZXdOb2RlIiwicGFzc2l2ZSIsImRlZmluZUV2ZW50QXR0cmlidXRlIiwiZXZlbnRUYXJnZXRQcm90b3R5cGUiLCJkZWZpbmVDdXN0b21FdmVudFRhcmdldCIsImV2ZW50TmFtZXMiLCJDdXN0b21FdmVudFRhcmdldCIsIkV2ZW50VGFyZ2V0IiwiTWFwIiwiQXJyYXkiLCJpc0FycmF5Iiwib3B0aW9uc0lzT2JqIiwiY2FwdHVyZSIsImRpc3BhdGNoRXZlbnQiLCJ3cmFwcGVkRXZlbnQiLCJoYW5kbGVFdmVudCIsIkFib3J0U2lnbmFsIiwiYWJvcnRlZEZsYWdzIiwiY3JlYXRlQWJvcnRTaWduYWwiLCJhYm9ydFNpZ25hbCIsIkFib3J0Q29udHJvbGxlciQxIiwic2lnbmFscyIsImdldFNpZ25hbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-fetch-native/lib/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/node-fetch-native/lib/index.cjs ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst nodeFetch = __webpack_require__(/*! ../dist/index.cjs */ \"(ssr)/./node_modules/node-fetch-native/dist/index.cjs\");\nfunction fetch(input, options) {\n    return nodeFetch.fetch(input, options);\n}\nfor(const key in nodeFetch){\n    fetch[key] = nodeFetch[key];\n}\nmodule.exports = fetch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvbGliL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsWUFBWUMsbUJBQU9BLENBQUMsZ0ZBQW1CO0FBRTdDLFNBQVNDLE1BQU9DLEtBQUssRUFBRUMsT0FBTztJQUM1QixPQUFPSixVQUFVRSxLQUFLLENBQUNDLE9BQU9DO0FBQ2hDO0FBRUEsSUFBSyxNQUFNQyxPQUFPTCxVQUFXO0lBQzNCRSxLQUFLLENBQUNHLElBQUksR0FBR0wsU0FBUyxDQUFDSyxJQUFJO0FBQzdCO0FBRUFDLE9BQU9DLE9BQU8sR0FBR0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZXJucHJvamVjdC8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoLW5hdGl2ZS9saWIvaW5kZXguY2pzPzA3NGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgbm9kZUZldGNoID0gcmVxdWlyZShcIi4uL2Rpc3QvaW5kZXguY2pzXCIpO1xuXG5mdW5jdGlvbiBmZXRjaCAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5vZGVGZXRjaC5mZXRjaChpbnB1dCwgb3B0aW9ucyk7XG59XG5cbmZvciAoY29uc3Qga2V5IGluIG5vZGVGZXRjaCkge1xuICBmZXRjaFtrZXldID0gbm9kZUZldGNoW2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmV0Y2g7XG4iXSwibmFtZXMiOlsibm9kZUZldGNoIiwicmVxdWlyZSIsImZldGNoIiwiaW5wdXQiLCJvcHRpb25zIiwia2V5IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch-native/lib/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs":
/*!*************************************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n__webpack_require__(/*! node:fs */ \"node:fs\");\n__webpack_require__(/*! node:path */ \"node:path\");\nconst abortController = __webpack_require__(/*! ../shared/node-fetch-native.8afd3fea.cjs */ \"(rsc)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs\");\n__webpack_require__(/*! node:http */ \"node:http\");\n__webpack_require__(/*! node:https */ \"node:https\");\n__webpack_require__(/*! node:zlib */ \"node:zlib\");\n__webpack_require__(/*! node:stream */ \"node:stream\");\n__webpack_require__(/*! node:buffer */ \"node:buffer\");\n__webpack_require__(/*! node:util */ \"node:util\");\n__webpack_require__(/*! node:url */ \"node:url\");\n__webpack_require__(/*! node:net */ \"node:net\");\nlet s = 0;\nconst S = {\n    START_BOUNDARY: s++,\n    HEADER_FIELD_START: s++,\n    HEADER_FIELD: s++,\n    HEADER_VALUE_START: s++,\n    HEADER_VALUE: s++,\n    HEADER_VALUE_ALMOST_DONE: s++,\n    HEADERS_ALMOST_DONE: s++,\n    PART_DATA_START: s++,\n    PART_DATA: s++,\n    END: s++\n};\nlet f = 1;\nconst F = {\n    PART_BOUNDARY: f,\n    LAST_BOUNDARY: f *= 2\n};\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\nconst lower = (c)=>c | 0x20;\nconst noop = ()=>{};\nclass MultipartParser {\n    /**\n\t * @param {string} boundary\n\t */ constructor(boundary){\n        this.index = 0;\n        this.flags = 0;\n        this.onHeaderEnd = noop;\n        this.onHeaderField = noop;\n        this.onHeadersEnd = noop;\n        this.onHeaderValue = noop;\n        this.onPartBegin = noop;\n        this.onPartData = noop;\n        this.onPartEnd = noop;\n        this.boundaryChars = {};\n        boundary = \"\\r\\n--\" + boundary;\n        const ui8a = new Uint8Array(boundary.length);\n        for(let i = 0; i < boundary.length; i++){\n            ui8a[i] = boundary.charCodeAt(i);\n            this.boundaryChars[ui8a[i]] = true;\n        }\n        this.boundary = ui8a;\n        this.lookbehind = new Uint8Array(this.boundary.length + 8);\n        this.state = S.START_BOUNDARY;\n    }\n    /**\n\t * @param {Uint8Array} data\n\t */ write(data) {\n        let i = 0;\n        const length_ = data.length;\n        let previousIndex = this.index;\n        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;\n        const boundaryLength = this.boundary.length;\n        const boundaryEnd = boundaryLength - 1;\n        const bufferLength = data.length;\n        let c;\n        let cl;\n        const mark = (name)=>{\n            this[name + \"Mark\"] = i;\n        };\n        const clear = (name)=>{\n            delete this[name + \"Mark\"];\n        };\n        const callback = (callbackSymbol, start, end, ui8a)=>{\n            if (start === undefined || start !== end) {\n                this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n            }\n        };\n        const dataCallback = (name, clear)=>{\n            const markSymbol = name + \"Mark\";\n            if (!(markSymbol in this)) {\n                return;\n            }\n            if (clear) {\n                callback(name, this[markSymbol], i, data);\n                delete this[markSymbol];\n            } else {\n                callback(name, this[markSymbol], data.length, data);\n                this[markSymbol] = 0;\n            }\n        };\n        for(i = 0; i < length_; i++){\n            c = data[i];\n            switch(state){\n                case S.START_BOUNDARY:\n                    if (index === boundary.length - 2) {\n                        if (c === HYPHEN) {\n                            flags |= F.LAST_BOUNDARY;\n                        } else if (c !== CR) {\n                            return;\n                        }\n                        index++;\n                        break;\n                    } else if (index - 1 === boundary.length - 2) {\n                        if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n                            state = S.END;\n                            flags = 0;\n                        } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n                            index = 0;\n                            callback(\"onPartBegin\");\n                            state = S.HEADER_FIELD_START;\n                        } else {\n                            return;\n                        }\n                        break;\n                    }\n                    if (c !== boundary[index + 2]) {\n                        index = -2;\n                    }\n                    if (c === boundary[index + 2]) {\n                        index++;\n                    }\n                    break;\n                case S.HEADER_FIELD_START:\n                    state = S.HEADER_FIELD;\n                    mark(\"onHeaderField\");\n                    index = 0;\n                // falls through\n                case S.HEADER_FIELD:\n                    if (c === CR) {\n                        clear(\"onHeaderField\");\n                        state = S.HEADERS_ALMOST_DONE;\n                        break;\n                    }\n                    index++;\n                    if (c === HYPHEN) {\n                        break;\n                    }\n                    if (c === COLON) {\n                        if (index === 1) {\n                            // empty header field\n                            return;\n                        }\n                        dataCallback(\"onHeaderField\", true);\n                        state = S.HEADER_VALUE_START;\n                        break;\n                    }\n                    cl = lower(c);\n                    if (cl < A || cl > Z) {\n                        return;\n                    }\n                    break;\n                case S.HEADER_VALUE_START:\n                    if (c === SPACE) {\n                        break;\n                    }\n                    mark(\"onHeaderValue\");\n                    state = S.HEADER_VALUE;\n                // falls through\n                case S.HEADER_VALUE:\n                    if (c === CR) {\n                        dataCallback(\"onHeaderValue\", true);\n                        callback(\"onHeaderEnd\");\n                        state = S.HEADER_VALUE_ALMOST_DONE;\n                    }\n                    break;\n                case S.HEADER_VALUE_ALMOST_DONE:\n                    if (c !== LF) {\n                        return;\n                    }\n                    state = S.HEADER_FIELD_START;\n                    break;\n                case S.HEADERS_ALMOST_DONE:\n                    if (c !== LF) {\n                        return;\n                    }\n                    callback(\"onHeadersEnd\");\n                    state = S.PART_DATA_START;\n                    break;\n                case S.PART_DATA_START:\n                    state = S.PART_DATA;\n                    mark(\"onPartData\");\n                // falls through\n                case S.PART_DATA:\n                    previousIndex = index;\n                    if (index === 0) {\n                        // boyer-moore derrived algorithm to safely skip non-boundary data\n                        i += boundaryEnd;\n                        while(i < bufferLength && !(data[i] in boundaryChars)){\n                            i += boundaryLength;\n                        }\n                        i -= boundaryEnd;\n                        c = data[i];\n                    }\n                    if (index < boundary.length) {\n                        if (boundary[index] === c) {\n                            if (index === 0) {\n                                dataCallback(\"onPartData\", true);\n                            }\n                            index++;\n                        } else {\n                            index = 0;\n                        }\n                    } else if (index === boundary.length) {\n                        index++;\n                        if (c === CR) {\n                            // CR = part boundary\n                            flags |= F.PART_BOUNDARY;\n                        } else if (c === HYPHEN) {\n                            // HYPHEN = end boundary\n                            flags |= F.LAST_BOUNDARY;\n                        } else {\n                            index = 0;\n                        }\n                    } else if (index - 1 === boundary.length) {\n                        if (flags & F.PART_BOUNDARY) {\n                            index = 0;\n                            if (c === LF) {\n                                // unset the PART_BOUNDARY flag\n                                flags &= ~F.PART_BOUNDARY;\n                                callback(\"onPartEnd\");\n                                callback(\"onPartBegin\");\n                                state = S.HEADER_FIELD_START;\n                                break;\n                            }\n                        } else if (flags & F.LAST_BOUNDARY) {\n                            if (c === HYPHEN) {\n                                callback(\"onPartEnd\");\n                                state = S.END;\n                                flags = 0;\n                            } else {\n                                index = 0;\n                            }\n                        } else {\n                            index = 0;\n                        }\n                    }\n                    if (index > 0) {\n                        // when matching a possible boundary, keep a lookbehind reference\n                        // in case it turns out to be a false lead\n                        lookbehind[index - 1] = c;\n                    } else if (previousIndex > 0) {\n                        // if our boundary turned out to be rubbish, the captured lookbehind\n                        // belongs to partData\n                        const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n                        callback(\"onPartData\", 0, previousIndex, _lookbehind);\n                        previousIndex = 0;\n                        mark(\"onPartData\");\n                        // reconsider the current character even so it interrupted the sequence\n                        // it could be the beginning of a new sequence\n                        i--;\n                    }\n                    break;\n                case S.END:\n                    break;\n                default:\n                    throw new Error(`Unexpected state entered: ${state}`);\n            }\n        }\n        dataCallback(\"onHeaderField\");\n        dataCallback(\"onHeaderValue\");\n        dataCallback(\"onPartData\");\n        // Update properties for the next call\n        this.index = index;\n        this.state = state;\n        this.flags = flags;\n    }\n    end() {\n        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n            this.onPartEnd();\n        } else if (this.state !== S.END) {\n            throw new Error(\"MultipartParser.end(): stream ended unexpectedly\");\n        }\n    }\n}\nfunction _fileName(headerValue) {\n    // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n    const m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n    if (!m) {\n        return;\n    }\n    const match = m[2] || m[3] || \"\";\n    let filename = match.slice(match.lastIndexOf(\"\\\\\") + 1);\n    filename = filename.replace(/%22/g, '\"');\n    filename = filename.replace(/&#(\\d{4});/g, (m, code)=>{\n        return String.fromCharCode(code);\n    });\n    return filename;\n}\nasync function toFormData(Body, ct) {\n    if (!/multipart/i.test(ct)) {\n        throw new TypeError(\"Failed to fetch\");\n    }\n    const m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n    if (!m) {\n        throw new TypeError(\"no or bad content-type header, no multipart boundary\");\n    }\n    const parser = new MultipartParser(m[1] || m[2]);\n    let headerField;\n    let headerValue;\n    let entryValue;\n    let entryName;\n    let contentType;\n    let filename;\n    const entryChunks = [];\n    const formData = new abortController.FormData();\n    const onPartData = (ui8a)=>{\n        entryValue += decoder.decode(ui8a, {\n            stream: true\n        });\n    };\n    const appendToFile = (ui8a)=>{\n        entryChunks.push(ui8a);\n    };\n    const appendFileToFormData = ()=>{\n        const file = new abortController.File(entryChunks, filename, {\n            type: contentType\n        });\n        formData.append(entryName, file);\n    };\n    const appendEntryToFormData = ()=>{\n        formData.append(entryName, entryValue);\n    };\n    const decoder = new TextDecoder(\"utf-8\");\n    decoder.decode();\n    parser.onPartBegin = function() {\n        parser.onPartData = onPartData;\n        parser.onPartEnd = appendEntryToFormData;\n        headerField = \"\";\n        headerValue = \"\";\n        entryValue = \"\";\n        entryName = \"\";\n        contentType = \"\";\n        filename = null;\n        entryChunks.length = 0;\n    };\n    parser.onHeaderField = function(ui8a) {\n        headerField += decoder.decode(ui8a, {\n            stream: true\n        });\n    };\n    parser.onHeaderValue = function(ui8a) {\n        headerValue += decoder.decode(ui8a, {\n            stream: true\n        });\n    };\n    parser.onHeaderEnd = function() {\n        headerValue += decoder.decode();\n        headerField = headerField.toLowerCase();\n        if (headerField === \"content-disposition\") {\n            // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n            const m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n            if (m) {\n                entryName = m[2] || m[3] || \"\";\n            }\n            filename = _fileName(headerValue);\n            if (filename) {\n                parser.onPartData = appendToFile;\n                parser.onPartEnd = appendFileToFormData;\n            }\n        } else if (headerField === \"content-type\") {\n            contentType = headerValue;\n        }\n        headerValue = \"\";\n        headerField = \"\";\n    };\n    for await (const chunk of Body){\n        parser.write(chunk);\n    }\n    parser.end();\n    return formData;\n}\nexports.toFormData = toFormData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9jaHVua3MvbXVsdGlwYXJ0LXBhcnNlci5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUixNQUFNQyxrQkFBa0JELG1CQUFPQSxDQUFDO0FBQ2hDQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLElBQUlFLElBQUk7QUFDUixNQUFNQyxJQUFJO0lBQ1RDLGdCQUFnQkY7SUFDaEJHLG9CQUFvQkg7SUFDcEJJLGNBQWNKO0lBQ2RLLG9CQUFvQkw7SUFDcEJNLGNBQWNOO0lBQ2RPLDBCQUEwQlA7SUFDMUJRLHFCQUFxQlI7SUFDckJTLGlCQUFpQlQ7SUFDakJVLFdBQVdWO0lBQ1hXLEtBQUtYO0FBQ047QUFFQSxJQUFJWSxJQUFJO0FBQ1IsTUFBTUMsSUFBSTtJQUNUQyxlQUFlRjtJQUNmRyxlQUFlSCxLQUFLO0FBQ3JCO0FBRUEsTUFBTUksS0FBSztBQUNYLE1BQU1DLEtBQUs7QUFDWCxNQUFNQyxRQUFRO0FBQ2QsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxJQUFJO0FBQ1YsTUFBTUMsSUFBSTtBQUVWLE1BQU1DLFFBQVFDLENBQUFBLElBQUtBLElBQUk7QUFFdkIsTUFBTUMsT0FBTyxLQUFPO0FBRXBCLE1BQU1DO0lBQ0w7O0VBRUMsR0FDREMsWUFBWUMsUUFBUSxDQUFFO1FBQ3JCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFFYixJQUFJLENBQUNDLFdBQVcsR0FBR047UUFDbkIsSUFBSSxDQUFDTyxhQUFhLEdBQUdQO1FBQ3JCLElBQUksQ0FB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UUFBUTtRQUFJO0lBQ2xEO0lBRUFWLE9BQU9wRCxhQUFhLEdBQUcsU0FBVUssSUFBSTtRQUNwQ2dDLGVBQWV1QixRQUFRQyxNQUFNLENBQUN4RCxNQUFNO1lBQUN5RCxRQUFRO1FBQUk7SUFDbEQ7SUFFQVYsT0FBT3ZELFdBQVcsR0FBRztRQUNwQndDLGVBQWV1QixRQUFRQyxNQUFNO1FBQzdCUixjQUFjQSxZQUFZbUIsV0FBVztRQUVyQyxJQUFJbkIsZ0JBQWdCLHVCQUF1QjtZQUMxQyxzRUFBc0U7WUFDdEUsTUFBTWYsSUFBSUQsWUFBWUUsS0FBSyxDQUFDO1lBRTVCLElBQUlELEdBQUc7Z0JBQ05pQixZQUFZakIsQ0FBQyxDQUFDLEVBQUUsSUFBSUEsQ0FBQyxDQUFDLEVBQUUsSUFBSTtZQUM3QjtZQUVBRSxXQUFXSixVQUFVQztZQUVyQixJQUFJRyxVQUFVO2dCQUNiWSxPQUFPbEQsVUFBVSxHQUFHNkQ7Z0JBQ3BCWCxPQUFPakQsU0FBUyxHQUFHOEQ7WUFDcEI7UUFDRCxPQUFPLElBQUlaLGdCQUFnQixnQkFBZ0I7WUFDMUNHLGNBQWNuQjtRQUNmO1FBRUFBLGNBQWM7UUFDZGdCLGNBQWM7SUFDZjtJQUVBLFdBQVcsTUFBTW9CLFNBQVN6QixLQUFNO1FBQy9CSSxPQUFPeEMsS0FBSyxDQUFDNkQ7SUFDZDtJQUVBckIsT0FBTzFCLEdBQUc7SUFFVixPQUFPZ0M7QUFDUjtBQUVBZ0Isa0JBQWtCLEdBQUczQiIsInNvdXJjZXMiOlsid2VicGFjazovL21lcm5wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gtbmF0aXZlL2Rpc3QvY2h1bmtzL211bHRpcGFydC1wYXJzZXIuY2pzPzRhZmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCdub2RlOmZzJyk7XG5yZXF1aXJlKCdub2RlOnBhdGgnKTtcbmNvbnN0IGFib3J0Q29udHJvbGxlciA9IHJlcXVpcmUoJy4uL3NoYXJlZC9ub2RlLWZldGNoLW5hdGl2ZS44YWZkM2ZlYS5janMnKTtcbnJlcXVpcmUoJ25vZGU6aHR0cCcpO1xucmVxdWlyZSgnbm9kZTpodHRwcycpO1xucmVxdWlyZSgnbm9kZTp6bGliJyk7XG5yZXF1aXJlKCdub2RlOnN0cmVhbScpO1xucmVxdWlyZSgnbm9kZTpidWZmZXInKTtcbnJlcXVpcmUoJ25vZGU6dXRpbCcpO1xucmVxdWlyZSgnbm9kZTp1cmwnKTtcbnJlcXVpcmUoJ25vZGU6bmV0Jyk7XG5cbmxldCBzID0gMDtcbmNvbnN0IFMgPSB7XG5cdFNUQVJUX0JPVU5EQVJZOiBzKyssXG5cdEhFQURFUl9GSUVMRF9TVEFSVDogcysrLFxuXHRIRUFERVJfRklFTEQ6IHMrKyxcblx0SEVBREVSX1ZBTFVFX1NUQVJUOiBzKyssXG5cdEhFQURFUl9WQUxVRTogcysrLFxuXHRIRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU6IHMrKyxcblx0SEVBREVSU19BTE1PU1RfRE9ORTogcysrLFxuXHRQQVJUX0RBVEFfU1RBUlQ6IHMrKyxcblx0UEFSVF9EQVRBOiBzKyssXG5cdEVORDogcysrXG59O1xuXG5sZXQgZiA9IDE7XG5jb25zdCBGID0ge1xuXHRQQVJUX0JPVU5EQVJZOiBmLFxuXHRMQVNUX0JPVU5EQVJZOiBmICo9IDJcbn07XG5cbmNvbnN0IExGID0gMTA7XG5jb25zdCBDUiA9IDEzO1xuY29uc3QgU1BBQ0UgPSAzMjtcbmNvbnN0IEhZUEhFTiA9IDQ1O1xuY29uc3QgQ09MT04gPSA1ODtcbmNvbnN0IEEgPSA5NztcbmNvbnN0IFogPSAxMjI7XG5cbmNvbnN0IGxvd2VyID0gYyA9PiBjIHwgMHgyMDtcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5jbGFzcyBNdWx0aXBhcnRQYXJzZXIge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kYXJ5XG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihib3VuZGFyeSkge1xuXHRcdHRoaXMuaW5kZXggPSAwO1xuXHRcdHRoaXMuZmxhZ3MgPSAwO1xuXG5cdFx0dGhpcy5vbkhlYWRlckVuZCA9IG5vb3A7XG5cdFx0dGhpcy5vbkhlYWRlckZpZWxkID0gbm9vcDtcblx0XHR0aGlzLm9uSGVhZGVyc0VuZCA9IG5vb3A7XG5cdFx0dGhpcy5vbkhlYWRlclZhbHVlID0gbm9vcDtcblx0XHR0aGlzLm9uUGFydEJlZ2luID0gbm9vcDtcblx0XHR0aGlzLm9uUGFydERhdGEgPSBub29wO1xuXHRcdHRoaXMub25QYXJ0RW5kID0gbm9vcDtcblxuXHRcdHRoaXMuYm91bmRhcnlDaGFycyA9IHt9O1xuXG5cdFx0Ym91bmRhcnkgPSAnXFxyXFxuLS0nICsgYm91bmRhcnk7XG5cdFx0Y29uc3QgdWk4YSA9IG5ldyBVaW50OEFycmF5KGJvdW5kYXJ5Lmxlbmd0aCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZGFyeS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dWk4YVtpXSA9IGJvdW5kYXJ5LmNoYXJDb2RlQXQoaSk7XG5cdFx0XHR0aGlzLmJvdW5kYXJ5Q2hhcnNbdWk4YVtpXV0gPSB0cnVlO1xuXHRcdH1cblxuXHRcdHRoaXMuYm91bmRhcnkgPSB1aThhO1xuXHRcdHRoaXMubG9va2JlaGluZCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYm91bmRhcnkubGVuZ3RoICsgOCk7XG5cdFx0dGhpcy5zdGF0ZSA9IFMuU1RBUlRfQk9VTkRBUlk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG5cdCAqL1xuXHR3cml0ZShkYXRhKSB7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGNvbnN0IGxlbmd0aF8gPSBkYXRhLmxlbmd0aDtcblx0XHRsZXQgcHJldmlvdXNJbmRleCA9IHRoaXMuaW5kZXg7XG5cdFx0bGV0IHtsb29rYmVoaW5kLCBib3VuZGFyeSwgYm91bmRhcnlDaGFycywgaW5kZXgsIHN0YXRlLCBmbGFnc30gPSB0aGlzO1xuXHRcdGNvbnN0IGJvdW5kYXJ5TGVuZ3RoID0gdGhpcy5ib3VuZGFyeS5sZW5ndGg7XG5cdFx0Y29uc3QgYm91bmRhcnlFbmQgPSBib3VuZGFyeUxlbmd0aCAtIDE7XG5cdFx0Y29uc3QgYnVmZmVyTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cdFx0bGV0IGM7XG5cdFx0bGV0IGNsO1xuXG5cdFx0Y29uc3QgbWFyayA9IG5hbWUgPT4ge1xuXHRcdFx0dGhpc1tuYW1lICsgJ01hcmsnXSA9IGk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IGNsZWFyID0gbmFtZSA9PiB7XG5cdFx0XHRkZWxldGUgdGhpc1tuYW1lICsgJ01hcmsnXTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgY2FsbGJhY2sgPSAoY2FsbGJhY2tTeW1ib2wsIHN0YXJ0LCBlbmQsIHVpOGEpID0+IHtcblx0XHRcdGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0ICE9PSBlbmQpIHtcblx0XHRcdFx0dGhpc1tjYWxsYmFja1N5bWJvbF0odWk4YSAmJiB1aThhLnN1YmFycmF5KHN0YXJ0LCBlbmQpKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3QgZGF0YUNhbGxiYWNrID0gKG5hbWUsIGNsZWFyKSA9PiB7XG5cdFx0XHRjb25zdCBtYXJrU3ltYm9sID0gbmFtZSArICdNYXJrJztcblx0XHRcdGlmICghKG1hcmtTeW1ib2wgaW4gdGhpcykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xlYXIpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmFtZSwgdGhpc1ttYXJrU3ltYm9sXSwgaSwgZGF0YSk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzW21hcmtTeW1ib2xdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sobmFtZSwgdGhpc1ttYXJrU3ltYm9sXSwgZGF0YS5sZW5ndGgsIGRhdGEpO1xuXHRcdFx0XHR0aGlzW21hcmtTeW1ib2xdID0gMDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aF87IGkrKykge1xuXHRcdFx0YyA9IGRhdGFbaV07XG5cblx0XHRcdHN3aXRjaCAoc3RhdGUpIHtcblx0XHRcdFx0Y2FzZSBTLlNUQVJUX0JPVU5EQVJZOlxuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gYm91bmRhcnkubGVuZ3RoIC0gMikge1xuXHRcdFx0XHRcdFx0aWYgKGMgPT09IEhZUEhFTikge1xuXHRcdFx0XHRcdFx0XHRmbGFncyB8PSBGLkxBU1RfQk9VTkRBUlk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgIT09IENSKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggLSAxID09PSBib3VuZGFyeS5sZW5ndGggLSAyKSB7XG5cdFx0XHRcdFx0XHRpZiAoZmxhZ3MgJiBGLkxBU1RfQk9VTkRBUlkgJiYgYyA9PT0gSFlQSEVOKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gUy5FTkQ7XG5cdFx0XHRcdFx0XHRcdGZsYWdzID0gMDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIShmbGFncyAmIEYuTEFTVF9CT1VOREFSWSkgJiYgYyA9PT0gTEYpIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjaygnb25QYXJ0QmVnaW4nKTtcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRF9TVEFSVDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMgIT09IGJvdW5kYXJ5W2luZGV4ICsgMl0pIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gLTI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMgPT09IGJvdW5kYXJ5W2luZGV4ICsgMl0pIHtcblx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5IRUFERVJfRklFTERfU1RBUlQ6XG5cdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRDtcblx0XHRcdFx0XHRtYXJrKCdvbkhlYWRlckZpZWxkJyk7XG5cdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdC8vIGZhbGxzIHRocm91Z2hcblx0XHRcdFx0Y2FzZSBTLkhFQURFUl9GSUVMRDpcblx0XHRcdFx0XHRpZiAoYyA9PT0gQ1IpIHtcblx0XHRcdFx0XHRcdGNsZWFyKCdvbkhlYWRlckZpZWxkJyk7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFMuSEVBREVSU19BTE1PU1RfRE9ORTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0aWYgKGMgPT09IEhZUEhFTikge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMgPT09IENPTE9OKSB7XG5cdFx0XHRcdFx0XHRpZiAoaW5kZXggPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0Ly8gZW1wdHkgaGVhZGVyIGZpZWxkXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlckZpZWxkJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFMuSEVBREVSX1ZBTFVFX1NUQVJUO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2wgPSBsb3dlcihjKTtcblx0XHRcdFx0XHRpZiAoY2wgPCBBIHx8IGNsID4gWikge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFMuSEVBREVSX1ZBTFVFX1NUQVJUOlxuXHRcdFx0XHRcdGlmIChjID09PSBTUEFDRSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWFyaygnb25IZWFkZXJWYWx1ZScpO1xuXHRcdFx0XHRcdHN0YXRlID0gUy5IRUFERVJfVkFMVUU7XG5cdFx0XHRcdFx0Ly8gZmFsbHMgdGhyb3VnaFxuXHRcdFx0XHRjYXNlIFMuSEVBREVSX1ZBTFVFOlxuXHRcdFx0XHRcdGlmIChjID09PSBDUikge1xuXHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlclZhbHVlJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygnb25IZWFkZXJFbmQnKTtcblx0XHRcdFx0XHRcdHN0YXRlID0gUy5IRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5IRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU6XG5cdFx0XHRcdFx0aWYgKGMgIT09IExGKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRF9TVEFSVDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBTLkhFQURFUlNfQUxNT1NUX0RPTkU6XG5cdFx0XHRcdFx0aWYgKGMgIT09IExGKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FsbGJhY2soJ29uSGVhZGVyc0VuZCcpO1xuXHRcdFx0XHRcdHN0YXRlID0gUy5QQVJUX0RBVEFfU1RBUlQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5QQVJUX0RBVEFfU1RBUlQ6XG5cdFx0XHRcdFx0c3RhdGUgPSBTLlBBUlRfREFUQTtcblx0XHRcdFx0XHRtYXJrKCdvblBhcnREYXRhJyk7XG5cdFx0XHRcdFx0Ly8gZmFsbHMgdGhyb3VnaFxuXHRcdFx0XHRjYXNlIFMuUEFSVF9EQVRBOlxuXHRcdFx0XHRcdHByZXZpb3VzSW5kZXggPSBpbmRleDtcblxuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Ly8gYm95ZXItbW9vcmUgZGVycml2ZWQgYWxnb3JpdGhtIHRvIHNhZmVseSBza2lwIG5vbi1ib3VuZGFyeSBkYXRhXG5cdFx0XHRcdFx0XHRpICs9IGJvdW5kYXJ5RW5kO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBidWZmZXJMZW5ndGggJiYgIShkYXRhW2ldIGluIGJvdW5kYXJ5Q2hhcnMpKSB7XG5cdFx0XHRcdFx0XHRcdGkgKz0gYm91bmRhcnlMZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGkgLT0gYm91bmRhcnlFbmQ7XG5cdFx0XHRcdFx0XHRjID0gZGF0YVtpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaW5kZXggPCBib3VuZGFyeS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmIChib3VuZGFyeVtpbmRleF0gPT09IGMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGluZGV4ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKCdvblBhcnREYXRhJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IGJvdW5kYXJ5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdGlmIChjID09PSBDUikge1xuXHRcdFx0XHRcdFx0XHQvLyBDUiA9IHBhcnQgYm91bmRhcnlcblx0XHRcdFx0XHRcdFx0ZmxhZ3MgfD0gRi5QQVJUX0JPVU5EQVJZO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBIWVBIRU4pIHtcblx0XHRcdFx0XHRcdFx0Ly8gSFlQSEVOID0gZW5kIGJvdW5kYXJ5XG5cdFx0XHRcdFx0XHRcdGZsYWdzIHw9IEYuTEFTVF9CT1VOREFSWTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGluZGV4IC0gMSA9PT0gYm91bmRhcnkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoZmxhZ3MgJiBGLlBBUlRfQk9VTkRBUlkpIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHRpZiAoYyA9PT0gTEYpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB1bnNldCB0aGUgUEFSVF9CT1VOREFSWSBmbGFnXG5cdFx0XHRcdFx0XHRcdFx0ZmxhZ3MgJj0gfkYuUEFSVF9CT1VOREFSWTtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjaygnb25QYXJ0RW5kJyk7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soJ29uUGFydEJlZ2luJyk7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUgPSBTLkhFQURFUl9GSUVMRF9TVEFSVDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChmbGFncyAmIEYuTEFTVF9CT1VOREFSWSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYyA9PT0gSFlQSEVOKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soJ29uUGFydEVuZCcpO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlID0gUy5FTkQ7XG5cdFx0XHRcdFx0XHRcdFx0ZmxhZ3MgPSAwO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpbmRleCA+IDApIHtcblx0XHRcdFx0XHRcdC8vIHdoZW4gbWF0Y2hpbmcgYSBwb3NzaWJsZSBib3VuZGFyeSwga2VlcCBhIGxvb2tiZWhpbmQgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHQvLyBpbiBjYXNlIGl0IHR1cm5zIG91dCB0byBiZSBhIGZhbHNlIGxlYWRcblx0XHRcdFx0XHRcdGxvb2tiZWhpbmRbaW5kZXggLSAxXSA9IGM7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwcmV2aW91c0luZGV4ID4gMCkge1xuXHRcdFx0XHRcdFx0Ly8gaWYgb3VyIGJvdW5kYXJ5IHR1cm5lZCBvdXQgdG8gYmUgcnViYmlzaCwgdGhlIGNhcHR1cmVkIGxvb2tiZWhpbmRcblx0XHRcdFx0XHRcdC8vIGJlbG9uZ3MgdG8gcGFydERhdGFcblx0XHRcdFx0XHRcdGNvbnN0IF9sb29rYmVoaW5kID0gbmV3IFVpbnQ4QXJyYXkobG9va2JlaGluZC5idWZmZXIsIGxvb2tiZWhpbmQuYnl0ZU9mZnNldCwgbG9va2JlaGluZC5ieXRlTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCdvblBhcnREYXRhJywgMCwgcHJldmlvdXNJbmRleCwgX2xvb2tiZWhpbmQpO1xuXHRcdFx0XHRcdFx0cHJldmlvdXNJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRtYXJrKCdvblBhcnREYXRhJyk7XG5cblx0XHRcdFx0XHRcdC8vIHJlY29uc2lkZXIgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGV2ZW4gc28gaXQgaW50ZXJydXB0ZWQgdGhlIHNlcXVlbmNlXG5cdFx0XHRcdFx0XHQvLyBpdCBjb3VsZCBiZSB0aGUgYmVnaW5uaW5nIG9mIGEgbmV3IHNlcXVlbmNlXG5cdFx0XHRcdFx0XHRpLS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUy5FTkQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHN0YXRlIGVudGVyZWQ6ICR7c3RhdGV9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlckZpZWxkJyk7XG5cdFx0ZGF0YUNhbGxiYWNrKCdvbkhlYWRlclZhbHVlJyk7XG5cdFx0ZGF0YUNhbGxiYWNrKCdvblBhcnREYXRhJyk7XG5cblx0XHQvLyBVcGRhdGUgcHJvcGVydGllcyBmb3IgdGhlIG5leHQgY2FsbFxuXHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XG5cdFx0dGhpcy5mbGFncyA9IGZsYWdzO1xuXHR9XG5cblx0ZW5kKCkge1xuXHRcdGlmICgodGhpcy5zdGF0ZSA9PT0gUy5IRUFERVJfRklFTERfU1RBUlQgJiYgdGhpcy5pbmRleCA9PT0gMCkgfHxcblx0XHRcdCh0aGlzLnN0YXRlID09PSBTLlBBUlRfREFUQSAmJiB0aGlzLmluZGV4ID09PSB0aGlzLmJvdW5kYXJ5Lmxlbmd0aCkpIHtcblx0XHRcdHRoaXMub25QYXJ0RW5kKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN0YXRlICE9PSBTLkVORCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdWx0aXBhcnRQYXJzZXIuZW5kKCk6IHN0cmVhbSBlbmRlZCB1bmV4cGVjdGVkbHknKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gX2ZpbGVOYW1lKGhlYWRlclZhbHVlKSB7XG5cdC8vIG1hdGNoZXMgZWl0aGVyIGEgcXVvdGVkLXN0cmluZyBvciBhIHRva2VuIChSRkMgMjYxNiBzZWN0aW9uIDE5LjUuMSlcblx0Y29uc3QgbSA9IGhlYWRlclZhbHVlLm1hdGNoKC9cXGJmaWxlbmFtZT0oXCIoLio/KVwifChbXigpPD5ALDs6XFxcXFwiL1tcXF0/PXt9XFxzXFx0XSspKSgkfDtcXHMpL2kpO1xuXHRpZiAoIW0pIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBtYXRjaCA9IG1bMl0gfHwgbVszXSB8fCAnJztcblx0bGV0IGZpbGVuYW1lID0gbWF0Y2guc2xpY2UobWF0Y2gubGFzdEluZGV4T2YoJ1xcXFwnKSArIDEpO1xuXHRmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoLyUyMi9nLCAnXCInKTtcblx0ZmlsZW5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKC8mIyhcXGR7NH0pOy9nLCAobSwgY29kZSkgPT4ge1xuXHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXHR9KTtcblx0cmV0dXJuIGZpbGVuYW1lO1xufVxuXG5hc3luYyBmdW5jdGlvbiB0b0Zvcm1EYXRhKEJvZHksIGN0KSB7XG5cdGlmICghL211bHRpcGFydC9pLnRlc3QoY3QpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGZldGNoJyk7XG5cdH1cblxuXHRjb25zdCBtID0gY3QubWF0Y2goL2JvdW5kYXJ5PSg/OlwiKFteXCJdKylcInwoW147XSspKS9pKTtcblxuXHRpZiAoIW0pIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBvciBiYWQgY29udGVudC10eXBlIGhlYWRlciwgbm8gbXVsdGlwYXJ0IGJvdW5kYXJ5Jyk7XG5cdH1cblxuXHRjb25zdCBwYXJzZXIgPSBuZXcgTXVsdGlwYXJ0UGFyc2VyKG1bMV0gfHwgbVsyXSk7XG5cblx0bGV0IGhlYWRlckZpZWxkO1xuXHRsZXQgaGVhZGVyVmFsdWU7XG5cdGxldCBlbnRyeVZhbHVlO1xuXHRsZXQgZW50cnlOYW1lO1xuXHRsZXQgY29udGVudFR5cGU7XG5cdGxldCBmaWxlbmFtZTtcblx0Y29uc3QgZW50cnlDaHVua3MgPSBbXTtcblx0Y29uc3QgZm9ybURhdGEgPSBuZXcgYWJvcnRDb250cm9sbGVyLkZvcm1EYXRhKCk7XG5cblx0Y29uc3Qgb25QYXJ0RGF0YSA9IHVpOGEgPT4ge1xuXHRcdGVudHJ5VmFsdWUgKz0gZGVjb2Rlci5kZWNvZGUodWk4YSwge3N0cmVhbTogdHJ1ZX0pO1xuXHR9O1xuXG5cdGNvbnN0IGFwcGVuZFRvRmlsZSA9IHVpOGEgPT4ge1xuXHRcdGVudHJ5Q2h1bmtzLnB1c2godWk4YSk7XG5cdH07XG5cblx0Y29uc3QgYXBwZW5kRmlsZVRvRm9ybURhdGEgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZmlsZSA9IG5ldyBhYm9ydENvbnRyb2xsZXIuRmlsZShlbnRyeUNodW5rcywgZmlsZW5hbWUsIHt0eXBlOiBjb250ZW50VHlwZX0pO1xuXHRcdGZvcm1EYXRhLmFwcGVuZChlbnRyeU5hbWUsIGZpbGUpO1xuXHR9O1xuXG5cdGNvbnN0IGFwcGVuZEVudHJ5VG9Gb3JtRGF0YSA9ICgpID0+IHtcblx0XHRmb3JtRGF0YS5hcHBlbmQoZW50cnlOYW1lLCBlbnRyeVZhbHVlKTtcblx0fTtcblxuXHRjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuXHRkZWNvZGVyLmRlY29kZSgpO1xuXG5cdHBhcnNlci5vblBhcnRCZWdpbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRwYXJzZXIub25QYXJ0RGF0YSA9IG9uUGFydERhdGE7XG5cdFx0cGFyc2VyLm9uUGFydEVuZCA9IGFwcGVuZEVudHJ5VG9Gb3JtRGF0YTtcblxuXHRcdGhlYWRlckZpZWxkID0gJyc7XG5cdFx0aGVhZGVyVmFsdWUgPSAnJztcblx0XHRlbnRyeVZhbHVlID0gJyc7XG5cdFx0ZW50cnlOYW1lID0gJyc7XG5cdFx0Y29udGVudFR5cGUgPSAnJztcblx0XHRmaWxlbmFtZSA9IG51bGw7XG5cdFx0ZW50cnlDaHVua3MubGVuZ3RoID0gMDtcblx0fTtcblxuXHRwYXJzZXIub25IZWFkZXJGaWVsZCA9IGZ1bmN0aW9uICh1aThhKSB7XG5cdFx0aGVhZGVyRmllbGQgKz0gZGVjb2Rlci5kZWNvZGUodWk4YSwge3N0cmVhbTogdHJ1ZX0pO1xuXHR9O1xuXG5cdHBhcnNlci5vbkhlYWRlclZhbHVlID0gZnVuY3Rpb24gKHVpOGEpIHtcblx0XHRoZWFkZXJWYWx1ZSArPSBkZWNvZGVyLmRlY29kZSh1aThhLCB7c3RyZWFtOiB0cnVlfSk7XG5cdH07XG5cblx0cGFyc2VyLm9uSGVhZGVyRW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdGhlYWRlclZhbHVlICs9IGRlY29kZXIuZGVjb2RlKCk7XG5cdFx0aGVhZGVyRmllbGQgPSBoZWFkZXJGaWVsZC50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKGhlYWRlckZpZWxkID09PSAnY29udGVudC1kaXNwb3NpdGlvbicpIHtcblx0XHRcdC8vIG1hdGNoZXMgZWl0aGVyIGEgcXVvdGVkLXN0cmluZyBvciBhIHRva2VuIChSRkMgMjYxNiBzZWN0aW9uIDE5LjUuMSlcblx0XHRcdGNvbnN0IG0gPSBoZWFkZXJWYWx1ZS5tYXRjaCgvXFxibmFtZT0oXCIoW15cIl0qKVwifChbXigpPD5ALDs6XFxcXFwiL1tcXF0/PXt9XFxzXFx0XSspKS9pKTtcblxuXHRcdFx0aWYgKG0pIHtcblx0XHRcdFx0ZW50cnlOYW1lID0gbVsyXSB8fCBtWzNdIHx8ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHRmaWxlbmFtZSA9IF9maWxlTmFtZShoZWFkZXJWYWx1ZSk7XG5cblx0XHRcdGlmIChmaWxlbmFtZSkge1xuXHRcdFx0XHRwYXJzZXIub25QYXJ0RGF0YSA9IGFwcGVuZFRvRmlsZTtcblx0XHRcdFx0cGFyc2VyLm9uUGFydEVuZCA9IGFwcGVuZEZpbGVUb0Zvcm1EYXRhO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoaGVhZGVyRmllbGQgPT09ICdjb250ZW50LXR5cGUnKSB7XG5cdFx0XHRjb250ZW50VHlwZSA9IGhlYWRlclZhbHVlO1xuXHRcdH1cblxuXHRcdGhlYWRlclZhbHVlID0gJyc7XG5cdFx0aGVhZGVyRmllbGQgPSAnJztcblx0fTtcblxuXHRmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIEJvZHkpIHtcblx0XHRwYXJzZXIud3JpdGUoY2h1bmspO1xuXHR9XG5cblx0cGFyc2VyLmVuZCgpO1xuXG5cdHJldHVybiBmb3JtRGF0YTtcbn1cblxuZXhwb3J0cy50b0Zvcm1EYXRhID0gdG9Gb3JtRGF0YTtcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiYWJvcnRDb250cm9sbGVyIiwicyIsIlMiLCJTVEFSVF9CT1VOREFSWSIsIkhFQURFUl9GSUVMRF9TVEFSVCIsIkhFQURFUl9GSUVMRCIsIkhFQURFUl9WQUxVRV9TVEFSVCIsIkhFQURFUl9WQUxVRSIsIkhFQURFUl9WQUxVRV9BTE1PU1RfRE9ORSIsIkhFQURFUlNfQUxNT1NUX0RPTkUiLCJQQVJUX0RBVEFfU1RBUlQiLCJQQVJUX0RBVEEiLCJFTkQiLCJmIiwiRiIsIlBBUlRfQk9VTkRBUlkiLCJMQVNUX0JPVU5EQVJZIiwiTEYiLCJDUiIsIlNQQUNFIiwiSFlQSEVOIiwiQ09MT04iLCJBIiwiWiIsImxvd2VyIiwiYyIsIm5vb3AiLCJNdWx0aXBhcnRQYXJzZXIiLCJjb25zdHJ1Y3RvciIsImJvdW5kYXJ5IiwiaW5kZXgiLCJmbGFncyIsIm9uSGVhZGVyRW5kIiwib25IZWFkZXJGaWVsZCIsIm9uSGVhZGVyc0VuZCIsIm9uSGVhZGVyVmFsdWUiLCJvblBhcnRCZWdpbiIsIm9uUGFydERhdGEiLCJvblBhcnRFbmQiLCJib3VuZGFyeUNoYXJzIiwidWk4YSIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJpIiwiY2hhckNvZGVBdCIsImxvb2tiZWhpbmQiLCJzdGF0ZSIsIndyaXRlIiwiZGF0YSIsImxlbmd0aF8iLCJwcmV2aW91c0luZGV4IiwiYm91bmRhcnlMZW5ndGgiLCJib3VuZGFyeUVuZCIsImJ1ZmZlckxlbmd0aCIsImNsIiwibWFyayIsIm5hbWUiLCJjbGVhciIsImNhbGxiYWNrIiwiY2FsbGJhY2tTeW1ib2wiLCJzdGFydCIsImVuZCIsInVuZGVmaW5lZCIsInN1YmFycmF5IiwiZGF0YUNhbGxiYWNrIiwibWFya1N5bWJvbCIsIl9sb29rYmVoaW5kIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJFcnJvciIsIl9maWxlTmFtZSIsImhlYWRlclZhbHVlIiwibSIsIm1hdGNoIiwiZmlsZW5hbWUiLCJzbGljZSIsImxhc3RJbmRleE9mIiwicmVwbGFjZSIsImNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ0b0Zvcm1EYXRhIiwiQm9keSIsImN0IiwidGVzdCIsIlR5cGVFcnJvciIsInBhcnNlciIsImhlYWRlckZpZWxkIiwiZW50cnlWYWx1ZSIsImVudHJ5TmFtZSIsImNvbnRlbnRUeXBlIiwiZW50cnlDaHVua3MiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiZGVjb2RlciIsImRlY29kZSIsInN0cmVhbSIsImFwcGVuZFRvRmlsZSIsInB1c2giLCJhcHBlbmRGaWxlVG9Gb3JtRGF0YSIsImZpbGUiLCJGaWxlIiwidHlwZSIsImFwcGVuZCIsImFwcGVuZEVudHJ5VG9Gb3JtRGF0YSIsIlRleHREZWNvZGVyIiwidG9Mb3dlckNhc2UiLCJjaHVuayIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst abortController = __webpack_require__(/*! ./shared/node-fetch-native.8afd3fea.cjs */ \"(rsc)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs\");\nconst node_fs = __webpack_require__(/*! node:fs */ \"node:fs\");\nconst node_path = __webpack_require__(/*! node:path */ \"node:path\");\n__webpack_require__(/*! node:http */ \"node:http\");\n__webpack_require__(/*! node:https */ \"node:https\");\n__webpack_require__(/*! node:zlib */ \"node:zlib\");\n__webpack_require__(/*! node:stream */ \"node:stream\");\n__webpack_require__(/*! node:buffer */ \"node:buffer\");\n__webpack_require__(/*! node:util */ \"node:util\");\n__webpack_require__(/*! node:url */ \"node:url\");\n__webpack_require__(/*! node:net */ \"node:net\");\nconst { stat } = node_fs.promises;\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */ const blobFromSync = (path, type)=>fromBlob(node_fs.statSync(path), path, type);\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */ const blobFrom = (path, type)=>stat(path).then((stat)=>fromBlob(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */ const fileFrom = (path, type)=>stat(path).then((stat)=>fromFile(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */ const fileFromSync = (path, type)=>fromFile(node_fs.statSync(path), path, type);\n// @ts-ignore\nconst fromBlob = (stat, path, type = \"\")=>new abortController._Blob([\n        new BlobDataItem({\n            path,\n            size: stat.size,\n            lastModified: stat.mtimeMs,\n            start: 0\n        })\n    ], {\n        type\n    });\n// @ts-ignore\nconst fromFile = (stat, path, type = \"\")=>new abortController.File([\n        new BlobDataItem({\n            path,\n            size: stat.size,\n            lastModified: stat.mtimeMs,\n            start: 0\n        })\n    ], node_path.basename(path), {\n        type,\n        lastModified: stat.mtimeMs\n    });\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */ class BlobDataItem {\n    #path;\n    #start;\n    constructor(options){\n        this.#path = options.path;\n        this.#start = options.start;\n        this.size = options.size;\n        this.lastModified = options.lastModified;\n        this.originalSize = options.originalSize === undefined ? options.size : options.originalSize;\n    }\n    /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */ slice(start, end) {\n        return new BlobDataItem({\n            path: this.#path,\n            lastModified: this.lastModified,\n            originalSize: this.originalSize,\n            size: end - start,\n            start: this.#start + start\n        });\n    }\n    async *stream() {\n        const { mtimeMs, size } = await stat(this.#path);\n        if (mtimeMs > this.lastModified || this.originalSize !== size) {\n            throw new abortController.nodeDomexception(\"The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.\", \"NotReadableError\");\n        }\n        yield* node_fs.createReadStream(this.#path, {\n            start: this.#start,\n            end: this.#start + this.size - 1\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n}\nconst fetch = globalThis.fetch || abortController.fetch;\nconst Blob = globalThis.Blob || abortController._Blob;\nconst File = globalThis.File || abortController.File;\nconst FormData = globalThis.FormData || abortController.FormData;\nconst Headers = globalThis.Headers || abortController.Headers;\nconst Request = globalThis.Request || abortController.Request;\nconst Response = globalThis.Response || abortController.Response;\nconst AbortController = globalThis.AbortController || abortController.AbortController;\nexports.AbortError = abortController.AbortError;\nexports.FetchError = abortController.FetchError;\nexports.isRedirect = abortController.isRedirect;\nexports.AbortController = AbortController;\nexports.Blob = Blob;\nexports.File = File;\nexports.FormData = FormData;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports.blobFrom = blobFrom;\nexports.blobFromSync = blobFromSync;\nexports[\"default\"] = fetch;\nexports.fetch = fetch;\nexports.fileFrom = fileFrom;\nexports.fileFromSync = fileFromSync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsTUFBTUMsa0JBQWtCQyxtQkFBT0EsQ0FBQztBQUNoQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNRSxZQUFZRixtQkFBT0EsQ0FBQztBQUMxQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixNQUFNLEVBQUVHLElBQUksRUFBRSxHQUFHRixRQUFRRyxRQUFRO0FBRWpDOzs7Q0FHQyxHQUNELE1BQU1DLGVBQWUsQ0FBQ0MsTUFBTUMsT0FBU0MsU0FBU1AsUUFBUVEsUUFBUSxDQUFDSCxPQUFPQSxNQUFNQztBQUU1RTs7OztDQUlDLEdBQ0QsTUFBTUcsV0FBVyxDQUFDSixNQUFNQyxPQUFTSixLQUFLRyxNQUFNSyxJQUFJLENBQUNSLENBQUFBLE9BQVFLLFNBQVNMLE1BQU1HLE1BQU1DO0FBRTlFOzs7O0NBSUMsR0FDRCxNQUFNSyxXQUFXLENBQUNOLE1BQU1DLE9BQVNKLEtBQUtHLE1BQU1LLElBQUksQ0FBQ1IsQ0FBQUEsT0FBUVUsU0FBU1YsTUFBTUcsTUFBTUM7QUFFOUU7OztDQUdDLEdBQ0QsTUFBTU8sZUFBZSxDQUFDUixNQUFNQyxPQUFTTSxTQUFTWixRQUFRUSxRQUFRLENBQUNILE9BQU9BLE1BQU1DO0FBRTVFLGFBQWE7QUFDYixNQUFNQyxXQUFXLENBQUNMLE1BQU1HLE1BQU1DLE9BQU8sRUFBRSxHQUFLLElBQUlSLGdCQUFnQmdCLEtBQUssQ0FBQztRQUFDLElBQUlDLGFBQWE7WUFDdEZWO1lBQ0FXLE1BQU1kLEtB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QyxVQUFVO0FBQy9DL0MsdUJBQXVCLEdBQUc0QztBQUMxQjVDLFlBQVksR0FBR3VDO0FBQ2Z2QyxZQUFZLEdBQUd3QjtBQUNmeEIsZ0JBQWdCLEdBQUd3QztBQUNuQnhDLGVBQWUsR0FBR3lDO0FBQ2xCekMsZUFBZSxHQUFHMEM7QUFDbEIxQyxnQkFBZ0IsR0FBRzJDO0FBQ25CM0MsZ0JBQWdCLEdBQUdhO0FBQ25CYixvQkFBb0IsR0FBR1E7QUFDdkJSLGtCQUFlLEdBQUdxQztBQUNsQnJDLGFBQWEsR0FBR3FDO0FBQ2hCckMsZ0JBQWdCLEdBQUdlO0FBQ25CZixvQkFBb0IsR0FBR2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVybnByb2plY3QvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9pbmRleC5janM/ZDE5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IGFib3J0Q29udHJvbGxlciA9IHJlcXVpcmUoJy4vc2hhcmVkL25vZGUtZmV0Y2gtbmF0aXZlLjhhZmQzZmVhLmNqcycpO1xuY29uc3Qgbm9kZV9mcyA9IHJlcXVpcmUoJ25vZGU6ZnMnKTtcbmNvbnN0IG5vZGVfcGF0aCA9IHJlcXVpcmUoJ25vZGU6cGF0aCcpO1xucmVxdWlyZSgnbm9kZTpodHRwJyk7XG5yZXF1aXJlKCdub2RlOmh0dHBzJyk7XG5yZXF1aXJlKCdub2RlOnpsaWInKTtcbnJlcXVpcmUoJ25vZGU6c3RyZWFtJyk7XG5yZXF1aXJlKCdub2RlOmJ1ZmZlcicpO1xucmVxdWlyZSgnbm9kZTp1dGlsJyk7XG5yZXF1aXJlKCdub2RlOnVybCcpO1xucmVxdWlyZSgnbm9kZTpuZXQnKTtcblxuY29uc3QgeyBzdGF0IH0gPSBub2RlX2ZzLnByb21pc2VzO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGVwYXRoIG9uIHRoZSBkaXNrXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG1pbWV0eXBlIHRvIHVzZVxuICovXG5jb25zdCBibG9iRnJvbVN5bmMgPSAocGF0aCwgdHlwZSkgPT4gZnJvbUJsb2Iobm9kZV9mcy5zdGF0U3luYyhwYXRoKSwgcGF0aCwgdHlwZSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZmlsZXBhdGggb24gdGhlIGRpc2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gbWltZXR5cGUgdG8gdXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCbG9iPn1cbiAqL1xuY29uc3QgYmxvYkZyb20gPSAocGF0aCwgdHlwZSkgPT4gc3RhdChwYXRoKS50aGVuKHN0YXQgPT4gZnJvbUJsb2Ioc3RhdCwgcGF0aCwgdHlwZSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGVwYXRoIG9uIHRoZSBkaXNrXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG1pbWV0eXBlIHRvIHVzZVxuICogQHJldHVybnMge1Byb21pc2U8RmlsZT59XG4gKi9cbmNvbnN0IGZpbGVGcm9tID0gKHBhdGgsIHR5cGUpID0+IHN0YXQocGF0aCkudGhlbihzdGF0ID0+IGZyb21GaWxlKHN0YXQsIHBhdGgsIHR5cGUpKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlcGF0aCBvbiB0aGUgZGlza1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBtaW1ldHlwZSB0byB1c2VcbiAqL1xuY29uc3QgZmlsZUZyb21TeW5jID0gKHBhdGgsIHR5cGUpID0+IGZyb21GaWxlKG5vZGVfZnMuc3RhdFN5bmMocGF0aCksIHBhdGgsIHR5cGUpO1xuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBmcm9tQmxvYiA9IChzdGF0LCBwYXRoLCB0eXBlID0gJycpID0+IG5ldyBhYm9ydENvbnRyb2xsZXIuX0Jsb2IoW25ldyBCbG9iRGF0YUl0ZW0oe1xuICBwYXRoLFxuICBzaXplOiBzdGF0LnNpemUsXG4gIGxhc3RNb2RpZmllZDogc3RhdC5tdGltZU1zLFxuICBzdGFydDogMFxufSldLCB7IHR5cGUgfSk7XG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGZyb21GaWxlID0gKHN0YXQsIHBhdGgsIHR5cGUgPSAnJykgPT4gbmV3IGFib3J0Q29udHJvbGxlci5GaWxlKFtuZXcgQmxvYkRhdGFJdGVtKHtcbiAgcGF0aCxcbiAgc2l6ZTogc3RhdC5zaXplLFxuICBsYXN0TW9kaWZpZWQ6IHN0YXQubXRpbWVNcyxcbiAgc3RhcnQ6IDBcbn0pXSwgbm9kZV9wYXRoLmJhc2VuYW1lKHBhdGgpLCB7IHR5cGUsIGxhc3RNb2RpZmllZDogc3RhdC5tdGltZU1zIH0pO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBibG9iIGJhY2tlZCB1cCBieSBhIGZpbGUgb24gdGhlIGRpc2tcbiAqIHdpdGggbWluaXVtIHJlcXVpcmVtZW50LiBJdHMgd3JhcHBlZCBhcm91bmQgYSBCbG9iIGFzIGEgYmxvYlBhcnRcbiAqIHNvIHlvdSBoYXZlIG5vIGRpcmVjdCBhY2Nlc3MgdG8gdGhpcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBCbG9iRGF0YUl0ZW0ge1xuICAjcGF0aFxuICAjc3RhcnRcblxuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMuI3BhdGggPSBvcHRpb25zLnBhdGg7XG4gICAgdGhpcy4jc3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xuICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcbiAgICB0aGlzLmxhc3RNb2RpZmllZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkO1xuICAgIHRoaXMub3JpZ2luYWxTaXplID0gb3B0aW9ucy5vcmlnaW5hbFNpemUgPT09IHVuZGVmaW5lZFxuICAgICAgPyBvcHRpb25zLnNpemVcbiAgICAgIDogb3B0aW9ucy5vcmlnaW5hbFNpemU7XG4gIH1cblxuICAvKipcbiAgICogU2xpY2luZyBhcmd1bWVudHMgaXMgZmlyc3QgdmFsaWRhdGVkIGFuZCBmb3JtYXR0ZWRcbiAgICogdG8gbm90IGJlIG91dCBvZiByYW5nZSBieSBCbG9iLnByb3RvdHlwZS5zbGljZVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gbmV3IEJsb2JEYXRhSXRlbSh7XG4gICAgICBwYXRoOiB0aGlzLiNwYXRoLFxuICAgICAgbGFzdE1vZGlmaWVkOiB0aGlzLmxhc3RNb2RpZmllZCxcbiAgICAgIG9yaWdpbmFsU2l6ZTogdGhpcy5vcmlnaW5hbFNpemUsXG4gICAgICBzaXplOiBlbmQgLSBzdGFydCxcbiAgICAgIHN0YXJ0OiB0aGlzLiNzdGFydCArIHN0YXJ0XG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jICogc3RyZWFtICgpIHtcbiAgICBjb25zdCB7IG10aW1lTXMsIHNpemUgfSA9IGF3YWl0IHN0YXQodGhpcy4jcGF0aCk7XG5cbiAgICBpZiAobXRpbWVNcyA+IHRoaXMubGFzdE1vZGlmaWVkIHx8IHRoaXMub3JpZ2luYWxTaXplICE9PSBzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgYWJvcnRDb250cm9sbGVyLm5vZGVEb21leGNlcHRpb24oJ1RoZSByZXF1ZXN0ZWQgZmlsZSBjb3VsZCBub3QgYmUgcmVhZCwgdHlwaWNhbGx5IGR1ZSB0byBwZXJtaXNzaW9uIHByb2JsZW1zIHRoYXQgaGF2ZSBvY2N1cnJlZCBhZnRlciBhIHJlZmVyZW5jZSB0byBhIGZpbGUgd2FzIGFjcXVpcmVkLicsICdOb3RSZWFkYWJsZUVycm9yJylcbiAgICB9XG5cbiAgICB5aWVsZCAqIG5vZGVfZnMuY3JlYXRlUmVhZFN0cmVhbSh0aGlzLiNwYXRoLCB7XG4gICAgICBzdGFydDogdGhpcy4jc3RhcnQsXG4gICAgICBlbmQ6IHRoaXMuI3N0YXJ0ICsgdGhpcy5zaXplIC0gMVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICByZXR1cm4gJ0Jsb2InXG4gIH1cbn1cblxuY29uc3QgZmV0Y2ggPSBnbG9iYWxUaGlzLmZldGNoIHx8IGFib3J0Q29udHJvbGxlci5mZXRjaDtcbmNvbnN0IEJsb2IgPSBnbG9iYWxUaGlzLkJsb2IgfHwgYWJvcnRDb250cm9sbGVyLl9CbG9iO1xuY29uc3QgRmlsZSA9IGdsb2JhbFRoaXMuRmlsZSB8fCBhYm9ydENvbnRyb2xsZXIuRmlsZTtcbmNvbnN0IEZvcm1EYXRhID0gZ2xvYmFsVGhpcy5Gb3JtRGF0YSB8fCBhYm9ydENvbnRyb2xsZXIuRm9ybURhdGE7XG5jb25zdCBIZWFkZXJzID0gZ2xvYmFsVGhpcy5IZWFkZXJzIHx8IGFib3J0Q29udHJvbGxlci5IZWFkZXJzO1xuY29uc3QgUmVxdWVzdCA9IGdsb2JhbFRoaXMuUmVxdWVzdCB8fCBhYm9ydENvbnRyb2xsZXIuUmVxdWVzdDtcbmNvbnN0IFJlc3BvbnNlID0gZ2xvYmFsVGhpcy5SZXNwb25zZSB8fCBhYm9ydENvbnRyb2xsZXIuUmVzcG9uc2U7XG5jb25zdCBBYm9ydENvbnRyb2xsZXIgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlciB8fCBhYm9ydENvbnRyb2xsZXIuQWJvcnRDb250cm9sbGVyO1xuXG5leHBvcnRzLkFib3J0RXJyb3IgPSBhYm9ydENvbnRyb2xsZXIuQWJvcnRFcnJvcjtcbmV4cG9ydHMuRmV0Y2hFcnJvciA9IGFib3J0Q29udHJvbGxlci5GZXRjaEVycm9yO1xuZXhwb3J0cy5pc1JlZGlyZWN0ID0gYWJvcnRDb250cm9sbGVyLmlzUmVkaXJlY3Q7XG5leHBvcnRzLkFib3J0Q29udHJvbGxlciA9IEFib3J0Q29udHJvbGxlcjtcbmV4cG9ydHMuQmxvYiA9IEJsb2I7XG5leHBvcnRzLkZpbGUgPSBGaWxlO1xuZXhwb3J0cy5Gb3JtRGF0YSA9IEZvcm1EYXRhO1xuZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gUmVzcG9uc2U7XG5leHBvcnRzLmJsb2JGcm9tID0gYmxvYkZyb207XG5leHBvcnRzLmJsb2JGcm9tU3luYyA9IGJsb2JGcm9tU3luYztcbmV4cG9ydHMuZGVmYXVsdCA9IGZldGNoO1xuZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuZXhwb3J0cy5maWxlRnJvbSA9IGZpbGVGcm9tO1xuZXhwb3J0cy5maWxlRnJvbVN5bmMgPSBmaWxlRnJvbVN5bmM7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhYm9ydENvbnRyb2xsZXIiLCJyZXF1aXJlIiwibm9kZV9mcyIsIm5vZGVfcGF0aCIsInN0YXQiLCJwcm9taXNlcyIsImJsb2JGcm9tU3luYyIsInBhdGgiLCJ0eXBlIiwiZnJvbUJsb2IiLCJzdGF0U3luYyIsImJsb2JGcm9tIiwidGhlbiIsImZpbGVGcm9tIiwiZnJvbUZpbGUiLCJmaWxlRnJvbVN5bmMiLCJfQmxvYiIsIkJsb2JEYXRhSXRlbSIsInNpemUiLCJsYXN0TW9kaWZpZWQiLCJtdGltZU1zIiwic3RhcnQiLCJGaWxlIiwiYmFzZW5hbWUiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJvcmlnaW5hbFNpemUiLCJ1bmRlZmluZWQiLCJzbGljZSIsImVuZCIsInN0cmVhbSIsIm5vZGVEb21leGNlcHRpb24iLCJjcmVhdGVSZWFkU3RyZWFtIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJmZXRjaCIsImdsb2JhbFRoaXMiLCJCbG9iIiwiRm9ybURhdGEiLCJIZWFkZXJzIiwiUmVxdWVzdCIsIlJlc3BvbnNlIiwiQWJvcnRDb250cm9sbGVyIiwiQWJvcnRFcnJvciIsIkZldGNoRXJyb3IiLCJpc1JlZGlyZWN0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(rsc)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst http = __webpack_require__(/*! node:http */ \"node:http\");\nconst https = __webpack_require__(/*! node:https */ \"node:https\");\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\");\nconst Stream = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst node_buffer = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst node_util = __webpack_require__(/*! node:util */ \"node:util\");\nconst node_url = __webpack_require__(/*! node:url */ \"node:url\");\nconst node_net = __webpack_require__(/*! node:net */ \"node:net\");\n__webpack_require__(/*! node:fs */ \"node:fs\");\n__webpack_require__(/*! node:path */ \"node:path\");\n/**\n * Returns a `Buffer` instance from the given data URI `uri`.\n *\n * @param {String} uri Data URI to turn into a Buffer instance\n * @returns {Buffer} Buffer instance from Data URI\n * @api public\n */ function dataUriToBuffer(uri) {\n    if (!/^data:/i.test(uri)) {\n        throw new TypeError('`uri` does not appear to be a Data URI (must begin with \"data:\")');\n    }\n    // strip newlines\n    uri = uri.replace(/\\r?\\n/g, \"\");\n    // split the URI up into the \"metadata\" and the \"data\" portions\n    const firstComma = uri.indexOf(\",\");\n    if (firstComma === -1 || firstComma <= 4) {\n        throw new TypeError(\"malformed data: URI\");\n    }\n    // remove the \"data:\" scheme and parse the metadata\n    const meta = uri.substring(5, firstComma).split(\";\");\n    let charset = \"\";\n    let base64 = false;\n    const type = meta[0] || \"text/plain\";\n    let typeFull = type;\n    for(let i = 1; i < meta.length; i++){\n        if (meta[i] === \"base64\") {\n            base64 = true;\n        } else {\n            typeFull += `;${meta[i]}`;\n            if (meta[i].indexOf(\"charset=\") === 0) {\n                charset = meta[i].substring(8);\n            }\n        }\n    }\n    // defaults to US-ASCII only if type is not provided\n    if (!meta[0] && !charset.length) {\n        typeFull += \";charset=US-ASCII\";\n        charset = \"US-ASCII\";\n    }\n    // get the encoded data portion and decode URI-encoded chars\n    const encoding = base64 ? \"base64\" : \"ascii\";\n    const data = unescape(uri.substring(firstComma + 1));\n    const buffer = Buffer.from(data, encoding);\n    // set `.type` and `.typeFull` properties to MIME type\n    buffer.type = type;\n    buffer.typeFull = typeFull;\n    // set the `.charset` property\n    buffer.charset = charset;\n    return buffer;\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar ponyfill_es2018 = {\n    exports: {}\n};\n/**\n * web-streams-polyfill v3.2.1\n */ var hasRequiredPonyfill_es2018;\nfunction requirePonyfill_es2018() {\n    if (hasRequiredPonyfill_es2018) return ponyfill_es2018.exports;\n    hasRequiredPonyfill_es2018 = 1;\n    (function(module, exports1) {\n        (function(global1, factory) {\n            factory(exports1);\n        })(commonjsGlobal, function(exports1) {\n            /// <reference lib=\"es2015.symbol\" />\n            const SymbolPolyfill = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? Symbol : (description)=>`Symbol(${description})`;\n            /// <reference lib=\"dom\" />\n            function noop() {\n                return undefined;\n            }\n            function getGlobals() {\n                if (typeof self !== \"undefined\") {\n                    return self;\n                } else if (false) {} else if (typeof commonjsGlobal !== \"undefined\") {\n                    return commonjsGlobal;\n                }\n                return undefined;\n            }\n            const globals = getGlobals();\n            function typeIsObject(x) {\n                return typeof x === \"object\" && x !== null || typeof x === \"function\";\n            }\n            const rethrowAssertionErrorRejection = noop;\n            const originalPromise = Promise;\n            const originalPromiseThen = Promise.prototype.then;\n            const originalPromiseResolve = Promise.resolve.bind(originalPromise);\n            const originalPromiseReject = Promise.reject.bind(originalPromise);\n            function newPromise(executor) {\n                return new originalPromise(executor);\n            }\n            function promiseResolvedWith(value1) {\n                return originalPromiseResolve(value1);\n            }\n            function promiseRejectedWith(reason) {\n                return originalPromiseReject(reason);\n            }\n            function PerformPromiseThen(promise, onFulfilled, onRejected) {\n                // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n                // approximation.\n                return originalPromiseThen.call(promise, onFulfilled, onRejected);\n            }\n            function uponPromise(promise, onFulfilled, onRejected) {\n                PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n            }\n            function uponFulfillment(promise, onFulfilled) {\n                uponPromise(promise, onFulfilled);\n            }\n            function uponRejection(promise, onRejected) {\n                uponPromise(promise, undefined, onRejected);\n            }\n            function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n                return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n            }\n            function setPromiseIsHandledToTrue(promise) {\n                PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n            }\n            const queueMicrotask = (()=>{\n                const globalQueueMicrotask = globals && globals.queueMicrotask;\n                if (typeof globalQueueMicrotask === \"function\") {\n                    return globalQueueMicrotask;\n                }\n                const resolvedPromise = promiseResolvedWith(undefined);\n                return (fn)=>PerformPromiseThen(resolvedPromise, fn);\n            })();\n            function reflectCall(F, V, args) {\n                if (typeof F !== \"function\") {\n                    throw new TypeError(\"Argument is not a function\");\n                }\n                return Function.prototype.apply.call(F, V, args);\n            }\n            function promiseCall(F, V, args) {\n                try {\n                    return promiseResolvedWith(reflectCall(F, V, args));\n                } catch (value1) {\n                    return promiseRejectedWith(value1);\n                }\n            }\n            // Original from Chromium\n            // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n            const QUEUE_MAX_ARRAY_SIZE = 16384;\n            /**\n\t\t     * Simple queue structure.\n\t\t     *\n\t\t     * Avoids scalability issues with using a packed array directly by using\n\t\t     * multiple arrays in a linked list and keeping the array size bounded.\n\t\t     */ class SimpleQueue {\n                constructor(){\n                    this._cursor = 0;\n                    this._size = 0;\n                    // _front and _back are always defined.\n                    this._front = {\n                        _elements: [],\n                        _next: undefined\n                    };\n                    this._back = this._front;\n                    // The cursor is used to avoid calling Array.shift().\n                    // It contains the index of the front element of the array inside the\n                    // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n                    this._cursor = 0;\n                    // When there is only one node, size === elements.length - cursor.\n                    this._size = 0;\n                }\n                get length() {\n                    return this._size;\n                }\n                // For exception safety, this method is structured in order:\n                // 1. Read state\n                // 2. Calculate required state mutations\n                // 3. Perform state mutations\n                push(element) {\n                    const oldBack = this._back;\n                    let newBack = oldBack;\n                    if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n                        newBack = {\n                            _elements: [],\n                            _next: undefined\n                        };\n                    }\n                    // push() is the mutation most likely to throw an exception, so it\n                    // goes first.\n                    oldBack._elements.push(element);\n                    if (newBack !== oldBack) {\n                        this._back = newBack;\n                        oldBack._next = newBack;\n                    }\n                    ++this._size;\n                }\n                // Like push(), shift() follows the read -> calculate -> mutate pattern for\n                // exception safety.\n                shift() {\n                    const oldFront = this._front;\n                    let newFront = oldFront;\n                    const oldCursor = this._cursor;\n                    let newCursor = oldCursor + 1;\n                    const elements = oldFront._elements;\n                    const element = elements[oldCursor];\n                    if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n                        newFront = oldFront._next;\n                        newCursor = 0;\n                    }\n                    // No mutations before this point.\n                    --this._size;\n                    this._cursor = newCursor;\n                    if (oldFront !== newFront) {\n                        this._front = newFront;\n                    }\n                    // Permit shifted element to be garbage collected.\n                    elements[oldCursor] = undefined;\n                    return element;\n                }\n                // The tricky thing about forEach() is that it can be called\n                // re-entrantly. The queue may be mutated inside the callback. It is easy to\n                // see that push() within the callback has no negative effects since the end\n                // of the queue is checked for on every iteration. If shift() is called\n                // repeatedly within the callback then the next iteration may return an\n                // element that has been removed. In this case the callback will be called\n                // with undefined values until we either \"catch up\" with elements that still\n                // exist or reach the back of the queue.\n                forEach(callback) {\n                    let i = this._cursor;\n                    let node = this._front;\n                    let elements = node._elements;\n                    while(i !== elements.length || node._next !== undefined){\n                        if (i === elements.length) {\n                            node = node._next;\n                            elements = node._elements;\n                            i = 0;\n                            if (elements.length === 0) {\n                                break;\n                            }\n                        }\n                        callback(elements[i]);\n                        ++i;\n                    }\n                }\n                // Return the element that would be returned if shift() was called now,\n                // without modifying the queue.\n                peek() {\n                    const front = this._front;\n                    const cursor = this._cursor;\n                    return front._elements[cursor];\n                }\n            }\n            function ReadableStreamReaderGenericInitialize(reader, stream) {\n                reader._ownerReadableStream = stream;\n                stream._reader = reader;\n                if (stream._state === \"readable\") {\n                    defaultReaderClosedPromiseInitialize(reader);\n                } else if (stream._state === \"closed\") {\n                    defaultReaderClosedPromiseInitializeAsResolved(reader);\n                } else {\n                    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n                }\n            }\n            // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n            // check.\n            function ReadableStreamReaderGenericCancel(reader, reason) {\n                const stream = reader._ownerReadableStream;\n                return ReadableStreamCancel(stream, reason);\n            }\n            function ReadableStreamReaderGenericRelease(reader) {\n                if (reader._ownerReadableStream._state === \"readable\") {\n                    defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n                } else {\n                    defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n                }\n                reader._ownerReadableStream._reader = undefined;\n                reader._ownerReadableStream = undefined;\n            }\n            // Helper functions for the readers.\n            function readerLockException(name) {\n                return new TypeError(\"Cannot \" + name + \" a stream using a released reader\");\n            }\n            // Helper functions for the ReadableStreamDefaultReader.\n            function defaultReaderClosedPromiseInitialize(reader) {\n                reader._closedPromise = newPromise((resolve, reject)=>{\n                    reader._closedPromise_resolve = resolve;\n                    reader._closedPromise_reject = reject;\n                });\n            }\n            function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n                defaultReaderClosedPromiseInitialize(reader);\n                defaultReaderClosedPromiseReject(reader, reason);\n            }\n            function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n                defaultReaderClosedPromiseInitialize(reader);\n                defaultReaderClosedPromiseResolve(reader);\n            }\n            function defaultReaderClosedPromiseReject(reader, reason) {\n                if (reader._closedPromise_reject === undefined) {\n                    return;\n                }\n                setPromiseIsHandledToTrue(reader._closedPromise);\n                reader._closedPromise_reject(reason);\n                reader._closedPromise_resolve = undefined;\n                reader._closedPromise_reject = undefined;\n            }\n            function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n                defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n            }\n            function defaultReaderClosedPromiseResolve(reader) {\n                if (reader._closedPromise_resolve === undefined) {\n                    return;\n                }\n                reader._closedPromise_resolve(undefined);\n                reader._closedPromise_resolve = undefined;\n                reader._closedPromise_reject = undefined;\n            }\n            const AbortSteps = SymbolPolyfill(\"[[AbortSteps]]\");\n            const ErrorSteps = SymbolPolyfill(\"[[ErrorSteps]]\");\n            const CancelSteps = SymbolPolyfill(\"[[CancelSteps]]\");\n            const PullSteps = SymbolPolyfill(\"[[PullSteps]]\");\n            /// <reference lib=\"es2015.core\" />\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\n            const NumberIsFinite = Number.isFinite || function(x) {\n                return typeof x === \"number\" && isFinite(x);\n            };\n            /// <reference lib=\"es2015.core\" />\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\n            const MathTrunc = Math.trunc || function(v) {\n                return v < 0 ? Math.ceil(v) : Math.floor(v);\n            };\n            // https://heycam.github.io/webidl/#idl-dictionaries\n            function isDictionary(x) {\n                return typeof x === \"object\" || typeof x === \"function\";\n            }\n            function assertDictionary(obj, context) {\n                if (obj !== undefined && !isDictionary(obj)) {\n                    throw new TypeError(`${context} is not an object.`);\n                }\n            }\n            // https://heycam.github.io/webidl/#idl-callback-functions\n            function assertFunction(x, context) {\n                if (typeof x !== \"function\") {\n                    throw new TypeError(`${context} is not a function.`);\n                }\n            }\n            // https://heycam.github.io/webidl/#idl-object\n            function isObject(x) {\n                return typeof x === \"object\" && x !== null || typeof x === \"function\";\n            }\n            function assertObject(x, context) {\n                if (!isObject(x)) {\n                    throw new TypeError(`${context} is not an object.`);\n                }\n            }\n            function assertRequiredArgument(x, position, context) {\n                if (x === undefined) {\n                    throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n                }\n            }\n            function assertRequiredField(x, field, context) {\n                if (x === undefined) {\n                    throw new TypeError(`${field} is required in '${context}'.`);\n                }\n            }\n            // https://heycam.github.io/webidl/#idl-unrestricted-double\n            function convertUnrestrictedDouble(value1) {\n                return Number(value1);\n            }\n            function censorNegativeZero(x) {\n                return x === 0 ? 0 : x;\n            }\n            function integerPart(x) {\n                return censorNegativeZero(MathTrunc(x));\n            }\n            // https://heycam.github.io/webidl/#idl-unsigned-long-long\n            function convertUnsignedLongLongWithEnforceRange(value1, context) {\n                const lowerBound = 0;\n                const upperBound = Number.MAX_SAFE_INTEGER;\n                let x = Number(value1);\n                x = censorNegativeZero(x);\n                if (!NumberIsFinite(x)) {\n                    throw new TypeError(`${context} is not a finite number`);\n                }\n                x = integerPart(x);\n                if (x < lowerBound || x > upperBound) {\n                    throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n                }\n                if (!NumberIsFinite(x) || x === 0) {\n                    return 0;\n                }\n                // TODO Use BigInt if supported?\n                // let xBigInt = BigInt(integerPart(x));\n                // xBigInt = BigInt.asUintN(64, xBigInt);\n                // return Number(xBigInt);\n                return x;\n            }\n            function assertReadableStream(x, context) {\n                if (!IsReadableStream(x)) {\n                    throw new TypeError(`${context} is not a ReadableStream.`);\n                }\n            }\n            // Abstract operations for the ReadableStream.\n            function AcquireReadableStreamDefaultReader(stream) {\n                return new ReadableStreamDefaultReader(stream);\n            }\n            // ReadableStream API exposed for controllers.\n            function ReadableStreamAddReadRequest(stream, readRequest) {\n                stream._reader._readRequests.push(readRequest);\n            }\n            function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n                const reader = stream._reader;\n                const readRequest = reader._readRequests.shift();\n                if (done) {\n                    readRequest._closeSteps();\n                } else {\n                    readRequest._chunkSteps(chunk);\n                }\n            }\n            function ReadableStreamGetNumReadRequests(stream) {\n                return stream._reader._readRequests.length;\n            }\n            function ReadableStreamHasDefaultReader(stream) {\n                const reader = stream._reader;\n                if (reader === undefined) {\n                    return false;\n                }\n                if (!IsReadableStreamDefaultReader(reader)) {\n                    return false;\n                }\n                return true;\n            }\n            /**\n\t\t     * A default reader vended by a {@link ReadableStream}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStreamDefaultReader {\n                constructor(stream){\n                    assertRequiredArgument(stream, 1, \"ReadableStreamDefaultReader\");\n                    assertReadableStream(stream, \"First parameter\");\n                    if (IsReadableStreamLocked(stream)) {\n                        throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n                    }\n                    ReadableStreamReaderGenericInitialize(this, stream);\n                    this._readRequests = new SimpleQueue();\n                }\n                /**\n\t\t         * Returns a promise that will be fulfilled when the stream becomes closed,\n\t\t         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n\t\t         */ get closed() {\n                    if (!IsReadableStreamDefaultReader(this)) {\n                        return promiseRejectedWith(defaultReaderBrandCheckException(\"closed\"));\n                    }\n                    return this._closedPromise;\n                }\n                /**\n\t\t         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n\t\t         */ cancel(reason = undefined) {\n                    if (!IsReadableStreamDefaultReader(this)) {\n                        return promiseRejectedWith(defaultReaderBrandCheckException(\"cancel\"));\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"cancel\"));\n                    }\n                    return ReadableStreamReaderGenericCancel(this, reason);\n                }\n                /**\n\t\t         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n\t\t         *\n\t\t         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n\t\t         */ read() {\n                    if (!IsReadableStreamDefaultReader(this)) {\n                        return promiseRejectedWith(defaultReaderBrandCheckException(\"read\"));\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"read from\"));\n                    }\n                    let resolvePromise;\n                    let rejectPromise;\n                    const promise = newPromise((resolve, reject)=>{\n                        resolvePromise = resolve;\n                        rejectPromise = reject;\n                    });\n                    const readRequest = {\n                        _chunkSteps: (chunk)=>resolvePromise({\n                                value: chunk,\n                                done: false\n                            }),\n                        _closeSteps: ()=>resolvePromise({\n                                value: undefined,\n                                done: true\n                            }),\n                        _errorSteps: (e)=>rejectPromise(e)\n                    };\n                    ReadableStreamDefaultReaderRead(this, readRequest);\n                    return promise;\n                }\n                /**\n\t\t         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n\t\t         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n\t\t         * from now on; otherwise, the reader will appear closed.\n\t\t         *\n\t\t         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n\t\t         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n\t\t         * do so will throw a `TypeError` and leave the reader locked to the stream.\n\t\t         */ releaseLock() {\n                    if (!IsReadableStreamDefaultReader(this)) {\n                        throw defaultReaderBrandCheckException(\"releaseLock\");\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return;\n                    }\n                    if (this._readRequests.length > 0) {\n                        throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n                    }\n                    ReadableStreamReaderGenericRelease(this);\n                }\n            }\n            Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n                cancel: {\n                    enumerable: true\n                },\n                read: {\n                    enumerable: true\n                },\n                releaseLock: {\n                    enumerable: true\n                },\n                closed: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStreamDefaultReader\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the readers.\n            function IsReadableStreamDefaultReader(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_readRequests\")) {\n                    return false;\n                }\n                return x instanceof ReadableStreamDefaultReader;\n            }\n            function ReadableStreamDefaultReaderRead(reader, readRequest) {\n                const stream = reader._ownerReadableStream;\n                stream._disturbed = true;\n                if (stream._state === \"closed\") {\n                    readRequest._closeSteps();\n                } else if (stream._state === \"errored\") {\n                    readRequest._errorSteps(stream._storedError);\n                } else {\n                    stream._readableStreamController[PullSteps](readRequest);\n                }\n            }\n            // Helper functions for the ReadableStreamDefaultReader.\n            function defaultReaderBrandCheckException(name) {\n                return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n            }\n            /// <reference lib=\"es2018.asynciterable\" />\n            /* eslint-disable @typescript-eslint/no-empty-function */ const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);\n            /// <reference lib=\"es2018.asynciterable\" />\n            class ReadableStreamAsyncIteratorImpl {\n                constructor(reader, preventCancel){\n                    this._ongoingPromise = undefined;\n                    this._isFinished = false;\n                    this._reader = reader;\n                    this._preventCancel = preventCancel;\n                }\n                next() {\n                    const nextSteps = ()=>this._nextSteps();\n                    this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();\n                    return this._ongoingPromise;\n                }\n                return(value1) {\n                    const returnSteps = ()=>this._returnSteps(value1);\n                    return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();\n                }\n                _nextSteps() {\n                    if (this._isFinished) {\n                        return Promise.resolve({\n                            value: undefined,\n                            done: true\n                        });\n                    }\n                    const reader = this._reader;\n                    if (reader._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"iterate\"));\n                    }\n                    let resolvePromise;\n                    let rejectPromise;\n                    const promise = newPromise((resolve, reject)=>{\n                        resolvePromise = resolve;\n                        rejectPromise = reject;\n                    });\n                    const readRequest = {\n                        _chunkSteps: (chunk)=>{\n                            this._ongoingPromise = undefined;\n                            // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                            // FIXME Is this a bug in the specification, or in the test?\n                            queueMicrotask(()=>resolvePromise({\n                                    value: chunk,\n                                    done: false\n                                }));\n                        },\n                        _closeSteps: ()=>{\n                            this._ongoingPromise = undefined;\n                            this._isFinished = true;\n                            ReadableStreamReaderGenericRelease(reader);\n                            resolvePromise({\n                                value: undefined,\n                                done: true\n                            });\n                        },\n                        _errorSteps: (reason)=>{\n                            this._ongoingPromise = undefined;\n                            this._isFinished = true;\n                            ReadableStreamReaderGenericRelease(reader);\n                            rejectPromise(reason);\n                        }\n                    };\n                    ReadableStreamDefaultReaderRead(reader, readRequest);\n                    return promise;\n                }\n                _returnSteps(value1) {\n                    if (this._isFinished) {\n                        return Promise.resolve({\n                            value: value1,\n                            done: true\n                        });\n                    }\n                    this._isFinished = true;\n                    const reader = this._reader;\n                    if (reader._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"finish iterating\"));\n                    }\n                    if (!this._preventCancel) {\n                        const result = ReadableStreamReaderGenericCancel(reader, value1);\n                        ReadableStreamReaderGenericRelease(reader);\n                        return transformPromiseWith(result, ()=>({\n                                value: value1,\n                                done: true\n                            }));\n                    }\n                    ReadableStreamReaderGenericRelease(reader);\n                    return promiseResolvedWith({\n                        value: value1,\n                        done: true\n                    });\n                }\n            }\n            const ReadableStreamAsyncIteratorPrototype = {\n                next () {\n                    if (!IsReadableStreamAsyncIterator(this)) {\n                        return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"next\"));\n                    }\n                    return this._asyncIteratorImpl.next();\n                },\n                return (value1) {\n                    if (!IsReadableStreamAsyncIterator(this)) {\n                        return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"return\"));\n                    }\n                    return this._asyncIteratorImpl.return(value1);\n                }\n            };\n            if (AsyncIteratorPrototype !== undefined) {\n                Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n            }\n            // Abstract operations for the ReadableStream.\n            function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n                const reader = AcquireReadableStreamDefaultReader(stream);\n                const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n                const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n                iterator._asyncIteratorImpl = impl;\n                return iterator;\n            }\n            function IsReadableStreamAsyncIterator(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_asyncIteratorImpl\")) {\n                    return false;\n                }\n                try {\n                    // noinspection SuspiciousTypeOfGuard\n                    return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;\n                } catch (_a) {\n                    return false;\n                }\n            }\n            // Helper functions for the ReadableStream.\n            function streamAsyncIteratorBrandCheckException(name) {\n                return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n            }\n            /// <reference lib=\"es2015.core\" />\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\n            const NumberIsNaN = Number.isNaN || function(x) {\n                // eslint-disable-next-line no-self-compare\n                return x !== x;\n            };\n            function CreateArrayFromList(elements) {\n                // We use arrays to represent lists, so this is basically a no-op.\n                // Do a slice though just in case we happen to depend on the unique-ness.\n                return elements.slice();\n            }\n            function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n                new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n            }\n            // Not implemented correctly\n            function TransferArrayBuffer(O) {\n                return O;\n            }\n            // Not implemented correctly\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            function IsDetachedBuffer(O) {\n                return false;\n            }\n            function ArrayBufferSlice(buffer, begin, end) {\n                // ArrayBuffer.prototype.slice is not available on IE10\n                // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n                if (buffer.slice) {\n                    return buffer.slice(begin, end);\n                }\n                const length = end - begin;\n                const slice = new ArrayBuffer(length);\n                CopyDataBlockBytes(slice, 0, buffer, begin, length);\n                return slice;\n            }\n            function IsNonNegativeNumber(v) {\n                if (typeof v !== \"number\") {\n                    return false;\n                }\n                if (NumberIsNaN(v)) {\n                    return false;\n                }\n                if (v < 0) {\n                    return false;\n                }\n                return true;\n            }\n            function CloneAsUint8Array(O) {\n                const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n                return new Uint8Array(buffer);\n            }\n            function DequeueValue(container) {\n                const pair = container._queue.shift();\n                container._queueTotalSize -= pair.size;\n                if (container._queueTotalSize < 0) {\n                    container._queueTotalSize = 0;\n                }\n                return pair.value;\n            }\n            function EnqueueValueWithSize(container, value1, size) {\n                if (!IsNonNegativeNumber(size) || size === Infinity) {\n                    throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n                }\n                container._queue.push({\n                    value: value1,\n                    size\n                });\n                container._queueTotalSize += size;\n            }\n            function PeekQueueValue(container) {\n                const pair = container._queue.peek();\n                return pair.value;\n            }\n            function ResetQueue(container) {\n                container._queue = new SimpleQueue();\n                container._queueTotalSize = 0;\n            }\n            /**\n\t\t     * A pull-into request in a {@link ReadableByteStreamController}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStreamBYOBRequest {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n\t\t         */ get view() {\n                    if (!IsReadableStreamBYOBRequest(this)) {\n                        throw byobRequestBrandCheckException(\"view\");\n                    }\n                    return this._view;\n                }\n                respond(bytesWritten) {\n                    if (!IsReadableStreamBYOBRequest(this)) {\n                        throw byobRequestBrandCheckException(\"respond\");\n                    }\n                    assertRequiredArgument(bytesWritten, 1, \"respond\");\n                    bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, \"First parameter\");\n                    if (this._associatedReadableByteStreamController === undefined) {\n                        throw new TypeError(\"This BYOB request has been invalidated\");\n                    }\n                    if (IsDetachedBuffer(this._view.buffer)) ;\n                    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n                }\n                respondWithNewView(view) {\n                    if (!IsReadableStreamBYOBRequest(this)) {\n                        throw byobRequestBrandCheckException(\"respondWithNewView\");\n                    }\n                    assertRequiredArgument(view, 1, \"respondWithNewView\");\n                    if (!ArrayBuffer.isView(view)) {\n                        throw new TypeError(\"You can only respond with array buffer views\");\n                    }\n                    if (this._associatedReadableByteStreamController === undefined) {\n                        throw new TypeError(\"This BYOB request has been invalidated\");\n                    }\n                    if (IsDetachedBuffer(view.buffer)) ;\n                    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n                }\n            }\n            Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n                respond: {\n                    enumerable: true\n                },\n                respondWithNewView: {\n                    enumerable: true\n                },\n                view: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStreamBYOBRequest\",\n                    configurable: true\n                });\n            }\n            /**\n\t\t     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableByteStreamController {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * Returns the current BYOB pull request, or `null` if there isn't one.\n\t\t         */ get byobRequest() {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"byobRequest\");\n                    }\n                    return ReadableByteStreamControllerGetBYOBRequest(this);\n                }\n                /**\n\t\t         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n\t\t         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n\t\t         */ get desiredSize() {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"desiredSize\");\n                    }\n                    return ReadableByteStreamControllerGetDesiredSize(this);\n                }\n                /**\n\t\t         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n\t\t         * the stream, but once those are read, the stream will become closed.\n\t\t         */ close() {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"close\");\n                    }\n                    if (this._closeRequested) {\n                        throw new TypeError(\"The stream has already been closed; do not close it again!\");\n                    }\n                    const state = this._controlledReadableByteStream._state;\n                    if (state !== \"readable\") {\n                        throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n                    }\n                    ReadableByteStreamControllerClose(this);\n                }\n                enqueue(chunk) {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"enqueue\");\n                    }\n                    assertRequiredArgument(chunk, 1, \"enqueue\");\n                    if (!ArrayBuffer.isView(chunk)) {\n                        throw new TypeError(\"chunk must be an array buffer view\");\n                    }\n                    if (chunk.byteLength === 0) {\n                        throw new TypeError(\"chunk must have non-zero byteLength\");\n                    }\n                    if (chunk.buffer.byteLength === 0) {\n                        throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n                    }\n                    if (this._closeRequested) {\n                        throw new TypeError(\"stream is closed or draining\");\n                    }\n                    const state = this._controlledReadableByteStream._state;\n                    if (state !== \"readable\") {\n                        throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n                    }\n                    ReadableByteStreamControllerEnqueue(this, chunk);\n                }\n                /**\n\t\t         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n\t\t         */ error(e = undefined) {\n                    if (!IsReadableByteStreamController(this)) {\n                        throw byteStreamControllerBrandCheckException(\"error\");\n                    }\n                    ReadableByteStreamControllerError(this, e);\n                }\n                /** @internal */ [CancelSteps](reason) {\n                    ReadableByteStreamControllerClearPendingPullIntos(this);\n                    ResetQueue(this);\n                    const result = this._cancelAlgorithm(reason);\n                    ReadableByteStreamControllerClearAlgorithms(this);\n                    return result;\n                }\n                /** @internal */ [PullSteps](readRequest) {\n                    const stream = this._controlledReadableByteStream;\n                    if (this._queueTotalSize > 0) {\n                        const entry = this._queue.shift();\n                        this._queueTotalSize -= entry.byteLength;\n                        ReadableByteStreamControllerHandleQueueDrain(this);\n                        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n                        readRequest._chunkSteps(view);\n                        return;\n                    }\n                    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n                    if (autoAllocateChunkSize !== undefined) {\n                        let buffer;\n                        try {\n                            buffer = new ArrayBuffer(autoAllocateChunkSize);\n                        } catch (bufferE) {\n                            readRequest._errorSteps(bufferE);\n                            return;\n                        }\n                        const pullIntoDescriptor = {\n                            buffer,\n                            bufferByteLength: autoAllocateChunkSize,\n                            byteOffset: 0,\n                            byteLength: autoAllocateChunkSize,\n                            bytesFilled: 0,\n                            elementSize: 1,\n                            viewConstructor: Uint8Array,\n                            readerType: \"default\"\n                        };\n                        this._pendingPullIntos.push(pullIntoDescriptor);\n                    }\n                    ReadableStreamAddReadRequest(stream, readRequest);\n                    ReadableByteStreamControllerCallPullIfNeeded(this);\n                }\n            }\n            Object.defineProperties(ReadableByteStreamController.prototype, {\n                close: {\n                    enumerable: true\n                },\n                enqueue: {\n                    enumerable: true\n                },\n                error: {\n                    enumerable: true\n                },\n                byobRequest: {\n                    enumerable: true\n                },\n                desiredSize: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableByteStreamController\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the ReadableByteStreamController.\n            function IsReadableByteStreamController(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableByteStream\")) {\n                    return false;\n                }\n                return x instanceof ReadableByteStreamController;\n            }\n            function IsReadableStreamBYOBRequest(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_associatedReadableByteStreamController\")) {\n                    return false;\n                }\n                return x instanceof ReadableStreamBYOBRequest;\n            }\n            function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n                const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n                if (!shouldPull) {\n                    return;\n                }\n                if (controller._pulling) {\n                    controller._pullAgain = true;\n                    return;\n                }\n                controller._pulling = true;\n                // TODO: Test controller argument\n                const pullPromise = controller._pullAlgorithm();\n                uponPromise(pullPromise, ()=>{\n                    controller._pulling = false;\n                    if (controller._pullAgain) {\n                        controller._pullAgain = false;\n                        ReadableByteStreamControllerCallPullIfNeeded(controller);\n                    }\n                }, (e)=>{\n                    ReadableByteStreamControllerError(controller, e);\n                });\n            }\n            function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n                ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n                controller._pendingPullIntos = new SimpleQueue();\n            }\n            function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n                let done = false;\n                if (stream._state === \"closed\") {\n                    done = true;\n                }\n                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                if (pullIntoDescriptor.readerType === \"default\") {\n                    ReadableStreamFulfillReadRequest(stream, filledView, done);\n                } else {\n                    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n                }\n            }\n            function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n                const bytesFilled = pullIntoDescriptor.bytesFilled;\n                const elementSize = pullIntoDescriptor.elementSize;\n                return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n            }\n            function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n                controller._queue.push({\n                    buffer,\n                    byteOffset,\n                    byteLength\n                });\n                controller._queueTotalSize += byteLength;\n            }\n            function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n                const elementSize = pullIntoDescriptor.elementSize;\n                const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n                const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n                const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n                const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n                let totalBytesToCopyRemaining = maxBytesToCopy;\n                let ready = false;\n                if (maxAlignedBytes > currentAlignedBytes) {\n                    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n                    ready = true;\n                }\n                const queue = controller._queue;\n                while(totalBytesToCopyRemaining > 0){\n                    const headOfQueue = queue.peek();\n                    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n                    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n                    CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n                    if (headOfQueue.byteLength === bytesToCopy) {\n                        queue.shift();\n                    } else {\n                        headOfQueue.byteOffset += bytesToCopy;\n                        headOfQueue.byteLength -= bytesToCopy;\n                    }\n                    controller._queueTotalSize -= bytesToCopy;\n                    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n                    totalBytesToCopyRemaining -= bytesToCopy;\n                }\n                return ready;\n            }\n            function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n                pullIntoDescriptor.bytesFilled += size;\n            }\n            function ReadableByteStreamControllerHandleQueueDrain(controller) {\n                if (controller._queueTotalSize === 0 && controller._closeRequested) {\n                    ReadableByteStreamControllerClearAlgorithms(controller);\n                    ReadableStreamClose(controller._controlledReadableByteStream);\n                } else {\n                    ReadableByteStreamControllerCallPullIfNeeded(controller);\n                }\n            }\n            function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n                if (controller._byobRequest === null) {\n                    return;\n                }\n                controller._byobRequest._associatedReadableByteStreamController = undefined;\n                controller._byobRequest._view = null;\n                controller._byobRequest = null;\n            }\n            function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n                while(controller._pendingPullIntos.length > 0){\n                    if (controller._queueTotalSize === 0) {\n                        return;\n                    }\n                    const pullIntoDescriptor = controller._pendingPullIntos.peek();\n                    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                        ReadableByteStreamControllerShiftPendingPullInto(controller);\n                        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n                    }\n                }\n            }\n            function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n                const stream = controller._controlledReadableByteStream;\n                let elementSize = 1;\n                if (view.constructor !== DataView) {\n                    elementSize = view.constructor.BYTES_PER_ELEMENT;\n                }\n                const ctor = view.constructor;\n                // try {\n                const buffer = TransferArrayBuffer(view.buffer);\n                // } catch (e) {\n                //   readIntoRequest._errorSteps(e);\n                //   return;\n                // }\n                const pullIntoDescriptor = {\n                    buffer,\n                    bufferByteLength: buffer.byteLength,\n                    byteOffset: view.byteOffset,\n                    byteLength: view.byteLength,\n                    bytesFilled: 0,\n                    elementSize,\n                    viewConstructor: ctor,\n                    readerType: \"byob\"\n                };\n                if (controller._pendingPullIntos.length > 0) {\n                    controller._pendingPullIntos.push(pullIntoDescriptor);\n                    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n                    // - No change happens on desiredSize\n                    // - The source has already been notified of that there's at least 1 pending read(view)\n                    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n                    return;\n                }\n                if (stream._state === \"closed\") {\n                    const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n                    readIntoRequest._closeSteps(emptyView);\n                    return;\n                }\n                if (controller._queueTotalSize > 0) {\n                    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                        ReadableByteStreamControllerHandleQueueDrain(controller);\n                        readIntoRequest._chunkSteps(filledView);\n                        return;\n                    }\n                    if (controller._closeRequested) {\n                        const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                        ReadableByteStreamControllerError(controller, e);\n                        readIntoRequest._errorSteps(e);\n                        return;\n                    }\n                }\n                controller._pendingPullIntos.push(pullIntoDescriptor);\n                ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n            function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n                const stream = controller._controlledReadableByteStream;\n                if (ReadableStreamHasBYOBReader(stream)) {\n                    while(ReadableStreamGetNumReadIntoRequests(stream) > 0){\n                        const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n                        ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n                    }\n                }\n            }\n            function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n                ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n                if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n                    return;\n                }\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\n                const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n                if (remainderSize > 0) {\n                    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n                    const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n                    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n                }\n                pullIntoDescriptor.bytesFilled -= remainderSize;\n                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n                ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n            }\n            function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n                const firstDescriptor = controller._pendingPullIntos.peek();\n                ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n                const state = controller._controlledReadableByteStream._state;\n                if (state === \"closed\") {\n                    ReadableByteStreamControllerRespondInClosedState(controller);\n                } else {\n                    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n                }\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n            function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n                const descriptor = controller._pendingPullIntos.shift();\n                return descriptor;\n            }\n            function ReadableByteStreamControllerShouldCallPull(controller) {\n                const stream = controller._controlledReadableByteStream;\n                if (stream._state !== \"readable\") {\n                    return false;\n                }\n                if (controller._closeRequested) {\n                    return false;\n                }\n                if (!controller._started) {\n                    return false;\n                }\n                if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n                    return true;\n                }\n                if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n                    return true;\n                }\n                const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n                if (desiredSize > 0) {\n                    return true;\n                }\n                return false;\n            }\n            function ReadableByteStreamControllerClearAlgorithms(controller) {\n                controller._pullAlgorithm = undefined;\n                controller._cancelAlgorithm = undefined;\n            }\n            // A client of ReadableByteStreamController may use these functions directly to bypass state check.\n            function ReadableByteStreamControllerClose(controller) {\n                const stream = controller._controlledReadableByteStream;\n                if (controller._closeRequested || stream._state !== \"readable\") {\n                    return;\n                }\n                if (controller._queueTotalSize > 0) {\n                    controller._closeRequested = true;\n                    return;\n                }\n                if (controller._pendingPullIntos.length > 0) {\n                    const firstPendingPullInto = controller._pendingPullIntos.peek();\n                    if (firstPendingPullInto.bytesFilled > 0) {\n                        const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                        ReadableByteStreamControllerError(controller, e);\n                        throw e;\n                    }\n                }\n                ReadableByteStreamControllerClearAlgorithms(controller);\n                ReadableStreamClose(stream);\n            }\n            function ReadableByteStreamControllerEnqueue(controller, chunk) {\n                const stream = controller._controlledReadableByteStream;\n                if (controller._closeRequested || stream._state !== \"readable\") {\n                    return;\n                }\n                const buffer = chunk.buffer;\n                const byteOffset = chunk.byteOffset;\n                const byteLength = chunk.byteLength;\n                const transferredBuffer = TransferArrayBuffer(buffer);\n                if (controller._pendingPullIntos.length > 0) {\n                    const firstPendingPullInto = controller._pendingPullIntos.peek();\n                    if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;\n                    firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n                }\n                ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n                if (ReadableStreamHasDefaultReader(stream)) {\n                    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n                        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n                    } else {\n                        if (controller._pendingPullIntos.length > 0) {\n                            ReadableByteStreamControllerShiftPendingPullInto(controller);\n                        }\n                        const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n                        ReadableStreamFulfillReadRequest(stream, transferredView, false);\n                    }\n                } else if (ReadableStreamHasBYOBReader(stream)) {\n                    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n                    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n                    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n                } else {\n                    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n                }\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n            function ReadableByteStreamControllerError(controller, e) {\n                const stream = controller._controlledReadableByteStream;\n                if (stream._state !== \"readable\") {\n                    return;\n                }\n                ReadableByteStreamControllerClearPendingPullIntos(controller);\n                ResetQueue(controller);\n                ReadableByteStreamControllerClearAlgorithms(controller);\n                ReadableStreamError(stream, e);\n            }\n            function ReadableByteStreamControllerGetBYOBRequest(controller) {\n                if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n                    const firstDescriptor = controller._pendingPullIntos.peek();\n                    const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n                    const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n                    SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n                    controller._byobRequest = byobRequest;\n                }\n                return controller._byobRequest;\n            }\n            function ReadableByteStreamControllerGetDesiredSize(controller) {\n                const state = controller._controlledReadableByteStream._state;\n                if (state === \"errored\") {\n                    return null;\n                }\n                if (state === \"closed\") {\n                    return 0;\n                }\n                return controller._strategyHWM - controller._queueTotalSize;\n            }\n            function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n                const firstDescriptor = controller._pendingPullIntos.peek();\n                const state = controller._controlledReadableByteStream._state;\n                if (state === \"closed\") {\n                    if (bytesWritten !== 0) {\n                        throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n                    }\n                } else {\n                    if (bytesWritten === 0) {\n                        throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n                    }\n                    if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n                        throw new RangeError(\"bytesWritten out of range\");\n                    }\n                }\n                firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n                ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n            }\n            function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n                const firstDescriptor = controller._pendingPullIntos.peek();\n                const state = controller._controlledReadableByteStream._state;\n                if (state === \"closed\") {\n                    if (view.byteLength !== 0) {\n                        throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n                    }\n                } else {\n                    if (view.byteLength === 0) {\n                        throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n                    }\n                }\n                if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n                    throw new RangeError(\"The region specified by view does not match byobRequest\");\n                }\n                if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n                    throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n                }\n                if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n                    throw new RangeError(\"The region specified by view is larger than byobRequest\");\n                }\n                const viewByteLength = view.byteLength;\n                firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n                ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n            }\n            function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n                controller._controlledReadableByteStream = stream;\n                controller._pullAgain = false;\n                controller._pulling = false;\n                controller._byobRequest = null;\n                // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n                controller._queue = controller._queueTotalSize = undefined;\n                ResetQueue(controller);\n                controller._closeRequested = false;\n                controller._started = false;\n                controller._strategyHWM = highWaterMark;\n                controller._pullAlgorithm = pullAlgorithm;\n                controller._cancelAlgorithm = cancelAlgorithm;\n                controller._autoAllocateChunkSize = autoAllocateChunkSize;\n                controller._pendingPullIntos = new SimpleQueue();\n                stream._readableStreamController = controller;\n                const startResult = startAlgorithm();\n                uponPromise(promiseResolvedWith(startResult), ()=>{\n                    controller._started = true;\n                    ReadableByteStreamControllerCallPullIfNeeded(controller);\n                }, (r)=>{\n                    ReadableByteStreamControllerError(controller, r);\n                });\n            }\n            function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n                const controller = Object.create(ReadableByteStreamController.prototype);\n                let startAlgorithm = ()=>undefined;\n                let pullAlgorithm = ()=>promiseResolvedWith(undefined);\n                let cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n                if (underlyingByteSource.start !== undefined) {\n                    startAlgorithm = ()=>underlyingByteSource.start(controller);\n                }\n                if (underlyingByteSource.pull !== undefined) {\n                    pullAlgorithm = ()=>underlyingByteSource.pull(controller);\n                }\n                if (underlyingByteSource.cancel !== undefined) {\n                    cancelAlgorithm = (reason)=>underlyingByteSource.cancel(reason);\n                }\n                const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n                if (autoAllocateChunkSize === 0) {\n                    throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n                }\n                SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n            }\n            function SetUpReadableStreamBYOBRequest(request, controller, view) {\n                request._associatedReadableByteStreamController = controller;\n                request._view = view;\n            }\n            // Helper functions for the ReadableStreamBYOBRequest.\n            function byobRequestBrandCheckException(name) {\n                return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n            }\n            // Helper functions for the ReadableByteStreamController.\n            function byteStreamControllerBrandCheckException(name) {\n                return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n            }\n            // Abstract operations for the ReadableStream.\n            function AcquireReadableStreamBYOBReader(stream) {\n                return new ReadableStreamBYOBReader(stream);\n            }\n            // ReadableStream API exposed for controllers.\n            function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n                stream._reader._readIntoRequests.push(readIntoRequest);\n            }\n            function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n                const reader = stream._reader;\n                const readIntoRequest = reader._readIntoRequests.shift();\n                if (done) {\n                    readIntoRequest._closeSteps(chunk);\n                } else {\n                    readIntoRequest._chunkSteps(chunk);\n                }\n            }\n            function ReadableStreamGetNumReadIntoRequests(stream) {\n                return stream._reader._readIntoRequests.length;\n            }\n            function ReadableStreamHasBYOBReader(stream) {\n                const reader = stream._reader;\n                if (reader === undefined) {\n                    return false;\n                }\n                if (!IsReadableStreamBYOBReader(reader)) {\n                    return false;\n                }\n                return true;\n            }\n            /**\n\t\t     * A BYOB reader vended by a {@link ReadableStream}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStreamBYOBReader {\n                constructor(stream){\n                    assertRequiredArgument(stream, 1, \"ReadableStreamBYOBReader\");\n                    assertReadableStream(stream, \"First parameter\");\n                    if (IsReadableStreamLocked(stream)) {\n                        throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n                    }\n                    if (!IsReadableByteStreamController(stream._readableStreamController)) {\n                        throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte \" + \"source\");\n                    }\n                    ReadableStreamReaderGenericInitialize(this, stream);\n                    this._readIntoRequests = new SimpleQueue();\n                }\n                /**\n\t\t         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n\t\t         * the reader's lock is released before the stream finishes closing.\n\t\t         */ get closed() {\n                    if (!IsReadableStreamBYOBReader(this)) {\n                        return promiseRejectedWith(byobReaderBrandCheckException(\"closed\"));\n                    }\n                    return this._closedPromise;\n                }\n                /**\n\t\t         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n\t\t         */ cancel(reason = undefined) {\n                    if (!IsReadableStreamBYOBReader(this)) {\n                        return promiseRejectedWith(byobReaderBrandCheckException(\"cancel\"));\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"cancel\"));\n                    }\n                    return ReadableStreamReaderGenericCancel(this, reason);\n                }\n                /**\n\t\t         * Attempts to reads bytes into view, and returns a promise resolved with the result.\n\t\t         *\n\t\t         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n\t\t         */ read(view) {\n                    if (!IsReadableStreamBYOBReader(this)) {\n                        return promiseRejectedWith(byobReaderBrandCheckException(\"read\"));\n                    }\n                    if (!ArrayBuffer.isView(view)) {\n                        return promiseRejectedWith(new TypeError(\"view must be an array buffer view\"));\n                    }\n                    if (view.byteLength === 0) {\n                        return promiseRejectedWith(new TypeError(\"view must have non-zero byteLength\"));\n                    }\n                    if (view.buffer.byteLength === 0) {\n                        return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n                    }\n                    if (IsDetachedBuffer(view.buffer)) ;\n                    if (this._ownerReadableStream === undefined) {\n                        return promiseRejectedWith(readerLockException(\"read from\"));\n                    }\n                    let resolvePromise;\n                    let rejectPromise;\n                    const promise = newPromise((resolve, reject)=>{\n                        resolvePromise = resolve;\n                        rejectPromise = reject;\n                    });\n                    const readIntoRequest = {\n                        _chunkSteps: (chunk)=>resolvePromise({\n                                value: chunk,\n                                done: false\n                            }),\n                        _closeSteps: (chunk)=>resolvePromise({\n                                value: chunk,\n                                done: true\n                            }),\n                        _errorSteps: (e)=>rejectPromise(e)\n                    };\n                    ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n                    return promise;\n                }\n                /**\n\t\t         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n\t\t         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n\t\t         * from now on; otherwise, the reader will appear closed.\n\t\t         *\n\t\t         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n\t\t         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n\t\t         * do so will throw a `TypeError` and leave the reader locked to the stream.\n\t\t         */ releaseLock() {\n                    if (!IsReadableStreamBYOBReader(this)) {\n                        throw byobReaderBrandCheckException(\"releaseLock\");\n                    }\n                    if (this._ownerReadableStream === undefined) {\n                        return;\n                    }\n                    if (this._readIntoRequests.length > 0) {\n                        throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n                    }\n                    ReadableStreamReaderGenericRelease(this);\n                }\n            }\n            Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n                cancel: {\n                    enumerable: true\n                },\n                read: {\n                    enumerable: true\n                },\n                releaseLock: {\n                    enumerable: true\n                },\n                closed: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStreamBYOBReader\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the readers.\n            function IsReadableStreamBYOBReader(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_readIntoRequests\")) {\n                    return false;\n                }\n                return x instanceof ReadableStreamBYOBReader;\n            }\n            function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n                const stream = reader._ownerReadableStream;\n                stream._disturbed = true;\n                if (stream._state === \"errored\") {\n                    readIntoRequest._errorSteps(stream._storedError);\n                } else {\n                    ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n                }\n            }\n            // Helper functions for the ReadableStreamBYOBReader.\n            function byobReaderBrandCheckException(name) {\n                return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n            }\n            function ExtractHighWaterMark(strategy, defaultHWM) {\n                const { highWaterMark } = strategy;\n                if (highWaterMark === undefined) {\n                    return defaultHWM;\n                }\n                if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n                    throw new RangeError(\"Invalid highWaterMark\");\n                }\n                return highWaterMark;\n            }\n            function ExtractSizeAlgorithm(strategy) {\n                const { size } = strategy;\n                if (!size) {\n                    return ()=>1;\n                }\n                return size;\n            }\n            function convertQueuingStrategy(init, context) {\n                assertDictionary(init, context);\n                const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n                const size = init === null || init === void 0 ? void 0 : init.size;\n                return {\n                    highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n                    size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n                };\n            }\n            function convertQueuingStrategySize(fn, context) {\n                assertFunction(fn, context);\n                return (chunk)=>convertUnrestrictedDouble(fn(chunk));\n            }\n            function convertUnderlyingSink(original, context) {\n                assertDictionary(original, context);\n                const abort = original === null || original === void 0 ? void 0 : original.abort;\n                const close = original === null || original === void 0 ? void 0 : original.close;\n                const start = original === null || original === void 0 ? void 0 : original.start;\n                const type = original === null || original === void 0 ? void 0 : original.type;\n                const write = original === null || original === void 0 ? void 0 : original.write;\n                return {\n                    abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n                    close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n                    start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n                    write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n                    type\n                };\n            }\n            function convertUnderlyingSinkAbortCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (reason)=>promiseCall(fn, original, [\n                        reason\n                    ]);\n            }\n            function convertUnderlyingSinkCloseCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return ()=>promiseCall(fn, original, []);\n            }\n            function convertUnderlyingSinkStartCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>reflectCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertUnderlyingSinkWriteCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (chunk, controller)=>promiseCall(fn, original, [\n                        chunk,\n                        controller\n                    ]);\n            }\n            function assertWritableStream(x, context) {\n                if (!IsWritableStream(x)) {\n                    throw new TypeError(`${context} is not a WritableStream.`);\n                }\n            }\n            function isAbortSignal(value1) {\n                if (typeof value1 !== \"object\" || value1 === null) {\n                    return false;\n                }\n                try {\n                    return typeof value1.aborted === \"boolean\";\n                } catch (_a) {\n                    // AbortSignal.prototype.aborted throws if its brand check fails\n                    return false;\n                }\n            }\n            const supportsAbortController = typeof AbortController === \"function\";\n            /**\n\t\t     * Construct a new AbortController, if supported by the platform.\n\t\t     *\n\t\t     * @internal\n\t\t     */ function createAbortController() {\n                if (supportsAbortController) {\n                    return new AbortController();\n                }\n                return undefined;\n            }\n            /**\n\t\t     * A writable stream represents a destination for data, into which you can write.\n\t\t     *\n\t\t     * @public\n\t\t     */ class WritableStream {\n                constructor(rawUnderlyingSink = {}, rawStrategy = {}){\n                    if (rawUnderlyingSink === undefined) {\n                        rawUnderlyingSink = null;\n                    } else {\n                        assertObject(rawUnderlyingSink, \"First parameter\");\n                    }\n                    const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n                    const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, \"First parameter\");\n                    InitializeWritableStream(this);\n                    const type = underlyingSink.type;\n                    if (type !== undefined) {\n                        throw new RangeError(\"Invalid type is specified\");\n                    }\n                    const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                    const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n                }\n                /**\n\t\t         * Returns whether or not the writable stream is locked to a writer.\n\t\t         */ get locked() {\n                    if (!IsWritableStream(this)) {\n                        throw streamBrandCheckException$2(\"locked\");\n                    }\n                    return IsWritableStreamLocked(this);\n                }\n                /**\n\t\t         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n\t\t         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n\t\t         * mechanism of the underlying sink.\n\t\t         *\n\t\t         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n\t\t         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n\t\t         * the stream) if the stream is currently locked.\n\t\t         */ abort(reason = undefined) {\n                    if (!IsWritableStream(this)) {\n                        return promiseRejectedWith(streamBrandCheckException$2(\"abort\"));\n                    }\n                    if (IsWritableStreamLocked(this)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot abort a stream that already has a writer\"));\n                    }\n                    return WritableStreamAbort(this, reason);\n                }\n                /**\n\t\t         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n\t\t         * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n\t\t         *\n\t\t         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n\t\t         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n\t\t         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n\t\t         */ close() {\n                    if (!IsWritableStream(this)) {\n                        return promiseRejectedWith(streamBrandCheckException$2(\"close\"));\n                    }\n                    if (IsWritableStreamLocked(this)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot close a stream that already has a writer\"));\n                    }\n                    if (WritableStreamCloseQueuedOrInFlight(this)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n                    }\n                    return WritableStreamClose(this);\n                }\n                /**\n\t\t         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n\t\t         * is locked, no other writer can be acquired until this one is released.\n\t\t         *\n\t\t         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n\t\t         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n\t\t         * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n\t\t         */ getWriter() {\n                    if (!IsWritableStream(this)) {\n                        throw streamBrandCheckException$2(\"getWriter\");\n                    }\n                    return AcquireWritableStreamDefaultWriter(this);\n                }\n            }\n            Object.defineProperties(WritableStream.prototype, {\n                abort: {\n                    enumerable: true\n                },\n                close: {\n                    enumerable: true\n                },\n                getWriter: {\n                    enumerable: true\n                },\n                locked: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"WritableStream\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the WritableStream.\n            function AcquireWritableStreamDefaultWriter(stream) {\n                return new WritableStreamDefaultWriter(stream);\n            }\n            // Throws if and only if startAlgorithm throws.\n            function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n                const stream = Object.create(WritableStream.prototype);\n                InitializeWritableStream(stream);\n                const controller = Object.create(WritableStreamDefaultController.prototype);\n                SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n                return stream;\n            }\n            function InitializeWritableStream(stream) {\n                stream._state = \"writable\";\n                // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n                // 'erroring' or 'errored'. May be set to an undefined value.\n                stream._storedError = undefined;\n                stream._writer = undefined;\n                // Initialize to undefined first because the constructor of the controller checks this\n                // variable to validate the caller.\n                stream._writableStreamController = undefined;\n                // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n                // producer without waiting for the queued writes to finish.\n                stream._writeRequests = new SimpleQueue();\n                // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n                // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n                stream._inFlightWriteRequest = undefined;\n                // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n                // has been detached.\n                stream._closeRequest = undefined;\n                // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n                // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n                stream._inFlightCloseRequest = undefined;\n                // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n                stream._pendingAbortRequest = undefined;\n                // The backpressure signal set by the controller.\n                stream._backpressure = false;\n            }\n            function IsWritableStream(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_writableStreamController\")) {\n                    return false;\n                }\n                return x instanceof WritableStream;\n            }\n            function IsWritableStreamLocked(stream) {\n                if (stream._writer === undefined) {\n                    return false;\n                }\n                return true;\n            }\n            function WritableStreamAbort(stream, reason) {\n                var _a;\n                if (stream._state === \"closed\" || stream._state === \"errored\") {\n                    return promiseResolvedWith(undefined);\n                }\n                stream._writableStreamController._abortReason = reason;\n                (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();\n                // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n                // but it doesn't know that signaling abort runs author code that might have changed the state.\n                // Widen the type again by casting to WritableStreamState.\n                const state = stream._state;\n                if (state === \"closed\" || state === \"errored\") {\n                    return promiseResolvedWith(undefined);\n                }\n                if (stream._pendingAbortRequest !== undefined) {\n                    return stream._pendingAbortRequest._promise;\n                }\n                let wasAlreadyErroring = false;\n                if (state === \"erroring\") {\n                    wasAlreadyErroring = true;\n                    // reason will not be used, so don't keep a reference to it.\n                    reason = undefined;\n                }\n                const promise = newPromise((resolve, reject)=>{\n                    stream._pendingAbortRequest = {\n                        _promise: undefined,\n                        _resolve: resolve,\n                        _reject: reject,\n                        _reason: reason,\n                        _wasAlreadyErroring: wasAlreadyErroring\n                    };\n                });\n                stream._pendingAbortRequest._promise = promise;\n                if (!wasAlreadyErroring) {\n                    WritableStreamStartErroring(stream, reason);\n                }\n                return promise;\n            }\n            function WritableStreamClose(stream) {\n                const state = stream._state;\n                if (state === \"closed\" || state === \"errored\") {\n                    return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n                }\n                const promise = newPromise((resolve, reject)=>{\n                    const closeRequest = {\n                        _resolve: resolve,\n                        _reject: reject\n                    };\n                    stream._closeRequest = closeRequest;\n                });\n                const writer = stream._writer;\n                if (writer !== undefined && stream._backpressure && state === \"writable\") {\n                    defaultWriterReadyPromiseResolve(writer);\n                }\n                WritableStreamDefaultControllerClose(stream._writableStreamController);\n                return promise;\n            }\n            // WritableStream API exposed for controllers.\n            function WritableStreamAddWriteRequest(stream) {\n                const promise = newPromise((resolve, reject)=>{\n                    const writeRequest = {\n                        _resolve: resolve,\n                        _reject: reject\n                    };\n                    stream._writeRequests.push(writeRequest);\n                });\n                return promise;\n            }\n            function WritableStreamDealWithRejection(stream, error) {\n                const state = stream._state;\n                if (state === \"writable\") {\n                    WritableStreamStartErroring(stream, error);\n                    return;\n                }\n                WritableStreamFinishErroring(stream);\n            }\n            function WritableStreamStartErroring(stream, reason) {\n                const controller = stream._writableStreamController;\n                stream._state = \"erroring\";\n                stream._storedError = reason;\n                const writer = stream._writer;\n                if (writer !== undefined) {\n                    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n                }\n                if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n                    WritableStreamFinishErroring(stream);\n                }\n            }\n            function WritableStreamFinishErroring(stream) {\n                stream._state = \"errored\";\n                stream._writableStreamController[ErrorSteps]();\n                const storedError = stream._storedError;\n                stream._writeRequests.forEach((writeRequest)=>{\n                    writeRequest._reject(storedError);\n                });\n                stream._writeRequests = new SimpleQueue();\n                if (stream._pendingAbortRequest === undefined) {\n                    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n                    return;\n                }\n                const abortRequest = stream._pendingAbortRequest;\n                stream._pendingAbortRequest = undefined;\n                if (abortRequest._wasAlreadyErroring) {\n                    abortRequest._reject(storedError);\n                    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n                    return;\n                }\n                const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n                uponPromise(promise, ()=>{\n                    abortRequest._resolve();\n                    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n                }, (reason)=>{\n                    abortRequest._reject(reason);\n                    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n                });\n            }\n            function WritableStreamFinishInFlightWrite(stream) {\n                stream._inFlightWriteRequest._resolve(undefined);\n                stream._inFlightWriteRequest = undefined;\n            }\n            function WritableStreamFinishInFlightWriteWithError(stream, error) {\n                stream._inFlightWriteRequest._reject(error);\n                stream._inFlightWriteRequest = undefined;\n                WritableStreamDealWithRejection(stream, error);\n            }\n            function WritableStreamFinishInFlightClose(stream) {\n                stream._inFlightCloseRequest._resolve(undefined);\n                stream._inFlightCloseRequest = undefined;\n                const state = stream._state;\n                if (state === \"erroring\") {\n                    // The error was too late to do anything, so it is ignored.\n                    stream._storedError = undefined;\n                    if (stream._pendingAbortRequest !== undefined) {\n                        stream._pendingAbortRequest._resolve();\n                        stream._pendingAbortRequest = undefined;\n                    }\n                }\n                stream._state = \"closed\";\n                const writer = stream._writer;\n                if (writer !== undefined) {\n                    defaultWriterClosedPromiseResolve(writer);\n                }\n            }\n            function WritableStreamFinishInFlightCloseWithError(stream, error) {\n                stream._inFlightCloseRequest._reject(error);\n                stream._inFlightCloseRequest = undefined;\n                // Never execute sink abort() after sink close().\n                if (stream._pendingAbortRequest !== undefined) {\n                    stream._pendingAbortRequest._reject(error);\n                    stream._pendingAbortRequest = undefined;\n                }\n                WritableStreamDealWithRejection(stream, error);\n            }\n            // TODO(ricea): Fix alphabetical order.\n            function WritableStreamCloseQueuedOrInFlight(stream) {\n                if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n                    return false;\n                }\n                return true;\n            }\n            function WritableStreamHasOperationMarkedInFlight(stream) {\n                if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n                    return false;\n                }\n                return true;\n            }\n            function WritableStreamMarkCloseRequestInFlight(stream) {\n                stream._inFlightCloseRequest = stream._closeRequest;\n                stream._closeRequest = undefined;\n            }\n            function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n                stream._inFlightWriteRequest = stream._writeRequests.shift();\n            }\n            function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n                if (stream._closeRequest !== undefined) {\n                    stream._closeRequest._reject(stream._storedError);\n                    stream._closeRequest = undefined;\n                }\n                const writer = stream._writer;\n                if (writer !== undefined) {\n                    defaultWriterClosedPromiseReject(writer, stream._storedError);\n                }\n            }\n            function WritableStreamUpdateBackpressure(stream, backpressure) {\n                const writer = stream._writer;\n                if (writer !== undefined && backpressure !== stream._backpressure) {\n                    if (backpressure) {\n                        defaultWriterReadyPromiseReset(writer);\n                    } else {\n                        defaultWriterReadyPromiseResolve(writer);\n                    }\n                }\n                stream._backpressure = backpressure;\n            }\n            /**\n\t\t     * A default writer vended by a {@link WritableStream}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class WritableStreamDefaultWriter {\n                constructor(stream){\n                    assertRequiredArgument(stream, 1, \"WritableStreamDefaultWriter\");\n                    assertWritableStream(stream, \"First parameter\");\n                    if (IsWritableStreamLocked(stream)) {\n                        throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n                    }\n                    this._ownerWritableStream = stream;\n                    stream._writer = this;\n                    const state = stream._state;\n                    if (state === \"writable\") {\n                        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                            defaultWriterReadyPromiseInitialize(this);\n                        } else {\n                            defaultWriterReadyPromiseInitializeAsResolved(this);\n                        }\n                        defaultWriterClosedPromiseInitialize(this);\n                    } else if (state === \"erroring\") {\n                        defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n                        defaultWriterClosedPromiseInitialize(this);\n                    } else if (state === \"closed\") {\n                        defaultWriterReadyPromiseInitializeAsResolved(this);\n                        defaultWriterClosedPromiseInitializeAsResolved(this);\n                    } else {\n                        const storedError = stream._storedError;\n                        defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n                        defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n                    }\n                }\n                /**\n\t\t         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n\t\t         * the writers lock is released before the stream finishes closing.\n\t\t         */ get closed() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"closed\"));\n                    }\n                    return this._closedPromise;\n                }\n                /**\n\t\t         * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n\t\t         * A producer can use this information to determine the right amount of data to write.\n\t\t         *\n\t\t         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n\t\t         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n\t\t         * the writers lock is released.\n\t\t         */ get desiredSize() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        throw defaultWriterBrandCheckException(\"desiredSize\");\n                    }\n                    if (this._ownerWritableStream === undefined) {\n                        throw defaultWriterLockException(\"desiredSize\");\n                    }\n                    return WritableStreamDefaultWriterGetDesiredSize(this);\n                }\n                /**\n\t\t         * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n\t\t         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n\t\t         * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n\t\t         *\n\t\t         * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n\t\t         * rejected.\n\t\t         */ get ready() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"ready\"));\n                    }\n                    return this._readyPromise;\n                }\n                /**\n\t\t         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n\t\t         */ abort(reason = undefined) {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"abort\"));\n                    }\n                    if (this._ownerWritableStream === undefined) {\n                        return promiseRejectedWith(defaultWriterLockException(\"abort\"));\n                    }\n                    return WritableStreamDefaultWriterAbort(this, reason);\n                }\n                /**\n\t\t         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n\t\t         */ close() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"close\"));\n                    }\n                    const stream = this._ownerWritableStream;\n                    if (stream === undefined) {\n                        return promiseRejectedWith(defaultWriterLockException(\"close\"));\n                    }\n                    if (WritableStreamCloseQueuedOrInFlight(stream)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n                    }\n                    return WritableStreamDefaultWriterClose(this);\n                }\n                /**\n\t\t         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n\t\t         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n\t\t         * now on; otherwise, the writer will appear closed.\n\t\t         *\n\t\t         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n\t\t         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n\t\t         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n\t\t         * other producers from writing in an interleaved manner.\n\t\t         */ releaseLock() {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        throw defaultWriterBrandCheckException(\"releaseLock\");\n                    }\n                    const stream = this._ownerWritableStream;\n                    if (stream === undefined) {\n                        return;\n                    }\n                    WritableStreamDefaultWriterRelease(this);\n                }\n                write(chunk = undefined) {\n                    if (!IsWritableStreamDefaultWriter(this)) {\n                        return promiseRejectedWith(defaultWriterBrandCheckException(\"write\"));\n                    }\n                    if (this._ownerWritableStream === undefined) {\n                        return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n                    }\n                    return WritableStreamDefaultWriterWrite(this, chunk);\n                }\n            }\n            Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n                abort: {\n                    enumerable: true\n                },\n                close: {\n                    enumerable: true\n                },\n                releaseLock: {\n                    enumerable: true\n                },\n                write: {\n                    enumerable: true\n                },\n                closed: {\n                    enumerable: true\n                },\n                desiredSize: {\n                    enumerable: true\n                },\n                ready: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"WritableStreamDefaultWriter\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the WritableStreamDefaultWriter.\n            function IsWritableStreamDefaultWriter(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_ownerWritableStream\")) {\n                    return false;\n                }\n                return x instanceof WritableStreamDefaultWriter;\n            }\n            // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n            function WritableStreamDefaultWriterAbort(writer, reason) {\n                const stream = writer._ownerWritableStream;\n                return WritableStreamAbort(stream, reason);\n            }\n            function WritableStreamDefaultWriterClose(writer) {\n                const stream = writer._ownerWritableStream;\n                return WritableStreamClose(stream);\n            }\n            function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n                const stream = writer._ownerWritableStream;\n                const state = stream._state;\n                if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n                    return promiseResolvedWith(undefined);\n                }\n                if (state === \"errored\") {\n                    return promiseRejectedWith(stream._storedError);\n                }\n                return WritableStreamDefaultWriterClose(writer);\n            }\n            function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n                if (writer._closedPromiseState === \"pending\") {\n                    defaultWriterClosedPromiseReject(writer, error);\n                } else {\n                    defaultWriterClosedPromiseResetToRejected(writer, error);\n                }\n            }\n            function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n                if (writer._readyPromiseState === \"pending\") {\n                    defaultWriterReadyPromiseReject(writer, error);\n                } else {\n                    defaultWriterReadyPromiseResetToRejected(writer, error);\n                }\n            }\n            function WritableStreamDefaultWriterGetDesiredSize(writer) {\n                const stream = writer._ownerWritableStream;\n                const state = stream._state;\n                if (state === \"errored\" || state === \"erroring\") {\n                    return null;\n                }\n                if (state === \"closed\") {\n                    return 0;\n                }\n                return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n            }\n            function WritableStreamDefaultWriterRelease(writer) {\n                const stream = writer._ownerWritableStream;\n                const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n                WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n                // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n                // rejected until afterwards. This means that simply testing state will not work.\n                WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n                stream._writer = undefined;\n                writer._ownerWritableStream = undefined;\n            }\n            function WritableStreamDefaultWriterWrite(writer, chunk) {\n                const stream = writer._ownerWritableStream;\n                const controller = stream._writableStreamController;\n                const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n                if (stream !== writer._ownerWritableStream) {\n                    return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n                }\n                const state = stream._state;\n                if (state === \"errored\") {\n                    return promiseRejectedWith(stream._storedError);\n                }\n                if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n                    return promiseRejectedWith(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n                }\n                if (state === \"erroring\") {\n                    return promiseRejectedWith(stream._storedError);\n                }\n                const promise = WritableStreamAddWriteRequest(stream);\n                WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n                return promise;\n            }\n            const closeSentinel = {};\n            /**\n\t\t     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n\t\t     *\n\t\t     * @public\n\t\t     */ class WritableStreamDefaultController {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n\t\t         *\n\t\t         * @deprecated\n\t\t         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n\t\t         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n\t\t         */ get abortReason() {\n                    if (!IsWritableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$2(\"abortReason\");\n                    }\n                    return this._abortReason;\n                }\n                /**\n\t\t         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n\t\t         */ get signal() {\n                    if (!IsWritableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$2(\"signal\");\n                    }\n                    if (this._abortController === undefined) {\n                        // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n                        // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n                        // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n                        throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n                    }\n                    return this._abortController.signal;\n                }\n                /**\n\t\t         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n\t\t         *\n\t\t         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n\t\t         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n\t\t         * normal lifecycle of interactions with the underlying sink.\n\t\t         */ error(e = undefined) {\n                    if (!IsWritableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$2(\"error\");\n                    }\n                    const state = this._controlledWritableStream._state;\n                    if (state !== \"writable\") {\n                        // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n                        // just treat it as a no-op.\n                        return;\n                    }\n                    WritableStreamDefaultControllerError(this, e);\n                }\n                /** @internal */ [AbortSteps](reason) {\n                    const result = this._abortAlgorithm(reason);\n                    WritableStreamDefaultControllerClearAlgorithms(this);\n                    return result;\n                }\n                /** @internal */ [ErrorSteps]() {\n                    ResetQueue(this);\n                }\n            }\n            Object.defineProperties(WritableStreamDefaultController.prototype, {\n                abortReason: {\n                    enumerable: true\n                },\n                signal: {\n                    enumerable: true\n                },\n                error: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"WritableStreamDefaultController\",\n                    configurable: true\n                });\n            }\n            // Abstract operations implementing interface required by the WritableStream.\n            function IsWritableStreamDefaultController(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_controlledWritableStream\")) {\n                    return false;\n                }\n                return x instanceof WritableStreamDefaultController;\n            }\n            function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n                controller._controlledWritableStream = stream;\n                stream._writableStreamController = controller;\n                // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n                controller._queue = undefined;\n                controller._queueTotalSize = undefined;\n                ResetQueue(controller);\n                controller._abortReason = undefined;\n                controller._abortController = createAbortController();\n                controller._started = false;\n                controller._strategySizeAlgorithm = sizeAlgorithm;\n                controller._strategyHWM = highWaterMark;\n                controller._writeAlgorithm = writeAlgorithm;\n                controller._closeAlgorithm = closeAlgorithm;\n                controller._abortAlgorithm = abortAlgorithm;\n                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                WritableStreamUpdateBackpressure(stream, backpressure);\n                const startResult = startAlgorithm();\n                const startPromise = promiseResolvedWith(startResult);\n                uponPromise(startPromise, ()=>{\n                    controller._started = true;\n                    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n                }, (r)=>{\n                    controller._started = true;\n                    WritableStreamDealWithRejection(stream, r);\n                });\n            }\n            function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n                const controller = Object.create(WritableStreamDefaultController.prototype);\n                let startAlgorithm = ()=>undefined;\n                let writeAlgorithm = ()=>promiseResolvedWith(undefined);\n                let closeAlgorithm = ()=>promiseResolvedWith(undefined);\n                let abortAlgorithm = ()=>promiseResolvedWith(undefined);\n                if (underlyingSink.start !== undefined) {\n                    startAlgorithm = ()=>underlyingSink.start(controller);\n                }\n                if (underlyingSink.write !== undefined) {\n                    writeAlgorithm = (chunk)=>underlyingSink.write(chunk, controller);\n                }\n                if (underlyingSink.close !== undefined) {\n                    closeAlgorithm = ()=>underlyingSink.close();\n                }\n                if (underlyingSink.abort !== undefined) {\n                    abortAlgorithm = (reason)=>underlyingSink.abort(reason);\n                }\n                SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n            }\n            // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n            function WritableStreamDefaultControllerClearAlgorithms(controller) {\n                controller._writeAlgorithm = undefined;\n                controller._closeAlgorithm = undefined;\n                controller._abortAlgorithm = undefined;\n                controller._strategySizeAlgorithm = undefined;\n            }\n            function WritableStreamDefaultControllerClose(controller) {\n                EnqueueValueWithSize(controller, closeSentinel, 0);\n                WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n            }\n            function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n                try {\n                    return controller._strategySizeAlgorithm(chunk);\n                } catch (chunkSizeE) {\n                    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n                    return 1;\n                }\n            }\n            function WritableStreamDefaultControllerGetDesiredSize(controller) {\n                return controller._strategyHWM - controller._queueTotalSize;\n            }\n            function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n                try {\n                    EnqueueValueWithSize(controller, chunk, chunkSize);\n                } catch (enqueueE) {\n                    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n                    return;\n                }\n                const stream = controller._controlledWritableStream;\n                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === \"writable\") {\n                    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                    WritableStreamUpdateBackpressure(stream, backpressure);\n                }\n                WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n            }\n            // Abstract operations for the WritableStreamDefaultController.\n            function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n                const stream = controller._controlledWritableStream;\n                if (!controller._started) {\n                    return;\n                }\n                if (stream._inFlightWriteRequest !== undefined) {\n                    return;\n                }\n                const state = stream._state;\n                if (state === \"erroring\") {\n                    WritableStreamFinishErroring(stream);\n                    return;\n                }\n                if (controller._queue.length === 0) {\n                    return;\n                }\n                const value1 = PeekQueueValue(controller);\n                if (value1 === closeSentinel) {\n                    WritableStreamDefaultControllerProcessClose(controller);\n                } else {\n                    WritableStreamDefaultControllerProcessWrite(controller, value1);\n                }\n            }\n            function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n                if (controller._controlledWritableStream._state === \"writable\") {\n                    WritableStreamDefaultControllerError(controller, error);\n                }\n            }\n            function WritableStreamDefaultControllerProcessClose(controller) {\n                const stream = controller._controlledWritableStream;\n                WritableStreamMarkCloseRequestInFlight(stream);\n                DequeueValue(controller);\n                const sinkClosePromise = controller._closeAlgorithm();\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n                uponPromise(sinkClosePromise, ()=>{\n                    WritableStreamFinishInFlightClose(stream);\n                }, (reason)=>{\n                    WritableStreamFinishInFlightCloseWithError(stream, reason);\n                });\n            }\n            function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n                const stream = controller._controlledWritableStream;\n                WritableStreamMarkFirstWriteRequestInFlight(stream);\n                const sinkWritePromise = controller._writeAlgorithm(chunk);\n                uponPromise(sinkWritePromise, ()=>{\n                    WritableStreamFinishInFlightWrite(stream);\n                    const state = stream._state;\n                    DequeueValue(controller);\n                    if (!WritableStreamCloseQueuedOrInFlight(stream) && state === \"writable\") {\n                        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                        WritableStreamUpdateBackpressure(stream, backpressure);\n                    }\n                    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n                }, (reason)=>{\n                    if (stream._state === \"writable\") {\n                        WritableStreamDefaultControllerClearAlgorithms(controller);\n                    }\n                    WritableStreamFinishInFlightWriteWithError(stream, reason);\n                });\n            }\n            function WritableStreamDefaultControllerGetBackpressure(controller) {\n                const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n                return desiredSize <= 0;\n            }\n            // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n            function WritableStreamDefaultControllerError(controller, error) {\n                const stream = controller._controlledWritableStream;\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n                WritableStreamStartErroring(stream, error);\n            }\n            // Helper functions for the WritableStream.\n            function streamBrandCheckException$2(name) {\n                return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n            }\n            // Helper functions for the WritableStreamDefaultController.\n            function defaultControllerBrandCheckException$2(name) {\n                return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n            }\n            // Helper functions for the WritableStreamDefaultWriter.\n            function defaultWriterBrandCheckException(name) {\n                return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n            }\n            function defaultWriterLockException(name) {\n                return new TypeError(\"Cannot \" + name + \" a stream using a released writer\");\n            }\n            function defaultWriterClosedPromiseInitialize(writer) {\n                writer._closedPromise = newPromise((resolve, reject)=>{\n                    writer._closedPromise_resolve = resolve;\n                    writer._closedPromise_reject = reject;\n                    writer._closedPromiseState = \"pending\";\n                });\n            }\n            function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n                defaultWriterClosedPromiseInitialize(writer);\n                defaultWriterClosedPromiseReject(writer, reason);\n            }\n            function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n                defaultWriterClosedPromiseInitialize(writer);\n                defaultWriterClosedPromiseResolve(writer);\n            }\n            function defaultWriterClosedPromiseReject(writer, reason) {\n                if (writer._closedPromise_reject === undefined) {\n                    return;\n                }\n                setPromiseIsHandledToTrue(writer._closedPromise);\n                writer._closedPromise_reject(reason);\n                writer._closedPromise_resolve = undefined;\n                writer._closedPromise_reject = undefined;\n                writer._closedPromiseState = \"rejected\";\n            }\n            function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n                defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n            }\n            function defaultWriterClosedPromiseResolve(writer) {\n                if (writer._closedPromise_resolve === undefined) {\n                    return;\n                }\n                writer._closedPromise_resolve(undefined);\n                writer._closedPromise_resolve = undefined;\n                writer._closedPromise_reject = undefined;\n                writer._closedPromiseState = \"resolved\";\n            }\n            function defaultWriterReadyPromiseInitialize(writer) {\n                writer._readyPromise = newPromise((resolve, reject)=>{\n                    writer._readyPromise_resolve = resolve;\n                    writer._readyPromise_reject = reject;\n                });\n                writer._readyPromiseState = \"pending\";\n            }\n            function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n                defaultWriterReadyPromiseInitialize(writer);\n                defaultWriterReadyPromiseReject(writer, reason);\n            }\n            function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n                defaultWriterReadyPromiseInitialize(writer);\n                defaultWriterReadyPromiseResolve(writer);\n            }\n            function defaultWriterReadyPromiseReject(writer, reason) {\n                if (writer._readyPromise_reject === undefined) {\n                    return;\n                }\n                setPromiseIsHandledToTrue(writer._readyPromise);\n                writer._readyPromise_reject(reason);\n                writer._readyPromise_resolve = undefined;\n                writer._readyPromise_reject = undefined;\n                writer._readyPromiseState = \"rejected\";\n            }\n            function defaultWriterReadyPromiseReset(writer) {\n                defaultWriterReadyPromiseInitialize(writer);\n            }\n            function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n                defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n            }\n            function defaultWriterReadyPromiseResolve(writer) {\n                if (writer._readyPromise_resolve === undefined) {\n                    return;\n                }\n                writer._readyPromise_resolve(undefined);\n                writer._readyPromise_resolve = undefined;\n                writer._readyPromise_reject = undefined;\n                writer._readyPromiseState = \"fulfilled\";\n            }\n            /// <reference lib=\"dom\" />\n            const NativeDOMException = typeof DOMException !== \"undefined\" ? DOMException : undefined;\n            /// <reference types=\"node\" />\n            function isDOMExceptionConstructor(ctor) {\n                if (!(typeof ctor === \"function\" || typeof ctor === \"object\")) {\n                    return false;\n                }\n                try {\n                    new ctor();\n                    return true;\n                } catch (_a) {\n                    return false;\n                }\n            }\n            function createDOMExceptionPolyfill() {\n                // eslint-disable-next-line no-shadow\n                const ctor = function DOMException1(message, name) {\n                    this.message = message || \"\";\n                    this.name = name || \"Error\";\n                    if (Error.captureStackTrace) {\n                        Error.captureStackTrace(this, this.constructor);\n                    }\n                };\n                ctor.prototype = Object.create(Error.prototype);\n                Object.defineProperty(ctor.prototype, \"constructor\", {\n                    value: ctor,\n                    writable: true,\n                    configurable: true\n                });\n                return ctor;\n            }\n            // eslint-disable-next-line no-redeclare\n            const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n            function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n                const reader = AcquireReadableStreamDefaultReader(source);\n                const writer = AcquireWritableStreamDefaultWriter(dest);\n                source._disturbed = true;\n                let shuttingDown = false;\n                // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n                let currentWrite = promiseResolvedWith(undefined);\n                return newPromise((resolve, reject)=>{\n                    let abortAlgorithm;\n                    if (signal !== undefined) {\n                        abortAlgorithm = ()=>{\n                            const error = new DOMException$1(\"Aborted\", \"AbortError\");\n                            const actions = [];\n                            if (!preventAbort) {\n                                actions.push(()=>{\n                                    if (dest._state === \"writable\") {\n                                        return WritableStreamAbort(dest, error);\n                                    }\n                                    return promiseResolvedWith(undefined);\n                                });\n                            }\n                            if (!preventCancel) {\n                                actions.push(()=>{\n                                    if (source._state === \"readable\") {\n                                        return ReadableStreamCancel(source, error);\n                                    }\n                                    return promiseResolvedWith(undefined);\n                                });\n                            }\n                            shutdownWithAction(()=>Promise.all(actions.map((action)=>action())), true, error);\n                        };\n                        if (signal.aborted) {\n                            abortAlgorithm();\n                            return;\n                        }\n                        signal.addEventListener(\"abort\", abortAlgorithm);\n                    }\n                    // Using reader and writer, read all chunks from this and write them to dest\n                    // - Backpressure must be enforced\n                    // - Shutdown must stop all activity\n                    function pipeLoop() {\n                        return newPromise((resolveLoop, rejectLoop)=>{\n                            function next(done) {\n                                if (done) {\n                                    resolveLoop();\n                                } else {\n                                    // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                                    // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                                    PerformPromiseThen(pipeStep(), next, rejectLoop);\n                                }\n                            }\n                            next(false);\n                        });\n                    }\n                    function pipeStep() {\n                        if (shuttingDown) {\n                            return promiseResolvedWith(true);\n                        }\n                        return PerformPromiseThen(writer._readyPromise, ()=>{\n                            return newPromise((resolveRead, rejectRead)=>{\n                                ReadableStreamDefaultReaderRead(reader, {\n                                    _chunkSteps: (chunk)=>{\n                                        currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                                        resolveRead(false);\n                                    },\n                                    _closeSteps: ()=>resolveRead(true),\n                                    _errorSteps: rejectRead\n                                });\n                            });\n                        });\n                    }\n                    // Errors must be propagated forward\n                    isOrBecomesErrored(source, reader._closedPromise, (storedError)=>{\n                        if (!preventAbort) {\n                            shutdownWithAction(()=>WritableStreamAbort(dest, storedError), true, storedError);\n                        } else {\n                            shutdown(true, storedError);\n                        }\n                    });\n                    // Errors must be propagated backward\n                    isOrBecomesErrored(dest, writer._closedPromise, (storedError)=>{\n                        if (!preventCancel) {\n                            shutdownWithAction(()=>ReadableStreamCancel(source, storedError), true, storedError);\n                        } else {\n                            shutdown(true, storedError);\n                        }\n                    });\n                    // Closing must be propagated forward\n                    isOrBecomesClosed(source, reader._closedPromise, ()=>{\n                        if (!preventClose) {\n                            shutdownWithAction(()=>WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n                        } else {\n                            shutdown();\n                        }\n                    });\n                    // Closing must be propagated backward\n                    if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === \"closed\") {\n                        const destClosed = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n                        if (!preventCancel) {\n                            shutdownWithAction(()=>ReadableStreamCancel(source, destClosed), true, destClosed);\n                        } else {\n                            shutdown(true, destClosed);\n                        }\n                    }\n                    setPromiseIsHandledToTrue(pipeLoop());\n                    function waitForWritesToFinish() {\n                        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n                        // for that too.\n                        const oldCurrentWrite = currentWrite;\n                        return PerformPromiseThen(currentWrite, ()=>oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n                    }\n                    function isOrBecomesErrored(stream, promise, action) {\n                        if (stream._state === \"errored\") {\n                            action(stream._storedError);\n                        } else {\n                            uponRejection(promise, action);\n                        }\n                    }\n                    function isOrBecomesClosed(stream, promise, action) {\n                        if (stream._state === \"closed\") {\n                            action();\n                        } else {\n                            uponFulfillment(promise, action);\n                        }\n                    }\n                    function shutdownWithAction(action, originalIsError, originalError) {\n                        if (shuttingDown) {\n                            return;\n                        }\n                        shuttingDown = true;\n                        if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                            uponFulfillment(waitForWritesToFinish(), doTheRest);\n                        } else {\n                            doTheRest();\n                        }\n                        function doTheRest() {\n                            uponPromise(action(), ()=>finalize(originalIsError, originalError), (newError)=>finalize(true, newError));\n                        }\n                    }\n                    function shutdown(isError, error) {\n                        if (shuttingDown) {\n                            return;\n                        }\n                        shuttingDown = true;\n                        if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                            uponFulfillment(waitForWritesToFinish(), ()=>finalize(isError, error));\n                        } else {\n                            finalize(isError, error);\n                        }\n                    }\n                    function finalize(isError, error) {\n                        WritableStreamDefaultWriterRelease(writer);\n                        ReadableStreamReaderGenericRelease(reader);\n                        if (signal !== undefined) {\n                            signal.removeEventListener(\"abort\", abortAlgorithm);\n                        }\n                        if (isError) {\n                            reject(error);\n                        } else {\n                            resolve(undefined);\n                        }\n                    }\n                });\n            }\n            /**\n\t\t     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStreamDefaultController {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n\t\t         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n\t\t         */ get desiredSize() {\n                    if (!IsReadableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$1(\"desiredSize\");\n                    }\n                    return ReadableStreamDefaultControllerGetDesiredSize(this);\n                }\n                /**\n\t\t         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n\t\t         * the stream, but once those are read, the stream will become closed.\n\t\t         */ close() {\n                    if (!IsReadableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$1(\"close\");\n                    }\n                    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                        throw new TypeError(\"The stream is not in a state that permits close\");\n                    }\n                    ReadableStreamDefaultControllerClose(this);\n                }\n                enqueue(chunk = undefined) {\n                    if (!IsReadableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$1(\"enqueue\");\n                    }\n                    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                        throw new TypeError(\"The stream is not in a state that permits enqueue\");\n                    }\n                    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n                }\n                /**\n\t\t         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n\t\t         */ error(e = undefined) {\n                    if (!IsReadableStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException$1(\"error\");\n                    }\n                    ReadableStreamDefaultControllerError(this, e);\n                }\n                /** @internal */ [CancelSteps](reason) {\n                    ResetQueue(this);\n                    const result = this._cancelAlgorithm(reason);\n                    ReadableStreamDefaultControllerClearAlgorithms(this);\n                    return result;\n                }\n                /** @internal */ [PullSteps](readRequest) {\n                    const stream = this._controlledReadableStream;\n                    if (this._queue.length > 0) {\n                        const chunk = DequeueValue(this);\n                        if (this._closeRequested && this._queue.length === 0) {\n                            ReadableStreamDefaultControllerClearAlgorithms(this);\n                            ReadableStreamClose(stream);\n                        } else {\n                            ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                        }\n                        readRequest._chunkSteps(chunk);\n                    } else {\n                        ReadableStreamAddReadRequest(stream, readRequest);\n                        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                    }\n                }\n            }\n            Object.defineProperties(ReadableStreamDefaultController.prototype, {\n                close: {\n                    enumerable: true\n                },\n                enqueue: {\n                    enumerable: true\n                },\n                error: {\n                    enumerable: true\n                },\n                desiredSize: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStreamDefaultController\",\n                    configurable: true\n                });\n            }\n            // Abstract operations for the ReadableStreamDefaultController.\n            function IsReadableStreamDefaultController(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableStream\")) {\n                    return false;\n                }\n                return x instanceof ReadableStreamDefaultController;\n            }\n            function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n                const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n                if (!shouldPull) {\n                    return;\n                }\n                if (controller._pulling) {\n                    controller._pullAgain = true;\n                    return;\n                }\n                controller._pulling = true;\n                const pullPromise = controller._pullAlgorithm();\n                uponPromise(pullPromise, ()=>{\n                    controller._pulling = false;\n                    if (controller._pullAgain) {\n                        controller._pullAgain = false;\n                        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n                    }\n                }, (e)=>{\n                    ReadableStreamDefaultControllerError(controller, e);\n                });\n            }\n            function ReadableStreamDefaultControllerShouldCallPull(controller) {\n                const stream = controller._controlledReadableStream;\n                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n                    return false;\n                }\n                if (!controller._started) {\n                    return false;\n                }\n                if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n                    return true;\n                }\n                const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n                if (desiredSize > 0) {\n                    return true;\n                }\n                return false;\n            }\n            function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n                controller._pullAlgorithm = undefined;\n                controller._cancelAlgorithm = undefined;\n                controller._strategySizeAlgorithm = undefined;\n            }\n            // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n            function ReadableStreamDefaultControllerClose(controller) {\n                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n                    return;\n                }\n                const stream = controller._controlledReadableStream;\n                controller._closeRequested = true;\n                if (controller._queue.length === 0) {\n                    ReadableStreamDefaultControllerClearAlgorithms(controller);\n                    ReadableStreamClose(stream);\n                }\n            }\n            function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n                    return;\n                }\n                const stream = controller._controlledReadableStream;\n                if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n                    ReadableStreamFulfillReadRequest(stream, chunk, false);\n                } else {\n                    let chunkSize;\n                    try {\n                        chunkSize = controller._strategySizeAlgorithm(chunk);\n                    } catch (chunkSizeE) {\n                        ReadableStreamDefaultControllerError(controller, chunkSizeE);\n                        throw chunkSizeE;\n                    }\n                    try {\n                        EnqueueValueWithSize(controller, chunk, chunkSize);\n                    } catch (enqueueE) {\n                        ReadableStreamDefaultControllerError(controller, enqueueE);\n                        throw enqueueE;\n                    }\n                }\n                ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n            }\n            function ReadableStreamDefaultControllerError(controller, e) {\n                const stream = controller._controlledReadableStream;\n                if (stream._state !== \"readable\") {\n                    return;\n                }\n                ResetQueue(controller);\n                ReadableStreamDefaultControllerClearAlgorithms(controller);\n                ReadableStreamError(stream, e);\n            }\n            function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n                const state = controller._controlledReadableStream._state;\n                if (state === \"errored\") {\n                    return null;\n                }\n                if (state === \"closed\") {\n                    return 0;\n                }\n                return controller._strategyHWM - controller._queueTotalSize;\n            }\n            // This is used in the implementation of TransformStream.\n            function ReadableStreamDefaultControllerHasBackpressure(controller) {\n                if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n                    return false;\n                }\n                return true;\n            }\n            function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n                const state = controller._controlledReadableStream._state;\n                if (!controller._closeRequested && state === \"readable\") {\n                    return true;\n                }\n                return false;\n            }\n            function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n                controller._controlledReadableStream = stream;\n                controller._queue = undefined;\n                controller._queueTotalSize = undefined;\n                ResetQueue(controller);\n                controller._started = false;\n                controller._closeRequested = false;\n                controller._pullAgain = false;\n                controller._pulling = false;\n                controller._strategySizeAlgorithm = sizeAlgorithm;\n                controller._strategyHWM = highWaterMark;\n                controller._pullAlgorithm = pullAlgorithm;\n                controller._cancelAlgorithm = cancelAlgorithm;\n                stream._readableStreamController = controller;\n                const startResult = startAlgorithm();\n                uponPromise(promiseResolvedWith(startResult), ()=>{\n                    controller._started = true;\n                    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n                }, (r)=>{\n                    ReadableStreamDefaultControllerError(controller, r);\n                });\n            }\n            function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n                const controller = Object.create(ReadableStreamDefaultController.prototype);\n                let startAlgorithm = ()=>undefined;\n                let pullAlgorithm = ()=>promiseResolvedWith(undefined);\n                let cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n                if (underlyingSource.start !== undefined) {\n                    startAlgorithm = ()=>underlyingSource.start(controller);\n                }\n                if (underlyingSource.pull !== undefined) {\n                    pullAlgorithm = ()=>underlyingSource.pull(controller);\n                }\n                if (underlyingSource.cancel !== undefined) {\n                    cancelAlgorithm = (reason)=>underlyingSource.cancel(reason);\n                }\n                SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n            }\n            // Helper functions for the ReadableStreamDefaultController.\n            function defaultControllerBrandCheckException$1(name) {\n                return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n            }\n            function ReadableStreamTee(stream, cloneForBranch2) {\n                if (IsReadableByteStreamController(stream._readableStreamController)) {\n                    return ReadableByteStreamTee(stream);\n                }\n                return ReadableStreamDefaultTee(stream);\n            }\n            function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n                const reader = AcquireReadableStreamDefaultReader(stream);\n                let reading = false;\n                let readAgain = false;\n                let canceled1 = false;\n                let canceled2 = false;\n                let reason1;\n                let reason2;\n                let branch1;\n                let branch2;\n                let resolveCancelPromise;\n                const cancelPromise = newPromise((resolve)=>{\n                    resolveCancelPromise = resolve;\n                });\n                function pullAlgorithm() {\n                    if (reading) {\n                        readAgain = true;\n                        return promiseResolvedWith(undefined);\n                    }\n                    reading = true;\n                    const readRequest = {\n                        _chunkSteps: (chunk)=>{\n                            // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                            // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                            // successful synchronously-available reads get ahead of asynchronously-available errors.\n                            queueMicrotask(()=>{\n                                readAgain = false;\n                                const chunk1 = chunk;\n                                const chunk2 = chunk;\n                                // There is no way to access the cloning code right now in the reference implementation.\n                                // If we add one then we'll need an implementation for serializable objects.\n                                // if (!canceled2 && cloneForBranch2) {\n                                //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n                                // }\n                                if (!canceled1) {\n                                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                                }\n                                if (!canceled2) {\n                                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                                }\n                                reading = false;\n                                if (readAgain) {\n                                    pullAlgorithm();\n                                }\n                            });\n                        },\n                        _closeSteps: ()=>{\n                            reading = false;\n                            if (!canceled1) {\n                                ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                            }\n                            if (!canceled2) {\n                                ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                            }\n                            if (!canceled1 || !canceled2) {\n                                resolveCancelPromise(undefined);\n                            }\n                        },\n                        _errorSteps: ()=>{\n                            reading = false;\n                        }\n                    };\n                    ReadableStreamDefaultReaderRead(reader, readRequest);\n                    return promiseResolvedWith(undefined);\n                }\n                function cancel1Algorithm(reason) {\n                    canceled1 = true;\n                    reason1 = reason;\n                    if (canceled2) {\n                        const compositeReason = CreateArrayFromList([\n                            reason1,\n                            reason2\n                        ]);\n                        const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                        resolveCancelPromise(cancelResult);\n                    }\n                    return cancelPromise;\n                }\n                function cancel2Algorithm(reason) {\n                    canceled2 = true;\n                    reason2 = reason;\n                    if (canceled1) {\n                        const compositeReason = CreateArrayFromList([\n                            reason1,\n                            reason2\n                        ]);\n                        const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                        resolveCancelPromise(cancelResult);\n                    }\n                    return cancelPromise;\n                }\n                function startAlgorithm() {\n                // do nothing\n                }\n                branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n                branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n                uponRejection(reader._closedPromise, (r)=>{\n                    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n                    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                });\n                return [\n                    branch1,\n                    branch2\n                ];\n            }\n            function ReadableByteStreamTee(stream) {\n                let reader = AcquireReadableStreamDefaultReader(stream);\n                let reading = false;\n                let readAgainForBranch1 = false;\n                let readAgainForBranch2 = false;\n                let canceled1 = false;\n                let canceled2 = false;\n                let reason1;\n                let reason2;\n                let branch1;\n                let branch2;\n                let resolveCancelPromise;\n                const cancelPromise = newPromise((resolve)=>{\n                    resolveCancelPromise = resolve;\n                });\n                function forwardReaderError(thisReader) {\n                    uponRejection(thisReader._closedPromise, (r)=>{\n                        if (thisReader !== reader) {\n                            return;\n                        }\n                        ReadableByteStreamControllerError(branch1._readableStreamController, r);\n                        ReadableByteStreamControllerError(branch2._readableStreamController, r);\n                        if (!canceled1 || !canceled2) {\n                            resolveCancelPromise(undefined);\n                        }\n                    });\n                }\n                function pullWithDefaultReader() {\n                    if (IsReadableStreamBYOBReader(reader)) {\n                        ReadableStreamReaderGenericRelease(reader);\n                        reader = AcquireReadableStreamDefaultReader(stream);\n                        forwardReaderError(reader);\n                    }\n                    const readRequest = {\n                        _chunkSteps: (chunk)=>{\n                            // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                            // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                            // successful synchronously-available reads get ahead of asynchronously-available errors.\n                            queueMicrotask(()=>{\n                                readAgainForBranch1 = false;\n                                readAgainForBranch2 = false;\n                                const chunk1 = chunk;\n                                let chunk2 = chunk;\n                                if (!canceled1 && !canceled2) {\n                                    try {\n                                        chunk2 = CloneAsUint8Array(chunk);\n                                    } catch (cloneE) {\n                                        ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                                        ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                                        resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                        return;\n                                    }\n                                }\n                                if (!canceled1) {\n                                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                                }\n                                if (!canceled2) {\n                                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                                }\n                                reading = false;\n                                if (readAgainForBranch1) {\n                                    pull1Algorithm();\n                                } else if (readAgainForBranch2) {\n                                    pull2Algorithm();\n                                }\n                            });\n                        },\n                        _closeSteps: ()=>{\n                            reading = false;\n                            if (!canceled1) {\n                                ReadableByteStreamControllerClose(branch1._readableStreamController);\n                            }\n                            if (!canceled2) {\n                                ReadableByteStreamControllerClose(branch2._readableStreamController);\n                            }\n                            if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n                            }\n                            if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n                            }\n                            if (!canceled1 || !canceled2) {\n                                resolveCancelPromise(undefined);\n                            }\n                        },\n                        _errorSteps: ()=>{\n                            reading = false;\n                        }\n                    };\n                    ReadableStreamDefaultReaderRead(reader, readRequest);\n                }\n                function pullWithBYOBReader(view, forBranch2) {\n                    if (IsReadableStreamDefaultReader(reader)) {\n                        ReadableStreamReaderGenericRelease(reader);\n                        reader = AcquireReadableStreamBYOBReader(stream);\n                        forwardReaderError(reader);\n                    }\n                    const byobBranch = forBranch2 ? branch2 : branch1;\n                    const otherBranch = forBranch2 ? branch1 : branch2;\n                    const readIntoRequest = {\n                        _chunkSteps: (chunk)=>{\n                            // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                            // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                            // successful synchronously-available reads get ahead of asynchronously-available errors.\n                            queueMicrotask(()=>{\n                                readAgainForBranch1 = false;\n                                readAgainForBranch2 = false;\n                                const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                                const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                                if (!otherCanceled) {\n                                    let clonedChunk;\n                                    try {\n                                        clonedChunk = CloneAsUint8Array(chunk);\n                                    } catch (cloneE) {\n                                        ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                                        ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                                        resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                        return;\n                                    }\n                                    if (!byobCanceled) {\n                                        ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                                    }\n                                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                                } else if (!byobCanceled) {\n                                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                                }\n                                reading = false;\n                                if (readAgainForBranch1) {\n                                    pull1Algorithm();\n                                } else if (readAgainForBranch2) {\n                                    pull2Algorithm();\n                                }\n                            });\n                        },\n                        _closeSteps: (chunk)=>{\n                            reading = false;\n                            const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                            const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                            if (!byobCanceled) {\n                                ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n                            }\n                            if (!otherCanceled) {\n                                ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n                            }\n                            if (chunk !== undefined) {\n                                if (!byobCanceled) {\n                                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                                }\n                                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                                }\n                            }\n                            if (!byobCanceled || !otherCanceled) {\n                                resolveCancelPromise(undefined);\n                            }\n                        },\n                        _errorSteps: ()=>{\n                            reading = false;\n                        }\n                    };\n                    ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n                }\n                function pull1Algorithm() {\n                    if (reading) {\n                        readAgainForBranch1 = true;\n                        return promiseResolvedWith(undefined);\n                    }\n                    reading = true;\n                    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n                    if (byobRequest === null) {\n                        pullWithDefaultReader();\n                    } else {\n                        pullWithBYOBReader(byobRequest._view, false);\n                    }\n                    return promiseResolvedWith(undefined);\n                }\n                function pull2Algorithm() {\n                    if (reading) {\n                        readAgainForBranch2 = true;\n                        return promiseResolvedWith(undefined);\n                    }\n                    reading = true;\n                    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n                    if (byobRequest === null) {\n                        pullWithDefaultReader();\n                    } else {\n                        pullWithBYOBReader(byobRequest._view, true);\n                    }\n                    return promiseResolvedWith(undefined);\n                }\n                function cancel1Algorithm(reason) {\n                    canceled1 = true;\n                    reason1 = reason;\n                    if (canceled2) {\n                        const compositeReason = CreateArrayFromList([\n                            reason1,\n                            reason2\n                        ]);\n                        const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                        resolveCancelPromise(cancelResult);\n                    }\n                    return cancelPromise;\n                }\n                function cancel2Algorithm(reason) {\n                    canceled2 = true;\n                    reason2 = reason;\n                    if (canceled1) {\n                        const compositeReason = CreateArrayFromList([\n                            reason1,\n                            reason2\n                        ]);\n                        const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                        resolveCancelPromise(cancelResult);\n                    }\n                    return cancelPromise;\n                }\n                function startAlgorithm() {\n                    return;\n                }\n                branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n                branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n                forwardReaderError(reader);\n                return [\n                    branch1,\n                    branch2\n                ];\n            }\n            function convertUnderlyingDefaultOrByteSource(source, context) {\n                assertDictionary(source, context);\n                const original = source;\n                const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n                const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n                const pull = original === null || original === void 0 ? void 0 : original.pull;\n                const start = original === null || original === void 0 ? void 0 : original.start;\n                const type = original === null || original === void 0 ? void 0 : original.type;\n                return {\n                    autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n                    cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n                    pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n                    start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n                    type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n                };\n            }\n            function convertUnderlyingSourceCancelCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (reason)=>promiseCall(fn, original, [\n                        reason\n                    ]);\n            }\n            function convertUnderlyingSourcePullCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>promiseCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertUnderlyingSourceStartCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>reflectCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertReadableStreamType(type, context) {\n                type = `${type}`;\n                if (type !== \"bytes\") {\n                    throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n                }\n                return type;\n            }\n            function convertReaderOptions(options, context) {\n                assertDictionary(options, context);\n                const mode = options === null || options === void 0 ? void 0 : options.mode;\n                return {\n                    mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n                };\n            }\n            function convertReadableStreamReaderMode(mode, context) {\n                mode = `${mode}`;\n                if (mode !== \"byob\") {\n                    throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n                }\n                return mode;\n            }\n            function convertIteratorOptions(options, context) {\n                assertDictionary(options, context);\n                const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n                return {\n                    preventCancel: Boolean(preventCancel)\n                };\n            }\n            function convertPipeOptions(options, context) {\n                assertDictionary(options, context);\n                const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n                const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n                const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n                const signal = options === null || options === void 0 ? void 0 : options.signal;\n                if (signal !== undefined) {\n                    assertAbortSignal(signal, `${context} has member 'signal' that`);\n                }\n                return {\n                    preventAbort: Boolean(preventAbort),\n                    preventCancel: Boolean(preventCancel),\n                    preventClose: Boolean(preventClose),\n                    signal\n                };\n            }\n            function assertAbortSignal(signal, context) {\n                if (!isAbortSignal(signal)) {\n                    throw new TypeError(`${context} is not an AbortSignal.`);\n                }\n            }\n            function convertReadableWritablePair(pair, context) {\n                assertDictionary(pair, context);\n                const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n                assertRequiredField(readable, \"readable\", \"ReadableWritablePair\");\n                assertReadableStream(readable, `${context} has member 'readable' that`);\n                const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n                assertRequiredField(writable, \"writable\", \"ReadableWritablePair\");\n                assertWritableStream(writable, `${context} has member 'writable' that`);\n                return {\n                    readable,\n                    writable\n                };\n            }\n            /**\n\t\t     * A readable stream represents a source of data, from which you can read.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ReadableStream1 {\n                constructor(rawUnderlyingSource = {}, rawStrategy = {}){\n                    if (rawUnderlyingSource === undefined) {\n                        rawUnderlyingSource = null;\n                    } else {\n                        assertObject(rawUnderlyingSource, \"First parameter\");\n                    }\n                    const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n                    const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, \"First parameter\");\n                    InitializeReadableStream(this);\n                    if (underlyingSource.type === \"bytes\") {\n                        if (strategy.size !== undefined) {\n                            throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n                        }\n                        const highWaterMark = ExtractHighWaterMark(strategy, 0);\n                        SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n                    } else {\n                        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                        const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                        SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n                    }\n                }\n                /**\n\t\t         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n\t\t         */ get locked() {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"locked\");\n                    }\n                    return IsReadableStreamLocked(this);\n                }\n                /**\n\t\t         * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n\t\t         *\n\t\t         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n\t\t         * method, which might or might not use it.\n\t\t         */ cancel(reason = undefined) {\n                    if (!IsReadableStream(this)) {\n                        return promiseRejectedWith(streamBrandCheckException$1(\"cancel\"));\n                    }\n                    if (IsReadableStreamLocked(this)) {\n                        return promiseRejectedWith(new TypeError(\"Cannot cancel a stream that already has a reader\"));\n                    }\n                    return ReadableStreamCancel(this, reason);\n                }\n                getReader(rawOptions = undefined) {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"getReader\");\n                    }\n                    const options = convertReaderOptions(rawOptions, \"First parameter\");\n                    if (options.mode === undefined) {\n                        return AcquireReadableStreamDefaultReader(this);\n                    }\n                    return AcquireReadableStreamBYOBReader(this);\n                }\n                pipeThrough(rawTransform, rawOptions = {}) {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"pipeThrough\");\n                    }\n                    assertRequiredArgument(rawTransform, 1, \"pipeThrough\");\n                    const transform = convertReadableWritablePair(rawTransform, \"First parameter\");\n                    const options = convertPipeOptions(rawOptions, \"Second parameter\");\n                    if (IsReadableStreamLocked(this)) {\n                        throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n                    }\n                    if (IsWritableStreamLocked(transform.writable)) {\n                        throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n                    }\n                    const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n                    setPromiseIsHandledToTrue(promise);\n                    return transform.readable;\n                }\n                pipeTo(destination, rawOptions = {}) {\n                    if (!IsReadableStream(this)) {\n                        return promiseRejectedWith(streamBrandCheckException$1(\"pipeTo\"));\n                    }\n                    if (destination === undefined) {\n                        return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n                    }\n                    if (!IsWritableStream(destination)) {\n                        return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n                    }\n                    let options;\n                    try {\n                        options = convertPipeOptions(rawOptions, \"Second parameter\");\n                    } catch (e) {\n                        return promiseRejectedWith(e);\n                    }\n                    if (IsReadableStreamLocked(this)) {\n                        return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\"));\n                    }\n                    if (IsWritableStreamLocked(destination)) {\n                        return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\"));\n                    }\n                    return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n                }\n                /**\n\t\t         * Tees this readable stream, returning a two-element array containing the two resulting branches as\n\t\t         * new {@link ReadableStream} instances.\n\t\t         *\n\t\t         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n\t\t         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n\t\t         * propagated to the stream's underlying source.\n\t\t         *\n\t\t         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n\t\t         * this could allow interference between the two branches.\n\t\t         */ tee() {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"tee\");\n                    }\n                    const branches = ReadableStreamTee(this);\n                    return CreateArrayFromList(branches);\n                }\n                values(rawOptions = undefined) {\n                    if (!IsReadableStream(this)) {\n                        throw streamBrandCheckException$1(\"values\");\n                    }\n                    const options = convertIteratorOptions(rawOptions, \"First parameter\");\n                    return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n                }\n            }\n            Object.defineProperties(ReadableStream1.prototype, {\n                cancel: {\n                    enumerable: true\n                },\n                getReader: {\n                    enumerable: true\n                },\n                pipeThrough: {\n                    enumerable: true\n                },\n                pipeTo: {\n                    enumerable: true\n                },\n                tee: {\n                    enumerable: true\n                },\n                values: {\n                    enumerable: true\n                },\n                locked: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ReadableStream1.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ReadableStream\",\n                    configurable: true\n                });\n            }\n            if (typeof SymbolPolyfill.asyncIterator === \"symbol\") {\n                Object.defineProperty(ReadableStream1.prototype, SymbolPolyfill.asyncIterator, {\n                    value: ReadableStream1.prototype.values,\n                    writable: true,\n                    configurable: true\n                });\n            }\n            // Abstract operations for the ReadableStream.\n            // Throws if and only if startAlgorithm throws.\n            function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n                const stream = Object.create(ReadableStream1.prototype);\n                InitializeReadableStream(stream);\n                const controller = Object.create(ReadableStreamDefaultController.prototype);\n                SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n                return stream;\n            }\n            // Throws if and only if startAlgorithm throws.\n            function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n                const stream = Object.create(ReadableStream1.prototype);\n                InitializeReadableStream(stream);\n                const controller = Object.create(ReadableByteStreamController.prototype);\n                SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n                return stream;\n            }\n            function InitializeReadableStream(stream) {\n                stream._state = \"readable\";\n                stream._reader = undefined;\n                stream._storedError = undefined;\n                stream._disturbed = false;\n            }\n            function IsReadableStream(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_readableStreamController\")) {\n                    return false;\n                }\n                return x instanceof ReadableStream1;\n            }\n            function IsReadableStreamLocked(stream) {\n                if (stream._reader === undefined) {\n                    return false;\n                }\n                return true;\n            }\n            // ReadableStream API exposed for controllers.\n            function ReadableStreamCancel(stream, reason) {\n                stream._disturbed = true;\n                if (stream._state === \"closed\") {\n                    return promiseResolvedWith(undefined);\n                }\n                if (stream._state === \"errored\") {\n                    return promiseRejectedWith(stream._storedError);\n                }\n                ReadableStreamClose(stream);\n                const reader = stream._reader;\n                if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n                    reader._readIntoRequests.forEach((readIntoRequest)=>{\n                        readIntoRequest._closeSteps(undefined);\n                    });\n                    reader._readIntoRequests = new SimpleQueue();\n                }\n                const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n                return transformPromiseWith(sourceCancelPromise, noop);\n            }\n            function ReadableStreamClose(stream) {\n                stream._state = \"closed\";\n                const reader = stream._reader;\n                if (reader === undefined) {\n                    return;\n                }\n                defaultReaderClosedPromiseResolve(reader);\n                if (IsReadableStreamDefaultReader(reader)) {\n                    reader._readRequests.forEach((readRequest)=>{\n                        readRequest._closeSteps();\n                    });\n                    reader._readRequests = new SimpleQueue();\n                }\n            }\n            function ReadableStreamError(stream, e) {\n                stream._state = \"errored\";\n                stream._storedError = e;\n                const reader = stream._reader;\n                if (reader === undefined) {\n                    return;\n                }\n                defaultReaderClosedPromiseReject(reader, e);\n                if (IsReadableStreamDefaultReader(reader)) {\n                    reader._readRequests.forEach((readRequest)=>{\n                        readRequest._errorSteps(e);\n                    });\n                    reader._readRequests = new SimpleQueue();\n                } else {\n                    reader._readIntoRequests.forEach((readIntoRequest)=>{\n                        readIntoRequest._errorSteps(e);\n                    });\n                    reader._readIntoRequests = new SimpleQueue();\n                }\n            }\n            // Helper functions for the ReadableStream.\n            function streamBrandCheckException$1(name) {\n                return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n            }\n            function convertQueuingStrategyInit(init, context) {\n                assertDictionary(init, context);\n                const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n                assertRequiredField(highWaterMark, \"highWaterMark\", \"QueuingStrategyInit\");\n                return {\n                    highWaterMark: convertUnrestrictedDouble(highWaterMark)\n                };\n            }\n            // The size function must not have a prototype property nor be a constructor\n            const byteLengthSizeFunction = (chunk)=>{\n                return chunk.byteLength;\n            };\n            try {\n                Object.defineProperty(byteLengthSizeFunction, \"name\", {\n                    value: \"size\",\n                    configurable: true\n                });\n            } catch (_a) {\n            // This property is non-configurable in older browsers, so ignore if this throws.\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n            }\n            /**\n\t\t     * A queuing strategy that counts the number of bytes in each chunk.\n\t\t     *\n\t\t     * @public\n\t\t     */ class ByteLengthQueuingStrategy {\n                constructor(options){\n                    assertRequiredArgument(options, 1, \"ByteLengthQueuingStrategy\");\n                    options = convertQueuingStrategyInit(options, \"First parameter\");\n                    this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n                }\n                /**\n\t\t         * Returns the high water mark provided to the constructor.\n\t\t         */ get highWaterMark() {\n                    if (!IsByteLengthQueuingStrategy(this)) {\n                        throw byteLengthBrandCheckException(\"highWaterMark\");\n                    }\n                    return this._byteLengthQueuingStrategyHighWaterMark;\n                }\n                /**\n\t\t         * Measures the size of `chunk` by returning the value of its `byteLength` property.\n\t\t         */ get size() {\n                    if (!IsByteLengthQueuingStrategy(this)) {\n                        throw byteLengthBrandCheckException(\"size\");\n                    }\n                    return byteLengthSizeFunction;\n                }\n            }\n            Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n                highWaterMark: {\n                    enumerable: true\n                },\n                size: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"ByteLengthQueuingStrategy\",\n                    configurable: true\n                });\n            }\n            // Helper functions for the ByteLengthQueuingStrategy.\n            function byteLengthBrandCheckException(name) {\n                return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n            }\n            function IsByteLengthQueuingStrategy(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_byteLengthQueuingStrategyHighWaterMark\")) {\n                    return false;\n                }\n                return x instanceof ByteLengthQueuingStrategy;\n            }\n            // The size function must not have a prototype property nor be a constructor\n            const countSizeFunction = ()=>{\n                return 1;\n            };\n            try {\n                Object.defineProperty(countSizeFunction, \"name\", {\n                    value: \"size\",\n                    configurable: true\n                });\n            } catch (_a) {\n            // This property is non-configurable in older browsers, so ignore if this throws.\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n            }\n            /**\n\t\t     * A queuing strategy that counts the number of chunks.\n\t\t     *\n\t\t     * @public\n\t\t     */ class CountQueuingStrategy {\n                constructor(options){\n                    assertRequiredArgument(options, 1, \"CountQueuingStrategy\");\n                    options = convertQueuingStrategyInit(options, \"First parameter\");\n                    this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n                }\n                /**\n\t\t         * Returns the high water mark provided to the constructor.\n\t\t         */ get highWaterMark() {\n                    if (!IsCountQueuingStrategy(this)) {\n                        throw countBrandCheckException(\"highWaterMark\");\n                    }\n                    return this._countQueuingStrategyHighWaterMark;\n                }\n                /**\n\t\t         * Measures the size of `chunk` by always returning 1.\n\t\t         * This ensures that the total queue size is a count of the number of chunks in the queue.\n\t\t         */ get size() {\n                    if (!IsCountQueuingStrategy(this)) {\n                        throw countBrandCheckException(\"size\");\n                    }\n                    return countSizeFunction;\n                }\n            }\n            Object.defineProperties(CountQueuingStrategy.prototype, {\n                highWaterMark: {\n                    enumerable: true\n                },\n                size: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"CountQueuingStrategy\",\n                    configurable: true\n                });\n            }\n            // Helper functions for the CountQueuingStrategy.\n            function countBrandCheckException(name) {\n                return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n            }\n            function IsCountQueuingStrategy(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_countQueuingStrategyHighWaterMark\")) {\n                    return false;\n                }\n                return x instanceof CountQueuingStrategy;\n            }\n            function convertTransformer(original, context) {\n                assertDictionary(original, context);\n                const flush = original === null || original === void 0 ? void 0 : original.flush;\n                const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n                const start = original === null || original === void 0 ? void 0 : original.start;\n                const transform = original === null || original === void 0 ? void 0 : original.transform;\n                const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n                return {\n                    flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n                    readableType,\n                    start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n                    transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n                    writableType\n                };\n            }\n            function convertTransformerFlushCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>promiseCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertTransformerStartCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (controller)=>reflectCall(fn, original, [\n                        controller\n                    ]);\n            }\n            function convertTransformerTransformCallback(fn, original, context) {\n                assertFunction(fn, context);\n                return (chunk, controller)=>promiseCall(fn, original, [\n                        chunk,\n                        controller\n                    ]);\n            }\n            // Class TransformStream\n            /**\n\t\t     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n\t\t     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n\t\t     * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n\t\t     * made available for reading from the readable side.\n\t\t     *\n\t\t     * @public\n\t\t     */ class TransformStream {\n                constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}){\n                    if (rawTransformer === undefined) {\n                        rawTransformer = null;\n                    }\n                    const writableStrategy = convertQueuingStrategy(rawWritableStrategy, \"Second parameter\");\n                    const readableStrategy = convertQueuingStrategy(rawReadableStrategy, \"Third parameter\");\n                    const transformer = convertTransformer(rawTransformer, \"First parameter\");\n                    if (transformer.readableType !== undefined) {\n                        throw new RangeError(\"Invalid readableType specified\");\n                    }\n                    if (transformer.writableType !== undefined) {\n                        throw new RangeError(\"Invalid writableType specified\");\n                    }\n                    const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n                    const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n                    const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n                    const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n                    let startPromise_resolve;\n                    const startPromise = newPromise((resolve)=>{\n                        startPromise_resolve = resolve;\n                    });\n                    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n                    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n                    if (transformer.start !== undefined) {\n                        startPromise_resolve(transformer.start(this._transformStreamController));\n                    } else {\n                        startPromise_resolve(undefined);\n                    }\n                }\n                /**\n\t\t         * The readable side of the transform stream.\n\t\t         */ get readable() {\n                    if (!IsTransformStream(this)) {\n                        throw streamBrandCheckException(\"readable\");\n                    }\n                    return this._readable;\n                }\n                /**\n\t\t         * The writable side of the transform stream.\n\t\t         */ get writable() {\n                    if (!IsTransformStream(this)) {\n                        throw streamBrandCheckException(\"writable\");\n                    }\n                    return this._writable;\n                }\n            }\n            Object.defineProperties(TransformStream.prototype, {\n                readable: {\n                    enumerable: true\n                },\n                writable: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"TransformStream\",\n                    configurable: true\n                });\n            }\n            function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n                function startAlgorithm() {\n                    return startPromise;\n                }\n                function writeAlgorithm(chunk) {\n                    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n                }\n                function abortAlgorithm(reason) {\n                    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n                }\n                function closeAlgorithm() {\n                    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n                }\n                stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n                function pullAlgorithm() {\n                    return TransformStreamDefaultSourcePullAlgorithm(stream);\n                }\n                function cancelAlgorithm(reason) {\n                    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n                    return promiseResolvedWith(undefined);\n                }\n                stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n                // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n                stream._backpressure = undefined;\n                stream._backpressureChangePromise = undefined;\n                stream._backpressureChangePromise_resolve = undefined;\n                TransformStreamSetBackpressure(stream, true);\n                stream._transformStreamController = undefined;\n            }\n            function IsTransformStream(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_transformStreamController\")) {\n                    return false;\n                }\n                return x instanceof TransformStream;\n            }\n            // This is a no-op if both sides are already errored.\n            function TransformStreamError(stream, e) {\n                ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n                TransformStreamErrorWritableAndUnblockWrite(stream, e);\n            }\n            function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n                TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n                WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n                if (stream._backpressure) {\n                    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n                    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n                    // _backpressure is set.\n                    TransformStreamSetBackpressure(stream, false);\n                }\n            }\n            function TransformStreamSetBackpressure(stream, backpressure) {\n                // Passes also when called during construction.\n                if (stream._backpressureChangePromise !== undefined) {\n                    stream._backpressureChangePromise_resolve();\n                }\n                stream._backpressureChangePromise = newPromise((resolve)=>{\n                    stream._backpressureChangePromise_resolve = resolve;\n                });\n                stream._backpressure = backpressure;\n            }\n            // Class TransformStreamDefaultController\n            /**\n\t\t     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n\t\t     *\n\t\t     * @public\n\t\t     */ class TransformStreamDefaultController {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                /**\n\t\t         * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n\t\t         */ get desiredSize() {\n                    if (!IsTransformStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException(\"desiredSize\");\n                    }\n                    const readableController = this._controlledTransformStream._readable._readableStreamController;\n                    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n                }\n                enqueue(chunk = undefined) {\n                    if (!IsTransformStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException(\"enqueue\");\n                    }\n                    TransformStreamDefaultControllerEnqueue(this, chunk);\n                }\n                /**\n\t\t         * Errors both the readable side and the writable side of the controlled transform stream, making all future\n\t\t         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n\t\t         */ error(reason = undefined) {\n                    if (!IsTransformStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException(\"error\");\n                    }\n                    TransformStreamDefaultControllerError(this, reason);\n                }\n                /**\n\t\t         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n\t\t         * transformer only needs to consume a portion of the chunks written to the writable side.\n\t\t         */ terminate() {\n                    if (!IsTransformStreamDefaultController(this)) {\n                        throw defaultControllerBrandCheckException(\"terminate\");\n                    }\n                    TransformStreamDefaultControllerTerminate(this);\n                }\n            }\n            Object.defineProperties(TransformStreamDefaultController.prototype, {\n                enqueue: {\n                    enumerable: true\n                },\n                error: {\n                    enumerable: true\n                },\n                terminate: {\n                    enumerable: true\n                },\n                desiredSize: {\n                    enumerable: true\n                }\n            });\n            if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n                Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n                    value: \"TransformStreamDefaultController\",\n                    configurable: true\n                });\n            }\n            // Transform Stream Default Controller Abstract Operations\n            function IsTransformStreamDefaultController(x) {\n                if (!typeIsObject(x)) {\n                    return false;\n                }\n                if (!Object.prototype.hasOwnProperty.call(x, \"_controlledTransformStream\")) {\n                    return false;\n                }\n                return x instanceof TransformStreamDefaultController;\n            }\n            function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n                controller._controlledTransformStream = stream;\n                stream._transformStreamController = controller;\n                controller._transformAlgorithm = transformAlgorithm;\n                controller._flushAlgorithm = flushAlgorithm;\n            }\n            function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n                const controller = Object.create(TransformStreamDefaultController.prototype);\n                let transformAlgorithm = (chunk)=>{\n                    try {\n                        TransformStreamDefaultControllerEnqueue(controller, chunk);\n                        return promiseResolvedWith(undefined);\n                    } catch (transformResultE) {\n                        return promiseRejectedWith(transformResultE);\n                    }\n                };\n                let flushAlgorithm = ()=>promiseResolvedWith(undefined);\n                if (transformer.transform !== undefined) {\n                    transformAlgorithm = (chunk)=>transformer.transform(chunk, controller);\n                }\n                if (transformer.flush !== undefined) {\n                    flushAlgorithm = ()=>transformer.flush(controller);\n                }\n                SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n            }\n            function TransformStreamDefaultControllerClearAlgorithms(controller) {\n                controller._transformAlgorithm = undefined;\n                controller._flushAlgorithm = undefined;\n            }\n            function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n                const stream = controller._controlledTransformStream;\n                const readableController = stream._readable._readableStreamController;\n                if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n                    throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n                }\n                // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n                // accept TransformStreamDefaultControllerEnqueue() calls.\n                try {\n                    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n                } catch (e) {\n                    // This happens when readableStrategy.size() throws.\n                    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n                    throw stream._readable._storedError;\n                }\n                const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n                if (backpressure !== stream._backpressure) {\n                    TransformStreamSetBackpressure(stream, true);\n                }\n            }\n            function TransformStreamDefaultControllerError(controller, e) {\n                TransformStreamError(controller._controlledTransformStream, e);\n            }\n            function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n                const transformPromise = controller._transformAlgorithm(chunk);\n                return transformPromiseWith(transformPromise, undefined, (r)=>{\n                    TransformStreamError(controller._controlledTransformStream, r);\n                    throw r;\n                });\n            }\n            function TransformStreamDefaultControllerTerminate(controller) {\n                const stream = controller._controlledTransformStream;\n                const readableController = stream._readable._readableStreamController;\n                ReadableStreamDefaultControllerClose(readableController);\n                const error = new TypeError(\"TransformStream terminated\");\n                TransformStreamErrorWritableAndUnblockWrite(stream, error);\n            }\n            // TransformStreamDefaultSink Algorithms\n            function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n                const controller = stream._transformStreamController;\n                if (stream._backpressure) {\n                    const backpressureChangePromise = stream._backpressureChangePromise;\n                    return transformPromiseWith(backpressureChangePromise, ()=>{\n                        const writable = stream._writable;\n                        const state = writable._state;\n                        if (state === \"erroring\") {\n                            throw writable._storedError;\n                        }\n                        return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n                    });\n                }\n                return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n            }\n            function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n                // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n                // errored.\n                TransformStreamError(stream, reason);\n                return promiseResolvedWith(undefined);\n            }\n            function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n                // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n                const readable = stream._readable;\n                const controller = stream._transformStreamController;\n                const flushPromise = controller._flushAlgorithm();\n                TransformStreamDefaultControllerClearAlgorithms(controller);\n                // Return a promise that is fulfilled with undefined on success.\n                return transformPromiseWith(flushPromise, ()=>{\n                    if (readable._state === \"errored\") {\n                        throw readable._storedError;\n                    }\n                    ReadableStreamDefaultControllerClose(readable._readableStreamController);\n                }, (r)=>{\n                    TransformStreamError(stream, r);\n                    throw readable._storedError;\n                });\n            }\n            // TransformStreamDefaultSource Algorithms\n            function TransformStreamDefaultSourcePullAlgorithm(stream) {\n                // Invariant. Enforced by the promises returned by start() and pull().\n                TransformStreamSetBackpressure(stream, false);\n                // Prevent the next pull() call until there is backpressure.\n                return stream._backpressureChangePromise;\n            }\n            // Helper functions for the TransformStreamDefaultController.\n            function defaultControllerBrandCheckException(name) {\n                return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n            }\n            // Helper functions for the TransformStream.\n            function streamBrandCheckException(name) {\n                return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n            }\n            exports1.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n            exports1.CountQueuingStrategy = CountQueuingStrategy;\n            exports1.ReadableByteStreamController = ReadableByteStreamController;\n            exports1.ReadableStream = ReadableStream1;\n            exports1.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n            exports1.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n            exports1.ReadableStreamDefaultController = ReadableStreamDefaultController;\n            exports1.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n            exports1.TransformStream = TransformStream;\n            exports1.TransformStreamDefaultController = TransformStreamDefaultController;\n            exports1.WritableStream = WritableStream;\n            exports1.WritableStreamDefaultController = WritableStreamDefaultController;\n            exports1.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        });\n    })(ponyfill_es2018, ponyfill_es2018.exports);\n    return ponyfill_es2018.exports;\n}\n/* c8 ignore start */ // 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE$1 = 65536;\nif (!globalThis.ReadableStream) {\n    // `node:stream/web` got introduced in v16.5.0 as experimental\n    // and it's preferred over the polyfilled version. So we also\n    // suppress the warning that gets emitted by NodeJS for using it.\n    try {\n        const process1 = __webpack_require__(/*! node:process */ \"node:process\");\n        const { emitWarning } = process1;\n        try {\n            process1.emitWarning = ()=>{};\n            Object.assign(globalThis, __webpack_require__(/*! node:stream/web */ \"node:stream/web\"));\n            process1.emitWarning = emitWarning;\n        } catch (error) {\n            process1.emitWarning = emitWarning;\n            throw error;\n        }\n    } catch (error) {\n        // fallback to polyfill implementation\n        Object.assign(globalThis, requirePonyfill_es2018());\n    }\n}\ntry {\n    // Don't use node: prefix for this, require+node: is not supported until node v14.14\n    // Only `import()` can use prefix in 12.20 and later\n    const { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\n    if (Blob && !Blob.prototype.stream) {\n        Blob.prototype.stream = function name(params) {\n            let position = 0;\n            const blob = this;\n            return new ReadableStream({\n                type: \"bytes\",\n                async pull (ctrl) {\n                    const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));\n                    const buffer = await chunk.arrayBuffer();\n                    position += buffer.byteLength;\n                    ctrl.enqueue(new Uint8Array(buffer));\n                    if (position === blob.size) {\n                        ctrl.close();\n                    }\n                }\n            });\n        };\n    }\n} catch (error) {}\n/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */ // 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536;\n/** @param {(Blob | Uint8Array)[]} parts */ async function* toIterator(parts, clone = true) {\n    for (const part of parts){\n        if (\"stream\" in part) {\n            yield* /** @type {AsyncIterableIterator<Uint8Array>} */ part.stream();\n        } else if (ArrayBuffer.isView(part)) {\n            if (clone) {\n                let position = part.byteOffset;\n                const end = part.byteOffset + part.byteLength;\n                while(position !== end){\n                    const size = Math.min(end - position, POOL_SIZE);\n                    const chunk = part.buffer.slice(position, position + size);\n                    position += chunk.byteLength;\n                    yield new Uint8Array(chunk);\n                }\n            } else {\n                yield part;\n            }\n        /* c8 ignore next 10 */ } else {\n            // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n            let position = 0, b = /** @type {Blob} */ part;\n            while(position !== b.size){\n                const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));\n                const buffer = await chunk.arrayBuffer();\n                position += buffer.byteLength;\n                yield new Uint8Array(buffer);\n            }\n        }\n    }\n}\nconst _Blob = class Blob {\n    /** @type {Array.<(Blob|Uint8Array)>} */ #parts;\n    #type;\n    #size;\n    #endings;\n    /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */ constructor(blobParts = [], options = {}){\n        this.#parts = [];\n        this.#type = \"\";\n        this.#size = 0;\n        this.#endings = \"transparent\";\n        if (typeof blobParts !== \"object\" || blobParts === null) {\n            throw new TypeError(\"Failed to construct 'Blob': The provided value cannot be converted to a sequence.\");\n        }\n        if (typeof blobParts[Symbol.iterator] !== \"function\") {\n            throw new TypeError(\"Failed to construct 'Blob': The object must have a callable @@iterator property.\");\n        }\n        if (typeof options !== \"object\" && typeof options !== \"function\") {\n            throw new TypeError(\"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\");\n        }\n        if (options === null) options = {};\n        const encoder = new TextEncoder();\n        for (const element of blobParts){\n            let part;\n            if (ArrayBuffer.isView(element)) {\n                part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n            } else if (element instanceof ArrayBuffer) {\n                part = new Uint8Array(element.slice(0));\n            } else if (element instanceof Blob) {\n                part = element;\n            } else {\n                part = encoder.encode(`${element}`);\n            }\n            const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n            // Avoid pushing empty parts into the array to better GC them\n            if (size) {\n                this.#size += size;\n                this.#parts.push(part);\n            }\n        }\n        this.#endings = `${options.endings === undefined ? \"transparent\" : options.endings}`;\n        const type = options.type === undefined ? \"\" : String(options.type);\n        this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : \"\";\n    }\n    /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */ get size() {\n        return this.#size;\n    }\n    /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */ get type() {\n        return this.#type;\n    }\n    /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */ async text() {\n        // More optimized than using this.arrayBuffer()\n        // that requires twice as much ram\n        const decoder = new TextDecoder();\n        let str = \"\";\n        for await (const part of toIterator(this.#parts, false)){\n            str += decoder.decode(part, {\n                stream: true\n            });\n        }\n        // Remaining\n        str += decoder.decode();\n        return str;\n    }\n    /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */ async arrayBuffer() {\n        // Easier way... Just a unnecessary overhead\n        // const view = new Uint8Array(this.size);\n        // await this.stream().getReader({mode: 'byob'}).read(view);\n        // return view.buffer;\n        const data = new Uint8Array(this.size);\n        let offset = 0;\n        for await (const chunk of toIterator(this.#parts, false)){\n            data.set(chunk, offset);\n            offset += chunk.length;\n        }\n        return data.buffer;\n    }\n    stream() {\n        const it = toIterator(this.#parts, true);\n        return new globalThis.ReadableStream({\n            // @ts-ignore\n            type: \"bytes\",\n            async pull (ctrl) {\n                const chunk = await it.next();\n                chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n            },\n            async cancel () {\n                await it.return();\n            }\n        });\n    }\n    /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */ slice(start = 0, end = this.size, type = \"\") {\n        const { size } = this;\n        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n        const span = Math.max(relativeEnd - relativeStart, 0);\n        const parts = this.#parts;\n        const blobParts = [];\n        let added = 0;\n        for (const part of parts){\n            // don't add the overflow to new blobParts\n            if (added >= span) {\n                break;\n            }\n            const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n            if (relativeStart && size <= relativeStart) {\n                // Skip the beginning and change the relative\n                // start & end position as we skip the unwanted parts\n                relativeStart -= size;\n                relativeEnd -= size;\n            } else {\n                let chunk;\n                if (ArrayBuffer.isView(part)) {\n                    chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));\n                    added += chunk.byteLength;\n                } else {\n                    chunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n                    added += chunk.size;\n                }\n                relativeEnd -= size;\n                blobParts.push(chunk);\n                relativeStart = 0; // All next sequential parts should start at 0\n            }\n        }\n        const blob = new Blob([], {\n            type: String(type).toLowerCase()\n        });\n        blob.#size = span;\n        blob.#parts = blobParts;\n        return blob;\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n    static [Symbol.hasInstance](object) {\n        return object && typeof object === \"object\" && typeof object.constructor === \"function\" && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n    }\n};\nObject.defineProperties(_Blob.prototype, {\n    size: {\n        enumerable: true\n    },\n    type: {\n        enumerable: true\n    },\n    slice: {\n        enumerable: true\n    }\n});\n/** @type {typeof globalThis.Blob} */ const Blob = _Blob;\nconst _Blob$1 = Blob;\nconst _File = class File extends _Blob$1 {\n    #lastModified;\n    #name;\n    /**\n   * @param {*[]} fileBits\n   * @param {string} fileName\n   * @param {{lastModified?: number, type?: string}} options\n   */ // @ts-ignore\n    constructor(fileBits, fileName, options = {}){\n        if (arguments.length < 2) {\n            throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);\n        }\n        super(fileBits, options);\n        this.#lastModified = 0;\n        this.#name = \"\";\n        if (options === null) options = {};\n        // Simulate WebIDL type casting for NaN value in lastModified option.\n        const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified);\n        if (!Number.isNaN(lastModified)) {\n            this.#lastModified = lastModified;\n        }\n        this.#name = String(fileName);\n    }\n    get name() {\n        return this.#name;\n    }\n    get lastModified() {\n        return this.#lastModified;\n    }\n    get [Symbol.toStringTag]() {\n        return \"File\";\n    }\n    static [Symbol.hasInstance](object) {\n        return !!object && object instanceof _Blob$1 && /^(File)$/.test(object[Symbol.toStringTag]);\n    }\n};\n/** @type {typeof globalThis.File} */ // @ts-ignore\nconst File = _File;\nconst File$1 = File;\n/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */ var { toStringTag: t, iterator: i, hasInstance: h } = Symbol, r = Math.random, m = \"append,set,get,getAll,delete,keys,values,entries,forEach,constructor\".split(\",\"), f = (a, b, c)=>(a += \"\", /^(Blob|File)$/.test(b && b[t]) ? [\n        (c = c !== void 0 ? c + \"\" : b[t] == \"File\" ? b.name : \"blob\", a),\n        b.name !== c || b[t] == \"blob\" ? new File$1([\n            b\n        ], c, b) : b\n    ] : [\n        a,\n        b + \"\"\n    ]), e = (c, f)=>(f ? c : c.replace(/\\r?\\n|\\r/g, \"\\r\\n\")).replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\"), x = (n, a, e)=>{\n    if (a.length < e) {\n        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`);\n    }\n};\n/** @type {typeof globalThis.FormData} */ const FormData = class FormData {\n    #d;\n    constructor(...a){\n        this.#d = [];\n        if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);\n    }\n    get [t]() {\n        return \"FormData\";\n    }\n    [i]() {\n        return this.entries();\n    }\n    static [h](o) {\n        return o && typeof o === \"object\" && o[t] === \"FormData\" && !m.some((m)=>typeof o[m] != \"function\");\n    }\n    append(...a) {\n        x(\"append\", arguments, 2);\n        this.#d.push(f(...a));\n    }\n    delete(a) {\n        x(\"delete\", arguments, 1);\n        a += \"\";\n        this.#d = this.#d.filter(([b])=>b !== a);\n    }\n    get(a) {\n        x(\"get\", arguments, 1);\n        a += \"\";\n        for(var b = this.#d, l = b.length, c = 0; c < l; c++)if (b[c][0] === a) return b[c][1];\n        return null;\n    }\n    getAll(a, b) {\n        x(\"getAll\", arguments, 1);\n        b = [];\n        a += \"\";\n        this.#d.forEach((c)=>c[0] === a && b.push(c[1]));\n        return b;\n    }\n    has(a) {\n        x(\"has\", arguments, 1);\n        a += \"\";\n        return this.#d.some((b)=>b[0] === a);\n    }\n    forEach(a, b) {\n        x(\"forEach\", arguments, 1);\n        for (var [c, d] of this)a.call(b, d, c, this);\n    }\n    set(...a) {\n        x(\"set\", arguments, 2);\n        var b = [], c = !0;\n        a = f(...a);\n        this.#d.forEach((d)=>{\n            d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);\n        });\n        c && b.push(a);\n        this.#d = b;\n    }\n    *entries() {\n        yield* this.#d;\n    }\n    *keys() {\n        for (var [a] of this)yield a;\n    }\n    *values() {\n        for (var [, a] of this)yield a;\n    }\n};\n/** @param {FormData} F */ function formDataToBlob(F, B = _Blob$1) {\n    var b = `${r()}${r()}`.replace(/\\./g, \"\").slice(-28).padStart(32, \"-\"), c = [], p = `--${b}\\r\\nContent-Disposition: form-data; name=\"`;\n    F.forEach((v, n)=>typeof v == \"string\" ? c.push(p + e(n) + `\"\\r\\n\\r\\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, \"\\r\\n\")}\\r\\n`) : c.push(p + e(n) + `\"; filename=\"${e(v.name, 1)}\"\\r\\nContent-Type: ${v.type || \"application/octet-stream\"}\\r\\n\\r\\n`, v, \"\\r\\n\"));\n    c.push(`--${b}--`);\n    return new B(c, {\n        type: \"multipart/form-data; boundary=\" + b\n    });\n}\nclass FetchBaseError extends Error {\n    constructor(message, type){\n        super(message);\n        // Hide custom error implementation details from end-users\n        Error.captureStackTrace(this, this.constructor);\n        this.type = type;\n    }\n    get name() {\n        return this.constructor.name;\n    }\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n}\n/**\n * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError\n*/ /**\n * FetchError interface for operational errors\n */ class FetchError extends FetchBaseError {\n    /**\n\t * @param  {string} message -      Error message for human\n\t * @param  {string} [type] -        Error type for machine\n\t * @param  {SystemError} [systemError] - For Node.js system error\n\t */ constructor(message, type, systemError){\n        super(message, type);\n        // When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code\n        if (systemError) {\n            // eslint-disable-next-line no-multi-assign\n            this.code = this.errno = systemError.code;\n            this.erroredSysCall = systemError.syscall;\n        }\n    }\n}\n/**\n * Is.js\n *\n * Object type checks.\n */ const NAME = Symbol.toStringTag;\n/**\n * Check if `obj` is a URLSearchParams object\n * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143\n * @param {*} object - Object to check for\n * @return {boolean}\n */ const isURLSearchParameters = (object)=>{\n    return typeof object === \"object\" && typeof object.append === \"function\" && typeof object.delete === \"function\" && typeof object.get === \"function\" && typeof object.getAll === \"function\" && typeof object.has === \"function\" && typeof object.set === \"function\" && typeof object.sort === \"function\" && object[NAME] === \"URLSearchParams\";\n};\n/**\n * Check if `object` is a W3C `Blob` object (which `File` inherits from)\n * @param {*} object - Object to check for\n * @return {boolean}\n */ const isBlob = (object)=>{\n    return object && typeof object === \"object\" && typeof object.arrayBuffer === \"function\" && typeof object.type === \"string\" && typeof object.stream === \"function\" && typeof object.constructor === \"function\" && /^(Blob|File)$/.test(object[NAME]);\n};\n/**\n * Check if `obj` is an instance of AbortSignal.\n * @param {*} object - Object to check for\n * @return {boolean}\n */ const isAbortSignal = (object)=>{\n    return typeof object === \"object\" && (object[NAME] === \"AbortSignal\" || object[NAME] === \"EventTarget\");\n};\n/**\n * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of\n * the parent domain.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */ const isDomainOrSubdomain = (destination, original)=>{\n    const orig = new URL(original).hostname;\n    const dest = new URL(destination).hostname;\n    return orig === dest || orig.endsWith(`.${dest}`);\n};\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */ const isSameProtocol = (destination, original)=>{\n    const orig = new URL(original).protocol;\n    const dest = new URL(destination).protocol;\n    return orig === dest;\n};\nconst pipeline = node_util.promisify(Stream.pipeline);\nconst INTERNALS$2 = Symbol(\"Body internals\");\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ class Body {\n    constructor(body, { size = 0 } = {}){\n        let boundary = null;\n        if (body === null) {\n            // Body is undefined or null\n            body = null;\n        } else if (isURLSearchParameters(body)) {\n            // Body is a URLSearchParams\n            body = node_buffer.Buffer.from(body.toString());\n        } else if (isBlob(body)) ;\n        else if (node_buffer.Buffer.isBuffer(body)) ;\n        else if (node_util.types.isAnyArrayBuffer(body)) {\n            // Body is ArrayBuffer\n            body = node_buffer.Buffer.from(body);\n        } else if (ArrayBuffer.isView(body)) {\n            // Body is ArrayBufferView\n            body = node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n        } else if (body instanceof Stream) ;\n        else if (body instanceof FormData) {\n            // Body is FormData\n            body = formDataToBlob(body);\n            boundary = body.type.split(\"=\")[1];\n        } else {\n            // None of the above\n            // coerce to string then buffer\n            body = node_buffer.Buffer.from(String(body));\n        }\n        let stream = body;\n        if (node_buffer.Buffer.isBuffer(body)) {\n            stream = Stream.Readable.from(body);\n        } else if (isBlob(body)) {\n            stream = Stream.Readable.from(body.stream());\n        }\n        this[INTERNALS$2] = {\n            body,\n            stream,\n            boundary,\n            disturbed: false,\n            error: null\n        };\n        this.size = size;\n        if (body instanceof Stream) {\n            body.on(\"error\", (error_)=>{\n                const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, \"system\", error_);\n                this[INTERNALS$2].error = error;\n            });\n        }\n    }\n    get body() {\n        return this[INTERNALS$2].stream;\n    }\n    get bodyUsed() {\n        return this[INTERNALS$2].disturbed;\n    }\n    /**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */ async arrayBuffer() {\n        const { buffer, byteOffset, byteLength } = await consumeBody(this);\n        return buffer.slice(byteOffset, byteOffset + byteLength);\n    }\n    async formData() {\n        const ct = this.headers.get(\"content-type\");\n        if (ct.startsWith(\"application/x-www-form-urlencoded\")) {\n            const formData = new FormData();\n            const parameters = new URLSearchParams(await this.text());\n            for (const [name, value1] of parameters){\n                formData.append(name, value1);\n            }\n            return formData;\n        }\n        const { toFormData } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../chunks/multipart-parser.cjs */ \"(rsc)/./node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs\")));\n        return toFormData(this.body, ct);\n    }\n    /**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */ async blob() {\n        const ct = this.headers && this.headers.get(\"content-type\") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || \"\";\n        const buf = await this.arrayBuffer();\n        return new _Blob$1([\n            buf\n        ], {\n            type: ct\n        });\n    }\n    /**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */ async json() {\n        const text = await this.text();\n        return JSON.parse(text);\n    }\n    /**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */ async text() {\n        const buffer = await consumeBody(this);\n        return new TextDecoder().decode(buffer);\n    }\n    /**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */ buffer() {\n        return consumeBody(this);\n    }\n}\nBody.prototype.buffer = node_util.deprecate(Body.prototype.buffer, \"Please use 'response.arrayBuffer()' instead of 'response.buffer()'\", \"node-fetch#buffer\");\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n    body: {\n        enumerable: true\n    },\n    bodyUsed: {\n        enumerable: true\n    },\n    arrayBuffer: {\n        enumerable: true\n    },\n    blob: {\n        enumerable: true\n    },\n    json: {\n        enumerable: true\n    },\n    text: {\n        enumerable: true\n    },\n    data: {\n        get: node_util.deprecate(()=>{}, \"data doesn't exist, use json(), text(), arrayBuffer(), or body instead\", \"https://github.com/node-fetch/node-fetch/issues/1000 (response)\")\n    }\n});\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */ async function consumeBody(data) {\n    if (data[INTERNALS$2].disturbed) {\n        throw new TypeError(`body used already for: ${data.url}`);\n    }\n    data[INTERNALS$2].disturbed = true;\n    if (data[INTERNALS$2].error) {\n        throw data[INTERNALS$2].error;\n    }\n    const { body } = data;\n    // Body is null\n    if (body === null) {\n        return node_buffer.Buffer.alloc(0);\n    }\n    /* c8 ignore next 3 */ if (!(body instanceof Stream)) {\n        return node_buffer.Buffer.alloc(0);\n    }\n    // Body is stream\n    // get ready to actually consume the body\n    const accum = [];\n    let accumBytes = 0;\n    try {\n        for await (const chunk of body){\n            if (data.size > 0 && accumBytes + chunk.length > data.size) {\n                const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, \"max-size\");\n                body.destroy(error);\n                throw error;\n            }\n            accumBytes += chunk.length;\n            accum.push(chunk);\n        }\n    } catch (error) {\n        const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, \"system\", error);\n        throw error_;\n    }\n    if (body.readableEnded === true || body._readableState.ended === true) {\n        try {\n            if (accum.every((c)=>typeof c === \"string\")) {\n                return node_buffer.Buffer.from(accum.join(\"\"));\n            }\n            return node_buffer.Buffer.concat(accum, accumBytes);\n        } catch (error) {\n            throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, \"system\", error);\n        }\n    } else {\n        throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n    }\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */ const clone = (instance, highWaterMark)=>{\n    let p1;\n    let p2;\n    let { body } = instance[INTERNALS$2];\n    // Don't allow cloning a used body\n    if (instance.bodyUsed) {\n        throw new Error(\"cannot clone body after it is used\");\n    }\n    // Check that body is a stream and not form-data object\n    // note: we can't clone the form-data object without having it as a dependency\n    if (body instanceof Stream && typeof body.getBoundary !== \"function\") {\n        // Tee instance body\n        p1 = new Stream.PassThrough({\n            highWaterMark\n        });\n        p2 = new Stream.PassThrough({\n            highWaterMark\n        });\n        body.pipe(p1);\n        body.pipe(p2);\n        // Set instance body to teed body and return the other teed body\n        instance[INTERNALS$2].stream = p1;\n        body = p2;\n    }\n    return body;\n};\nconst getNonSpecFormDataBoundary = node_util.deprecate((body)=>body.getBoundary(), \"form-data doesn't follow the spec and requires special treatment. Use alternative package\", \"https://github.com/node-fetch/node-fetch/issues/1167\");\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */ const extractContentType = (body, request)=>{\n    // Body is null or undefined\n    if (body === null) {\n        return null;\n    }\n    // Body is string\n    if (typeof body === \"string\") {\n        return \"text/plain;charset=UTF-8\";\n    }\n    // Body is a URLSearchParams\n    if (isURLSearchParameters(body)) {\n        return \"application/x-www-form-urlencoded;charset=UTF-8\";\n    }\n    // Body is blob\n    if (isBlob(body)) {\n        return body.type || null;\n    }\n    // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n    if (node_buffer.Buffer.isBuffer(body) || node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n        return null;\n    }\n    if (body instanceof FormData) {\n        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;\n    }\n    // Detect form data input from form-data module\n    if (body && typeof body.getBoundary === \"function\") {\n        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n    }\n    // Body is stream - can't really do much about this\n    if (body instanceof Stream) {\n        return null;\n    }\n    // Body constructor defaults other things to string\n    return \"text/plain;charset=UTF-8\";\n};\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */ const getTotalBytes = (request)=>{\n    const { body } = request[INTERNALS$2];\n    // Body is null or undefined\n    if (body === null) {\n        return 0;\n    }\n    // Body is Blob\n    if (isBlob(body)) {\n        return body.size;\n    }\n    // Body is Buffer\n    if (node_buffer.Buffer.isBuffer(body)) {\n        return body.length;\n    }\n    // Detect form data input from form-data module\n    if (body && typeof body.getLengthSync === \"function\") {\n        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n    }\n    // Body is stream\n    return null;\n};\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */ const writeToStream = async (dest, { body })=>{\n    if (body === null) {\n        // Body is null\n        dest.end();\n    } else {\n        // Body is stream\n        await pipeline(body, dest);\n    }\n};\n/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */ /* c8 ignore next 9 */ const validateHeaderName = typeof http.validateHeaderName === \"function\" ? http.validateHeaderName : (name)=>{\n    if (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n        const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n        Object.defineProperty(error, \"code\", {\n            value: \"ERR_INVALID_HTTP_TOKEN\"\n        });\n        throw error;\n    }\n};\n/* c8 ignore next 9 */ const validateHeaderValue = typeof http.validateHeaderValue === \"function\" ? http.validateHeaderValue : (name, value1)=>{\n    if (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value1)) {\n        const error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n        Object.defineProperty(error, \"code\", {\n            value: \"ERR_INVALID_CHAR\"\n        });\n        throw error;\n    }\n};\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */ /**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */ class Headers extends URLSearchParams {\n    /**\n\t * Headers class\n\t *\n\t * @constructor\n\t * @param {HeadersInit} [init] - Response headers\n\t */ constructor(init){\n        // Validate and normalize init object in [name, value(s)][]\n        /** @type {string[][]} */ let result = [];\n        if (init instanceof Headers) {\n            const raw = init.raw();\n            for (const [name, values] of Object.entries(raw)){\n                result.push(...values.map((value1)=>[\n                        name,\n                        value1\n                    ]));\n            }\n        } else if (init == null) ;\n        else if (typeof init === \"object\" && !node_util.types.isBoxedPrimitive(init)) {\n            const method = init[Symbol.iterator];\n            // eslint-disable-next-line no-eq-null, eqeqeq\n            if (method == null) {\n                // Record<ByteString, ByteString>\n                result.push(...Object.entries(init));\n            } else {\n                if (typeof method !== \"function\") {\n                    throw new TypeError(\"Header pairs must be iterable\");\n                }\n                // Sequence<sequence<ByteString>>\n                // Note: per spec we have to first exhaust the lists then process them\n                result = [\n                    ...init\n                ].map((pair)=>{\n                    if (typeof pair !== \"object\" || node_util.types.isBoxedPrimitive(pair)) {\n                        throw new TypeError(\"Each header pair must be an iterable object\");\n                    }\n                    return [\n                        ...pair\n                    ];\n                }).map((pair)=>{\n                    if (pair.length !== 2) {\n                        throw new TypeError(\"Each header pair must be a name/value tuple\");\n                    }\n                    return [\n                        ...pair\n                    ];\n                });\n            }\n        } else {\n            throw new TypeError(\"Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)\");\n        }\n        // Validate and lowercase\n        result = result.length > 0 ? result.map(([name, value1])=>{\n            validateHeaderName(name);\n            validateHeaderValue(name, String(value1));\n            return [\n                String(name).toLowerCase(),\n                String(value1)\n            ];\n        }) : undefined;\n        super(result);\n        // Returning a Proxy that will lowercase key names, validate parameters and sort keys\n        // eslint-disable-next-line no-constructor-return\n        return new Proxy(this, {\n            get (target, p, receiver) {\n                switch(p){\n                    case \"append\":\n                    case \"set\":\n                        return (name, value1)=>{\n                            validateHeaderName(name);\n                            validateHeaderValue(name, String(value1));\n                            return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value1));\n                        };\n                    case \"delete\":\n                    case \"has\":\n                    case \"getAll\":\n                        return (name)=>{\n                            validateHeaderName(name);\n                            return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());\n                        };\n                    case \"keys\":\n                        return ()=>{\n                            target.sort();\n                            return new Set(URLSearchParams.prototype.keys.call(target)).keys();\n                        };\n                    default:\n                        return Reflect.get(target, p, receiver);\n                }\n            }\n        });\n    /* c8 ignore next */ }\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n    toString() {\n        return Object.prototype.toString.call(this);\n    }\n    get(name) {\n        const values = this.getAll(name);\n        if (values.length === 0) {\n            return null;\n        }\n        let value1 = values.join(\", \");\n        if (/^content-encoding$/i.test(name)) {\n            value1 = value1.toLowerCase();\n        }\n        return value1;\n    }\n    forEach(callback, thisArg = undefined) {\n        for (const name of this.keys()){\n            Reflect.apply(callback, thisArg, [\n                this.get(name),\n                name,\n                this\n            ]);\n        }\n    }\n    *values() {\n        for (const name of this.keys()){\n            yield this.get(name);\n        }\n    }\n    /**\n\t * @type {() => IterableIterator<[string, string]>}\n\t */ *entries() {\n        for (const name of this.keys()){\n            yield [\n                name,\n                this.get(name)\n            ];\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n\t * Node-fetch non-spec method\n\t * returning all headers and their values as array\n\t * @returns {Record<string, string[]>}\n\t */ raw() {\n        return [\n            ...this.keys()\n        ].reduce((result, key)=>{\n            result[key] = this.getAll(key);\n            return result;\n        }, {});\n    }\n    /**\n\t * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n\t */ [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return [\n            ...this.keys()\n        ].reduce((result, key)=>{\n            const values = this.getAll(key);\n            // Http.request() only supports string as Host header.\n            // This hack makes specifying custom Host header possible.\n            if (key === \"host\") {\n                result[key] = values[0];\n            } else {\n                result[key] = values.length > 1 ? values : values[0];\n            }\n            return result;\n        }, {});\n    }\n}\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */ Object.defineProperties(Headers.prototype, [\n    \"get\",\n    \"entries\",\n    \"forEach\",\n    \"values\"\n].reduce((result, property)=>{\n    result[property] = {\n        enumerable: true\n    };\n    return result;\n}, {}));\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */ function fromRawHeaders(headers = []) {\n    return new Headers(headers// Split into pairs\n    .reduce((result, value1, index, array)=>{\n        if (index % 2 === 0) {\n            result.push(array.slice(index, index + 2));\n        }\n        return result;\n    }, []).filter(([name, value1])=>{\n        try {\n            validateHeaderName(name);\n            validateHeaderValue(name, String(value1));\n            return true;\n        } catch  {\n            return false;\n        }\n    }));\n}\nconst redirectStatus = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\n/**\n * Redirect code matching\n *\n * @param {number} code - Status code\n * @return {boolean}\n */ const isRedirect = (code)=>{\n    return redirectStatus.has(code);\n};\n/**\n * Response.js\n *\n * Response class provides content decoding\n */ const INTERNALS$1 = Symbol(\"Response internals\");\n/**\n * Response class\n *\n * Ref: https://fetch.spec.whatwg.org/#response-class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ class Response extends Body {\n    constructor(body = null, options = {}){\n        super(body, options);\n        // eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition\n        const status = options.status != null ? options.status : 200;\n        const headers = new Headers(options.headers);\n        if (body !== null && !headers.has(\"Content-Type\")) {\n            const contentType = extractContentType(body, this);\n            if (contentType) {\n                headers.append(\"Content-Type\", contentType);\n            }\n        }\n        this[INTERNALS$1] = {\n            type: \"default\",\n            url: options.url,\n            status,\n            statusText: options.statusText || \"\",\n            headers,\n            counter: options.counter,\n            highWaterMark: options.highWaterMark\n        };\n    }\n    get type() {\n        return this[INTERNALS$1].type;\n    }\n    get url() {\n        return this[INTERNALS$1].url || \"\";\n    }\n    get status() {\n        return this[INTERNALS$1].status;\n    }\n    /**\n\t * Convenience property representing if the request ended normally\n\t */ get ok() {\n        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n    }\n    get redirected() {\n        return this[INTERNALS$1].counter > 0;\n    }\n    get statusText() {\n        return this[INTERNALS$1].statusText;\n    }\n    get headers() {\n        return this[INTERNALS$1].headers;\n    }\n    get highWaterMark() {\n        return this[INTERNALS$1].highWaterMark;\n    }\n    /**\n\t * Clone this response\n\t *\n\t * @return  Response\n\t */ clone() {\n        return new Response(clone(this, this.highWaterMark), {\n            type: this.type,\n            url: this.url,\n            status: this.status,\n            statusText: this.statusText,\n            headers: this.headers,\n            ok: this.ok,\n            redirected: this.redirected,\n            size: this.size,\n            highWaterMark: this.highWaterMark\n        });\n    }\n    /**\n\t * @param {string} url    The URL that the new response is to originate from.\n\t * @param {number} status An optional status code for the response (e.g., 302.)\n\t * @returns {Response}    A Response object.\n\t */ static redirect(url, status = 302) {\n        if (!isRedirect(status)) {\n            throw new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n        }\n        return new Response(null, {\n            headers: {\n                location: new URL(url).toString()\n            },\n            status\n        });\n    }\n    static error() {\n        const response = new Response(null, {\n            status: 0,\n            statusText: \"\"\n        });\n        response[INTERNALS$1].type = \"error\";\n        return response;\n    }\n    static json(data = undefined, init = {}) {\n        const body = JSON.stringify(data);\n        if (body === undefined) {\n            throw new TypeError(\"data is not JSON serializable\");\n        }\n        const headers = new Headers(init && init.headers);\n        if (!headers.has(\"content-type\")) {\n            headers.set(\"content-type\", \"application/json\");\n        }\n        return new Response(body, {\n            ...init,\n            headers\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Response\";\n    }\n}\nObject.defineProperties(Response.prototype, {\n    type: {\n        enumerable: true\n    },\n    url: {\n        enumerable: true\n    },\n    status: {\n        enumerable: true\n    },\n    ok: {\n        enumerable: true\n    },\n    redirected: {\n        enumerable: true\n    },\n    statusText: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    }\n});\nconst getSearch = (parsedURL)=>{\n    if (parsedURL.search) {\n        return parsedURL.search;\n    }\n    const lastOffset = parsedURL.href.length - 1;\n    const hash = parsedURL.hash || (parsedURL.href[lastOffset] === \"#\" ? \"#\" : \"\");\n    return parsedURL.href[lastOffset - hash.length] === \"?\" ? \"?\" : \"\";\n};\n/**\n * @external URL\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}\n */ /**\n * @module utils/referrer\n * @private\n */ /**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy 8.4. Strip url for use as a referrer}\n * @param {string} URL\n * @param {boolean} [originOnly=false]\n */ function stripURLForUseAsAReferrer(url, originOnly = false) {\n    // 1. If url is null, return no referrer.\n    if (url == null) {\n        return \"no-referrer\";\n    }\n    url = new URL(url);\n    // 2. If url's scheme is a local scheme, then return no referrer.\n    if (/^(about|blob|data):$/.test(url.protocol)) {\n        return \"no-referrer\";\n    }\n    // 3. Set url's username to the empty string.\n    url.username = \"\";\n    // 4. Set url's password to null.\n    // Note: `null` appears to be a mistake as this actually results in the password being `\"null\"`.\n    url.password = \"\";\n    // 5. Set url's fragment to null.\n    // Note: `null` appears to be a mistake as this actually results in the fragment being `\"#null\"`.\n    url.hash = \"\";\n    // 6. If the origin-only flag is true, then:\n    if (originOnly) {\n        // 6.1. Set url's path to null.\n        // Note: `null` appears to be a mistake as this actually results in the path being `\"/null\"`.\n        url.pathname = \"\";\n        // 6.2. Set url's query to null.\n        // Note: `null` appears to be a mistake as this actually results in the query being `\"?null\"`.\n        url.search = \"\";\n    }\n    // 7. Return url.\n    return url;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}\n */ const ReferrerPolicy = new Set([\n    \"\",\n    \"no-referrer\",\n    \"no-referrer-when-downgrade\",\n    \"same-origin\",\n    \"origin\",\n    \"strict-origin\",\n    \"origin-when-cross-origin\",\n    \"strict-origin-when-cross-origin\",\n    \"unsafe-url\"\n]);\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}\n */ const DEFAULT_REFERRER_POLICY = \"strict-origin-when-cross-origin\";\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy 3. Referrer Policies}\n * @param {string} referrerPolicy\n * @returns {string} referrerPolicy\n */ function validateReferrerPolicy(referrerPolicy) {\n    if (!ReferrerPolicy.has(referrerPolicy)) {\n        throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n    }\n    return referrerPolicy;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy 3.2. Is origin potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */ function isOriginPotentiallyTrustworthy(url) {\n    // 1. If origin is an opaque origin, return \"Not Trustworthy\".\n    // Not applicable\n    // 2. Assert: origin is a tuple origin.\n    // Not for implementations\n    // 3. If origin's scheme is either \"https\" or \"wss\", return \"Potentially Trustworthy\".\n    if (/^(http|ws)s:$/.test(url.protocol)) {\n        return true;\n    }\n    // 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n    const hostIp = url.host.replace(/(^\\[)|(]$)/g, \"\");\n    const hostIPVersion = node_net.isIP(hostIp);\n    if (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n        return true;\n    }\n    if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n        return true;\n    }\n    // 5. If origin's host component is \"localhost\" or falls within \".localhost\", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return \"Potentially Trustworthy\".\n    // We are returning FALSE here because we cannot ensure conformance to\n    // let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)\n    if (url.host === \"localhost\" || url.host.endsWith(\".localhost\")) {\n        return false;\n    }\n    // 6. If origin's scheme component is file, return \"Potentially Trustworthy\".\n    if (url.protocol === \"file:\") {\n        return true;\n    }\n    // 7. If origin's scheme component is one which the user agent considers to be authenticated, return \"Potentially Trustworthy\".\n    // Not supported\n    // 8. If origin has been configured as a trustworthy origin, return \"Potentially Trustworthy\".\n    // Not supported\n    // 9. Return \"Not Trustworthy\".\n    return false;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy 3.3. Is url potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */ function isUrlPotentiallyTrustworthy(url) {\n    // 1. If url is \"about:blank\" or \"about:srcdoc\", return \"Potentially Trustworthy\".\n    if (/^about:(blank|srcdoc)$/.test(url)) {\n        return true;\n    }\n    // 2. If url's scheme is \"data\", return \"Potentially Trustworthy\".\n    if (url.protocol === \"data:\") {\n        return true;\n    }\n    // Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were\n    // created. Therefore, blobs created in a trustworthy origin will themselves be potentially\n    // trustworthy.\n    if (/^(blob|filesystem):$/.test(url.protocol)) {\n        return true;\n    }\n    // 3. Return the result of executing 3.2 Is origin potentially trustworthy? on url's origin.\n    return isOriginPotentiallyTrustworthy(url);\n}\n/**\n * Modifies the referrerURL to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerURLCallback\n * @param {external:URL} referrerURL\n * @returns {external:URL} modified referrerURL\n */ /**\n * Modifies the referrerOrigin to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerOriginCallback\n * @param {external:URL} referrerOrigin\n * @returns {external:URL} modified referrerOrigin\n */ /**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}\n * @param {Request} request\n * @param {object} o\n * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback\n * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback\n * @returns {external:URL} Request's referrer\n */ function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {\n    // There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for\n    // these cases:\n    // > Note: If request's referrer is \"no-referrer\", Fetch will not call into this algorithm.\n    // > Note: If request's referrer policy is the empty string, Fetch will not call into this\n    // > algorithm.\n    if (request.referrer === \"no-referrer\" || request.referrerPolicy === \"\") {\n        return null;\n    }\n    // 1. Let policy be request's associated referrer policy.\n    const policy = request.referrerPolicy;\n    // 2. Let environment be request's client.\n    // not applicable to node.js\n    // 3. Switch on request's referrer:\n    if (request.referrer === \"about:client\") {\n        return \"no-referrer\";\n    }\n    // \"a URL\": Let referrerSource be request's referrer.\n    const referrerSource = request.referrer;\n    // 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.\n    let referrerURL = stripURLForUseAsAReferrer(referrerSource);\n    // 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the\n    //    origin-only flag set to true.\n    let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);\n    // 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set\n    //    referrerURL to referrerOrigin.\n    if (referrerURL.toString().length > 4096) {\n        referrerURL = referrerOrigin;\n    }\n    // 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary\n    //    policy considerations in the interests of minimizing data leakage. For example, the user\n    //    agent could strip the URL down to an origin, modify its host, replace it with an empty\n    //    string, etc.\n    if (referrerURLCallback) {\n        referrerURL = referrerURLCallback(referrerURL);\n    }\n    if (referrerOriginCallback) {\n        referrerOrigin = referrerOriginCallback(referrerOrigin);\n    }\n    // 8.Execute the statements corresponding to the value of policy:\n    const currentURL = new URL(request.url);\n    switch(policy){\n        case \"no-referrer\":\n            return \"no-referrer\";\n        case \"origin\":\n            return referrerOrigin;\n        case \"unsafe-url\":\n            return referrerURL;\n        case \"strict-origin\":\n            // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n            //    potentially trustworthy URL, then return no referrer.\n            if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n                return \"no-referrer\";\n            }\n            // 2. Return referrerOrigin.\n            return referrerOrigin.toString();\n        case \"strict-origin-when-cross-origin\":\n            // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n            //    return referrerURL.\n            if (referrerURL.origin === currentURL.origin) {\n                return referrerURL;\n            }\n            // 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n            //    potentially trustworthy URL, then return no referrer.\n            if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n                return \"no-referrer\";\n            }\n            // 3. Return referrerOrigin.\n            return referrerOrigin;\n        case \"same-origin\":\n            // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n            //    return referrerURL.\n            if (referrerURL.origin === currentURL.origin) {\n                return referrerURL;\n            }\n            // 2. Return no referrer.\n            return \"no-referrer\";\n        case \"origin-when-cross-origin\":\n            // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n            //    return referrerURL.\n            if (referrerURL.origin === currentURL.origin) {\n                return referrerURL;\n            }\n            // Return referrerOrigin.\n            return referrerOrigin;\n        case \"no-referrer-when-downgrade\":\n            // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n            //    potentially trustworthy URL, then return no referrer.\n            if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n                return \"no-referrer\";\n            }\n            // 2. Return referrerURL.\n            return referrerURL;\n        default:\n            throw new TypeError(`Invalid referrerPolicy: ${policy}`);\n    }\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy 8.1. Parse a referrer policy from a Referrer-Policy header}\n * @param {Headers} headers Response headers\n * @returns {string} policy\n */ function parseReferrerPolicyFromHeader(headers) {\n    // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`\n    //    and responses header list.\n    const policyTokens = (headers.get(\"referrer-policy\") || \"\").split(/[,\\s]+/);\n    // 2. Let policy be the empty string.\n    let policy = \"\";\n    // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty\n    //    string, then set policy to token.\n    // Note: This algorithm loops over multiple policy values to allow deployment of new policy\n    // values with fallbacks for older user agents, as described in  11.1 Unknown Policy Values.\n    for (const token of policyTokens){\n        if (token && ReferrerPolicy.has(token)) {\n            policy = token;\n        }\n    }\n    // 4. Return policy.\n    return policy;\n}\n/**\n * Request.js\n *\n * Request class contains server only options\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */ const INTERNALS = Symbol(\"Request internals\");\n/**\n * Check if `obj` is an instance of Request.\n *\n * @param  {*} object\n * @return {boolean}\n */ const isRequest = (object)=>{\n    return typeof object === \"object\" && typeof object[INTERNALS] === \"object\";\n};\nconst doBadDataWarn = node_util.deprecate(()=>{}, \".data is not a valid RequestInit property, use .body instead\", \"https://github.com/node-fetch/node-fetch/issues/1000 (request)\");\n/**\n * Request class\n *\n * Ref: https://fetch.spec.whatwg.org/#request-class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */ class Request extends Body {\n    constructor(input, init = {}){\n        let parsedURL;\n        // Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)\n        if (isRequest(input)) {\n            parsedURL = new URL(input.url);\n        } else {\n            parsedURL = new URL(input);\n            input = {};\n        }\n        if (parsedURL.username !== \"\" || parsedURL.password !== \"\") {\n            throw new TypeError(`${parsedURL} is an url with embedded credentials.`);\n        }\n        let method = init.method || input.method || \"GET\";\n        if (/^(delete|get|head|options|post|put)$/i.test(method)) {\n            method = method.toUpperCase();\n        }\n        if (!isRequest(init) && \"data\" in init) {\n            doBadDataWarn();\n        }\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if ((init.body != null || isRequest(input) && input.body !== null) && (method === \"GET\" || method === \"HEAD\")) {\n            throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n        }\n        const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n        super(inputBody, {\n            size: init.size || input.size || 0\n        });\n        const headers = new Headers(init.headers || input.headers || {});\n        if (inputBody !== null && !headers.has(\"Content-Type\")) {\n            const contentType = extractContentType(inputBody, this);\n            if (contentType) {\n                headers.set(\"Content-Type\", contentType);\n            }\n        }\n        let signal = isRequest(input) ? input.signal : null;\n        if (\"signal\" in init) {\n            signal = init.signal;\n        }\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (signal != null && !isAbortSignal(signal)) {\n            throw new TypeError(\"Expected signal to be an instanceof AbortSignal or EventTarget\");\n        }\n        // 5.4, Request constructor steps, step 15.1\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        let referrer = init.referrer == null ? input.referrer : init.referrer;\n        if (referrer === \"\") {\n            // 5.4, Request constructor steps, step 15.2\n            referrer = \"no-referrer\";\n        } else if (referrer) {\n            // 5.4, Request constructor steps, step 15.3.1, 15.3.2\n            const parsedReferrer = new URL(referrer);\n            // 5.4, Request constructor steps, step 15.3.3, 15.3.4\n            referrer = /^about:(\\/\\/)?client$/.test(parsedReferrer) ? \"client\" : parsedReferrer;\n        } else {\n            referrer = undefined;\n        }\n        this[INTERNALS] = {\n            method,\n            redirect: init.redirect || input.redirect || \"follow\",\n            headers,\n            parsedURL,\n            signal,\n            referrer\n        };\n        // Node-fetch-only options\n        this.follow = init.follow === undefined ? input.follow === undefined ? 20 : input.follow : init.follow;\n        this.compress = init.compress === undefined ? input.compress === undefined ? true : input.compress : init.compress;\n        this.counter = init.counter || input.counter || 0;\n        this.agent = init.agent || input.agent;\n        this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;\n        this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;\n        // 5.4, Request constructor steps, step 16.\n        // Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy\n        this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || \"\";\n    }\n    /** @returns {string} */ get method() {\n        return this[INTERNALS].method;\n    }\n    /** @returns {string} */ get url() {\n        return node_url.format(this[INTERNALS].parsedURL);\n    }\n    /** @returns {Headers} */ get headers() {\n        return this[INTERNALS].headers;\n    }\n    get redirect() {\n        return this[INTERNALS].redirect;\n    }\n    /** @returns {AbortSignal} */ get signal() {\n        return this[INTERNALS].signal;\n    }\n    // https://fetch.spec.whatwg.org/#dom-request-referrer\n    get referrer() {\n        if (this[INTERNALS].referrer === \"no-referrer\") {\n            return \"\";\n        }\n        if (this[INTERNALS].referrer === \"client\") {\n            return \"about:client\";\n        }\n        if (this[INTERNALS].referrer) {\n            return this[INTERNALS].referrer.toString();\n        }\n        return undefined;\n    }\n    get referrerPolicy() {\n        return this[INTERNALS].referrerPolicy;\n    }\n    set referrerPolicy(referrerPolicy) {\n        this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);\n    }\n    /**\n\t * Clone this request\n\t *\n\t * @return  Request\n\t */ clone() {\n        return new Request(this);\n    }\n    get [Symbol.toStringTag]() {\n        return \"Request\";\n    }\n}\nObject.defineProperties(Request.prototype, {\n    method: {\n        enumerable: true\n    },\n    url: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    redirect: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    },\n    signal: {\n        enumerable: true\n    },\n    referrer: {\n        enumerable: true\n    },\n    referrerPolicy: {\n        enumerable: true\n    }\n});\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param {Request} request - A Request instance\n * @return The options object to be passed to http.request\n */ const getNodeRequestOptions = (request)=>{\n    const { parsedURL } = request[INTERNALS];\n    const headers = new Headers(request[INTERNALS].headers);\n    // Fetch step 1.3\n    if (!headers.has(\"Accept\")) {\n        headers.set(\"Accept\", \"*/*\");\n    }\n    // HTTP-network-or-cache fetch steps 2.4-2.7\n    let contentLengthValue = null;\n    if (request.body === null && /^(post|put)$/i.test(request.method)) {\n        contentLengthValue = \"0\";\n    }\n    if (request.body !== null) {\n        const totalBytes = getTotalBytes(request);\n        // Set Content-Length if totalBytes is a number (that is not NaN)\n        if (typeof totalBytes === \"number\" && !Number.isNaN(totalBytes)) {\n            contentLengthValue = String(totalBytes);\n        }\n    }\n    if (contentLengthValue) {\n        headers.set(\"Content-Length\", contentLengthValue);\n    }\n    // 4.1. Main fetch, step 2.6\n    // > If request's referrer policy is the empty string, then set request's referrer policy to the\n    // > default referrer policy.\n    if (request.referrerPolicy === \"\") {\n        request.referrerPolicy = DEFAULT_REFERRER_POLICY;\n    }\n    // 4.1. Main fetch, step 2.7\n    // > If request's referrer is not \"no-referrer\", set request's referrer to the result of invoking\n    // > determine request's referrer.\n    if (request.referrer && request.referrer !== \"no-referrer\") {\n        request[INTERNALS].referrer = determineRequestsReferrer(request);\n    } else {\n        request[INTERNALS].referrer = \"no-referrer\";\n    }\n    // 4.5. HTTP-network-or-cache fetch, step 6.9\n    // > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized\n    // >  and isomorphic encoded, to httpRequest's header list.\n    if (request[INTERNALS].referrer instanceof URL) {\n        headers.set(\"Referer\", request.referrer);\n    }\n    // HTTP-network-or-cache fetch step 2.11\n    if (!headers.has(\"User-Agent\")) {\n        headers.set(\"User-Agent\", \"node-fetch\");\n    }\n    // HTTP-network-or-cache fetch step 2.15\n    if (request.compress && !headers.has(\"Accept-Encoding\")) {\n        headers.set(\"Accept-Encoding\", \"gzip, deflate, br\");\n    }\n    let { agent } = request;\n    if (typeof agent === \"function\") {\n        agent = agent(parsedURL);\n    }\n    if (!headers.has(\"Connection\") && !agent) {\n        headers.set(\"Connection\", \"close\");\n    }\n    // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n    const search = getSearch(parsedURL);\n    // Pass the full URL directly to request(), but overwrite the following\n    // options:\n    const options = {\n        // Overwrite search to retain trailing ? (issue #776)\n        path: parsedURL.pathname + search,\n        // The following options are not expressed in the URL\n        method: request.method,\n        headers: headers[Symbol.for(\"nodejs.util.inspect.custom\")](),\n        insecureHTTPParser: request.insecureHTTPParser,\n        agent\n    };\n    return {\n        /** @type {URL} */ parsedURL,\n        options\n    };\n};\n/**\n * AbortError interface for cancelled requests\n */ class AbortError extends FetchBaseError {\n    constructor(message, type = \"aborted\"){\n        super(message, type);\n    }\n}\n/*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */ if (!globalThis.DOMException) {\n    try {\n        const { MessageChannel } = __webpack_require__(/*! worker_threads */ \"worker_threads\"), port = new MessageChannel().port1, ab = new ArrayBuffer();\n        port.postMessage(ab, [\n            ab,\n            ab\n        ]);\n    } catch (err) {\n        err.constructor.name === \"DOMException\" && (globalThis.DOMException = err.constructor);\n    }\n}\nvar nodeDomexception = globalThis.DOMException;\n/**\n * Index.js\n *\n * a request API compatible with window.fetch\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */ const supportedSchemas = new Set([\n    \"data:\",\n    \"http:\",\n    \"https:\"\n]);\n/**\n * Fetch function\n *\n * @param   {string | URL | import('./request').default} url - Absolute url or Request instance\n * @param   {*} [options_] - Fetch options\n * @return  {Promise<import('./response').default>}\n */ async function fetch(url, options_) {\n    return new Promise((resolve, reject)=>{\n        // Build request object\n        const request = new Request(url, options_);\n        const { parsedURL, options } = getNodeRequestOptions(request);\n        if (!supportedSchemas.has(parsedURL.protocol)) {\n            throw new TypeError(`node-fetch cannot load ${url}. URL scheme \"${parsedURL.protocol.replace(/:$/, \"\")}\" is not supported.`);\n        }\n        if (parsedURL.protocol === \"data:\") {\n            const data = dataUriToBuffer(request.url);\n            const response = new Response(data, {\n                headers: {\n                    \"Content-Type\": data.typeFull\n                }\n            });\n            resolve(response);\n            return;\n        }\n        // Wrap http.request into fetch\n        const send = (parsedURL.protocol === \"https:\" ? https : http).request;\n        const { signal } = request;\n        let response = null;\n        const abort = ()=>{\n            const error = new AbortError(\"The operation was aborted.\");\n            reject(error);\n            if (request.body && request.body instanceof Stream.Readable) {\n                request.body.destroy(error);\n            }\n            if (!response || !response.body) {\n                return;\n            }\n            response.body.emit(\"error\", error);\n        };\n        if (signal && signal.aborted) {\n            abort();\n            return;\n        }\n        const abortAndFinalize = ()=>{\n            abort();\n            finalize();\n        };\n        // Send request\n        const request_ = send(parsedURL.toString(), options);\n        if (signal) {\n            signal.addEventListener(\"abort\", abortAndFinalize);\n        }\n        const finalize = ()=>{\n            request_.abort();\n            if (signal) {\n                signal.removeEventListener(\"abort\", abortAndFinalize);\n            }\n        };\n        request_.on(\"error\", (error)=>{\n            reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, \"system\", error));\n            finalize();\n        });\n        fixResponseChunkedTransferBadEnding(request_, (error)=>{\n            if (response && response.body) {\n                response.body.destroy(error);\n            }\n        });\n        /* c8 ignore next 18 */ if (process.version < \"v14\") {\n            // Before Node.js 14, pipeline() does not fully support async iterators and does not always\n            // properly handle when the socket close/end events are out of order.\n            request_.on(\"socket\", (s)=>{\n                let endedWithEventsCount;\n                s.prependListener(\"end\", ()=>{\n                    endedWithEventsCount = s._eventsCount;\n                });\n                s.prependListener(\"close\", (hadError)=>{\n                    // if end happened before close but the socket didn't emit an error, do it now\n                    if (response && endedWithEventsCount < s._eventsCount && !hadError) {\n                        const error = new Error(\"Premature close\");\n                        error.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                        response.body.emit(\"error\", error);\n                    }\n                });\n            });\n        }\n        request_.on(\"response\", (response_)=>{\n            request_.setTimeout(0);\n            const headers = fromRawHeaders(response_.rawHeaders);\n            // HTTP fetch step 5\n            if (isRedirect(response_.statusCode)) {\n                // HTTP fetch step 5.2\n                const location = headers.get(\"Location\");\n                // HTTP fetch step 5.3\n                let locationURL = null;\n                try {\n                    locationURL = location === null ? null : new URL(location, request.url);\n                } catch  {\n                    // error here can only be invalid URL in Location: header\n                    // do not throw when options.redirect == manual\n                    // let the user extract the errorneous redirect URL\n                    if (request.redirect !== \"manual\") {\n                        reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, \"invalid-redirect\"));\n                        finalize();\n                        return;\n                    }\n                }\n                // HTTP fetch step 5.5\n                switch(request.redirect){\n                    case \"error\":\n                        reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, \"no-redirect\"));\n                        finalize();\n                        return;\n                    case \"manual\":\n                        break;\n                    case \"follow\":\n                        {\n                            // HTTP-redirect fetch step 2\n                            if (locationURL === null) {\n                                break;\n                            }\n                            // HTTP-redirect fetch step 5\n                            if (request.counter >= request.follow) {\n                                reject(new FetchError(`maximum redirect reached at: ${request.url}`, \"max-redirect\"));\n                                finalize();\n                                return;\n                            }\n                            // HTTP-redirect fetch step 6 (counter increment)\n                            // Create a new Request object.\n                            const requestOptions = {\n                                headers: new Headers(request.headers),\n                                follow: request.follow,\n                                counter: request.counter + 1,\n                                agent: request.agent,\n                                compress: request.compress,\n                                method: request.method,\n                                body: clone(request),\n                                signal: request.signal,\n                                size: request.size,\n                                referrer: request.referrer,\n                                referrerPolicy: request.referrerPolicy\n                            };\n                            // when forwarding sensitive headers like \"Authorization\",\n                            // \"WWW-Authenticate\", and \"Cookie\" to untrusted targets,\n                            // headers will be ignored when following a redirect to a domain\n                            // that is not a subdomain match or exact match of the initial domain.\n                            // For example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\"\n                            // will forward the sensitive headers, but a redirect to \"bar.com\" will not.\n                            // headers will also be ignored when following a redirect to a domain using\n                            // a different protocol. For example, a redirect from \"https://foo.com\" to \"http://foo.com\"\n                            // will not forward the sensitive headers\n                            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n                                for (const name of [\n                                    \"authorization\",\n                                    \"www-authenticate\",\n                                    \"cookie\",\n                                    \"cookie2\"\n                                ]){\n                                    requestOptions.headers.delete(name);\n                                }\n                            }\n                            // HTTP-redirect fetch step 9\n                            if (response_.statusCode !== 303 && request.body && options_.body instanceof Stream.Readable) {\n                                reject(new FetchError(\"Cannot follow redirect with body being a readable stream\", \"unsupported-redirect\"));\n                                finalize();\n                                return;\n                            }\n                            // HTTP-redirect fetch step 11\n                            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === \"POST\") {\n                                requestOptions.method = \"GET\";\n                                requestOptions.body = undefined;\n                                requestOptions.headers.delete(\"content-length\");\n                            }\n                            // HTTP-redirect fetch step 14\n                            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);\n                            if (responseReferrerPolicy) {\n                                requestOptions.referrerPolicy = responseReferrerPolicy;\n                            }\n                            // HTTP-redirect fetch step 15\n                            resolve(fetch(new Request(locationURL, requestOptions)));\n                            finalize();\n                            return;\n                        }\n                    default:\n                        return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));\n                }\n            }\n            // Prepare response\n            if (signal) {\n                response_.once(\"end\", ()=>{\n                    signal.removeEventListener(\"abort\", abortAndFinalize);\n                });\n            }\n            let body = Stream.pipeline(response_, new Stream.PassThrough(), (error)=>{\n                if (error) {\n                    reject(error);\n                }\n            });\n            // see https://github.com/nodejs/node/pull/29376\n            /* c8 ignore next 3 */ if (process.version < \"v12.10\") {\n                response_.on(\"aborted\", abortAndFinalize);\n            }\n            const responseOptions = {\n                url: request.url,\n                status: response_.statusCode,\n                statusText: response_.statusMessage,\n                headers,\n                size: request.size,\n                counter: request.counter,\n                highWaterMark: request.highWaterMark\n            };\n            // HTTP-network fetch step 12.1.1.3\n            const codings = headers.get(\"Content-Encoding\");\n            // HTTP-network fetch step 12.1.1.4: handle content codings\n            // in following scenarios we ignore compression support\n            // 1. compression support is disabled\n            // 2. HEAD request\n            // 3. no Content-Encoding header\n            // 4. no content response (204)\n            // 5. content not modified response (304)\n            if (!request.compress || request.method === \"HEAD\" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {\n                response = new Response(body, responseOptions);\n                resolve(response);\n                return;\n            }\n            // For Node v6+\n            // Be less strict when decoding compressed responses, since sometimes\n            // servers send slightly invalid responses that are still accepted\n            // by common browsers.\n            // Always using Z_SYNC_FLUSH is what cURL does.\n            const zlibOptions = {\n                flush: zlib.Z_SYNC_FLUSH,\n                finishFlush: zlib.Z_SYNC_FLUSH\n            };\n            // For gzip\n            if (codings === \"gzip\" || codings === \"x-gzip\") {\n                body = Stream.pipeline(body, zlib.createGunzip(zlibOptions), (error)=>{\n                    if (error) {\n                        reject(error);\n                    }\n                });\n                response = new Response(body, responseOptions);\n                resolve(response);\n                return;\n            }\n            // For deflate\n            if (codings === \"deflate\" || codings === \"x-deflate\") {\n                // Handle the infamous raw deflate response from old servers\n                // a hack for old IIS and Apache servers\n                const raw = Stream.pipeline(response_, new Stream.PassThrough(), (error)=>{\n                    if (error) {\n                        reject(error);\n                    }\n                });\n                raw.once(\"data\", (chunk)=>{\n                    // See http://stackoverflow.com/questions/37519828\n                    if ((chunk[0] & 0x0F) === 0x08) {\n                        body = Stream.pipeline(body, zlib.createInflate(), (error)=>{\n                            if (error) {\n                                reject(error);\n                            }\n                        });\n                    } else {\n                        body = Stream.pipeline(body, zlib.createInflateRaw(), (error)=>{\n                            if (error) {\n                                reject(error);\n                            }\n                        });\n                    }\n                    response = new Response(body, responseOptions);\n                    resolve(response);\n                });\n                raw.once(\"end\", ()=>{\n                    // Some old IIS servers return zero-length OK deflate responses, so\n                    // 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903\n                    if (!response) {\n                        response = new Response(body, responseOptions);\n                        resolve(response);\n                    }\n                });\n                return;\n            }\n            // For br\n            if (codings === \"br\") {\n                body = Stream.pipeline(body, zlib.createBrotliDecompress(), (error)=>{\n                    if (error) {\n                        reject(error);\n                    }\n                });\n                response = new Response(body, responseOptions);\n                resolve(response);\n                return;\n            }\n            // Otherwise, use response as-is\n            response = new Response(body, responseOptions);\n            resolve(response);\n        });\n        // eslint-disable-next-line promise/prefer-await-to-then\n        writeToStream(request_, request).catch(reject);\n    });\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n    const LAST_CHUNK = node_buffer.Buffer.from(\"0\\r\\n\\r\\n\");\n    let isChunkedTransfer = false;\n    let properLastChunkReceived = false;\n    let previousChunk;\n    request.on(\"response\", (response)=>{\n        const { headers } = response;\n        isChunkedTransfer = headers[\"transfer-encoding\"] === \"chunked\" && !headers[\"content-length\"];\n    });\n    request.on(\"socket\", (socket)=>{\n        const onSocketClose = ()=>{\n            if (isChunkedTransfer && !properLastChunkReceived) {\n                const error = new Error(\"Premature close\");\n                error.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                errorCallback(error);\n            }\n        };\n        const onData = (buf)=>{\n            properLastChunkReceived = node_buffer.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;\n            // Sometimes final 0-length chunk and end of message code are in separate packets\n            if (!properLastChunkReceived && previousChunk) {\n                properLastChunkReceived = node_buffer.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && node_buffer.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;\n            }\n            previousChunk = buf;\n        };\n        socket.prependListener(\"close\", onSocketClose);\n        socket.on(\"data\", onData);\n        request.on(\"close\", ()=>{\n            socket.removeListener(\"close\", onSocketClose);\n            socket.removeListener(\"data\", onData);\n        });\n    });\n}\n/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */ /**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */ /**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */ const privateData = new WeakMap();\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */ const wrappers = new WeakMap();\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */ function pd(event) {\n    const retv = privateData.get(event);\n    console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n    return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */ function setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n            console.error(\"Unable to preventDefault inside passive event listener invocation.\", data.passiveListener);\n        }\n        return;\n    }\n    if (!data.event.cancelable) {\n        return;\n    }\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */ /**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */ function Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now()\n    });\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", {\n        value: false,\n        enumerable: true\n    });\n    // Define accessors\n    const keys = Object.keys(event);\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */ get type () {\n        return pd(this).event.type;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */ get target () {\n        return pd(this).eventTarget;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */ get currentTarget () {\n        return pd(this).currentTarget;\n    },\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */ composedPath () {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return [];\n        }\n        return [\n            currentTarget\n        ];\n    },\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */ get NONE () {\n        return 0;\n    },\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */ get CAPTURING_PHASE () {\n        return 1;\n    },\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */ get AT_TARGET () {\n        return 2;\n    },\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */ get BUBBLING_PHASE () {\n        return 3;\n    },\n    /**\n     * The target of this event.\n     * @type {number}\n     */ get eventPhase () {\n        return pd(this).eventPhase;\n    },\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */ stopPropagation () {\n        const data = pd(this);\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */ stopImmediatePropagation () {\n        const data = pd(this);\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */ get bubbles () {\n        return Boolean(pd(this).event.bubbles);\n    },\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */ get cancelable () {\n        return Boolean(pd(this).event.cancelable);\n    },\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */ preventDefault () {\n        setCancelFlag(pd(this));\n    },\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */ get defaultPrevented () {\n        return pd(this).canceled;\n    },\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */ get composed () {\n        return Boolean(pd(this).event.composed);\n    },\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */ get timeStamp () {\n        return pd(this).timeStamp;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */ get srcElement () {\n        return pd(this).eventTarget;\n    },\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */ get cancelBubble () {\n        return pd(this).stopped;\n    },\n    set cancelBubble (value){\n        if (!value) {\n            return;\n        }\n        const data = pd(this);\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */ get returnValue () {\n        return !pd(this).canceled;\n    },\n    set returnValue (value){\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */ initEvent () {\n    // Do nothing.\n    }\n};\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true\n});\n// Ensure `event instanceof window.Event` is `true`.\nif (false) {}\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */ function defineRedirectDescriptor(key) {\n    return {\n        get () {\n            return pd(this).event[key];\n        },\n        set (value1) {\n            pd(this).event[key] = value1;\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */ function defineCallDescriptor(key) {\n    return {\n        value () {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments);\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */ function defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent;\n    }\n    /** CustomEvent */ function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: {\n            value: CustomEvent,\n            configurable: true,\n            writable: true\n        }\n    });\n    // Define accessors.\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));\n        }\n    }\n    return CustomEvent;\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */ function getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event;\n    }\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper;\n}\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */ function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event);\n}\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */ function isStopped(event) {\n    return pd(event).immediateStopped;\n}\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */ function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */ function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */ function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */ /**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */ const listenersMap = new WeakMap();\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */ function isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n    ;\n}\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */ function getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n    }\n    return listeners;\n}\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */ function defineEventAttributeDescriptor(eventName) {\n    return {\n        get () {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while(node != null){\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener;\n                }\n                node = node.next;\n            }\n            return null;\n        },\n        set (listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while(node != null){\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n                node = node.next;\n            }\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */ function defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));\n}\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */ function defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */ function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true\n        }\n    });\n    for(let i = 0; i < eventNames.length; ++i){\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n    return CustomEventTarget;\n}\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */ function EventTarget() {\n    /*eslint-disable consistent-return */ if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return;\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0]);\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for(let i = 0; i < arguments.length; ++i){\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types);\n    }\n    throw new TypeError(\"Cannot call a class as a function\");\n/*eslint-enable consistent-return */ }\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */ addEventListener (eventName, listener, options) {\n        if (listener == null) {\n            return;\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\");\n        }\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null\n        };\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return;\n        }\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while(node != null){\n            if (node.listener === listener && node.listenerType === listenerType) {\n                // Should ignore duplication.\n                return;\n            }\n            prev = node;\n            node = node.next;\n        }\n        // Add it.\n        prev.next = newNode;\n    },\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */ removeEventListener (eventName, listener, options) {\n        if (listener == null) {\n            return;\n        }\n        const listeners = getListeners(this);\n        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        let prev = null;\n        let node = listeners.get(eventName);\n        while(node != null){\n            if (node.listener === listener && node.listenerType === listenerType) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return;\n            }\n            prev = node;\n            node = node.next;\n        }\n    },\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */ dispatchEvent (event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.');\n        }\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true;\n        }\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while(node != null){\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n            // Call this listener\n            setPassiveListener(wrappedEvent, node.passive ? node.listener : null);\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n                        console.error(err);\n                    }\n                }\n            } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n                node.listener.handleEvent(wrappedEvent);\n            }\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break;\n            }\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n        return !wrappedEvent.defaultPrevented;\n    }\n};\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true\n});\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (false) {}\n/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * See LICENSE file in root directory for full license.\n */ /**\n * The signal class.\n * @see https://dom.spec.whatwg.org/#abortsignal\n */ class AbortSignal extends EventTarget {\n    /**\n     * AbortSignal cannot be constructed directly.\n     */ constructor(){\n        super();\n        throw new TypeError(\"AbortSignal cannot be constructed directly\");\n    }\n    /**\n     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.\n     */ get aborted() {\n        const aborted = abortedFlags.get(this);\n        if (typeof aborted !== \"boolean\") {\n            throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? \"null\" : typeof this}`);\n        }\n        return aborted;\n    }\n}\ndefineEventAttribute(AbortSignal.prototype, \"abort\");\n/**\n * Create an AbortSignal object.\n */ function createAbortSignal() {\n    const signal = Object.create(AbortSignal.prototype);\n    EventTarget.call(signal);\n    abortedFlags.set(signal, false);\n    return signal;\n}\n/**\n * Abort a given signal.\n */ function abortSignal(signal) {\n    if (abortedFlags.get(signal) !== false) {\n        return;\n    }\n    abortedFlags.set(signal, true);\n    signal.dispatchEvent({\n        type: \"abort\"\n    });\n}\n/**\n * Aborted flag for each instances.\n */ const abortedFlags = new WeakMap();\n// Properties should be enumerable.\nObject.defineProperties(AbortSignal.prototype, {\n    aborted: {\n        enumerable: true\n    }\n});\n// `toString()` should return `\"[object AbortSignal]\"`\nif (typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\") {\n    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \"AbortSignal\"\n    });\n}\n/**\n * The AbortController.\n * @see https://dom.spec.whatwg.org/#abortcontroller\n */ class AbortController$1 {\n    /**\n     * Initialize this controller.\n     */ constructor(){\n        signals.set(this, createAbortSignal());\n    }\n    /**\n     * Returns the `AbortSignal` object associated with this object.\n     */ get signal() {\n        return getSignal(this);\n    }\n    /**\n     * Abort and signal to any observers that the associated activity is to be aborted.\n     */ abort() {\n        abortSignal(getSignal(this));\n    }\n}\n/**\n * Associated signals.\n */ const signals = new WeakMap();\n/**\n * Get the associated signal of a given controller.\n */ function getSignal(controller) {\n    const signal = signals.get(controller);\n    if (signal == null) {\n        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? \"null\" : typeof controller}`);\n    }\n    return signal;\n}\n// Properties should be enumerable.\nObject.defineProperties(AbortController$1.prototype, {\n    signal: {\n        enumerable: true\n    },\n    abort: {\n        enumerable: true\n    }\n});\nif (typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\") {\n    Object.defineProperty(AbortController$1.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \"AbortController\"\n    });\n}\nexports.AbortController = AbortController$1;\nexports.AbortError = AbortError;\nexports.FetchError = FetchError;\nexports.File = File$1;\nexports.FormData = FormData;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports._Blob = _Blob$1;\nexports.fetch = fetch;\nexports.isRedirect = isRedirect;\nexports.nodeDomexception = nodeDomexception;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9zaGFyZWQvbm9kZS1mZXRjaC1uYXRpdmUuOGFmZDNmZWEuY2pzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUVBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1JLGNBQWNKLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1LLFlBQVlMLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1NLFdBQVdOLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1PLFdBQVdQLG1CQUFPQSxDQUFDO0FBQ3pCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSOzs7Ozs7Q0FNQyxHQUNELFNBQVNRLGdCQUFnQkMsR0FBRztJQUN4QixJQUFJLENBQUMsVUFBVUMsSUFBSSxDQUFDRCxNQUFNO1FBQ3RCLE1BQU0sSUFBSUUsVUFBVTtJQUN4QjtJQUNBLGlCQUFpQjtJQUNqQkYsTUFBTUEsSUFBSUcsT0FBTyxDQUFDLFVBQVU7SUFDNUIsK0RBQStEO0lBQy9ELE1BQU1DLGFBQWFKLElBQUlLLE9BQU8sQ0FBQztJQUMvQixJQUFJRCxlQUFlLENBQUMsS0FBS0EsY0FBYyxHQUFHO1FBQ3RDLE1BQU0sSUFBSUYsVUFBVTtJQUN4QjtJQUNBLG1EQUFtRDtJQUNuRCxNQUFNSSxPQUFPTixJQUFJTyxTQUFTLENBQUMsR0FBR0gsWUFBWUksS0FBSyxDQUFDO0lBQ2hELElBQUlDLFVBQVU7SUFDZCxJQUFJQyxTQUFTO0lBQ2IsTUFBTUMsT0FBT0wsSUFBSSxDQUFDLEVBQUUsSUFBSTtJQUN4QixJQUFJTSxXQUFXRDtJQUNmLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJUCxLQUFLUSxNQUFNLEVBQUVELElBQUs7UUFDbEMsSUFBSVAsSUFBSSxDQUFDTyxF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YnBhY2s6Ly9tZXJucHJvamVjdC8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoLW5hdGl2ZS9kaXN0L3NoYXJlZC9ub2RlLWZldGNoLW5hdGl2ZS44YWZkM2ZlYS5janM/ZTdiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdub2RlOmh0dHAnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnbm9kZTpodHRwcycpO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoJ25vZGU6emxpYicpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKTtcbmNvbnN0IG5vZGVfYnVmZmVyID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKTtcbmNvbnN0IG5vZGVfdXRpbCA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpO1xuY29uc3Qgbm9kZV91cmwgPSByZXF1aXJlKCdub2RlOnVybCcpO1xuY29uc3Qgbm9kZV9uZXQgPSByZXF1aXJlKCdub2RlOm5ldCcpO1xucmVxdWlyZSgnbm9kZTpmcycpO1xucmVxdWlyZSgnbm9kZTpwYXRoJyk7XG5cbi8qKlxuICogUmV0dXJucyBhIGBCdWZmZXJgIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIGRhdGEgVVJJIGB1cmlgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmkgRGF0YSBVUkkgdG8gdHVybiBpbnRvIGEgQnVmZmVyIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXIgaW5zdGFuY2UgZnJvbSBEYXRhIFVSSVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGF0YVVyaVRvQnVmZmVyKHVyaSkge1xuICAgIGlmICghL15kYXRhOi9pLnRlc3QodXJpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgdXJpYCBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSBEYXRhIFVSSSAobXVzdCBiZWdpbiB3aXRoIFwiZGF0YTpcIiknKTtcbiAgICB9XG4gICAgLy8gc3RyaXAgbmV3bGluZXNcbiAgICB1cmkgPSB1cmkucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyk7XG4gICAgLy8gc3BsaXQgdGhlIFVSSSB1cCBpbnRvIHRoZSBcIm1ldGFkYXRhXCIgYW5kIHRoZSBcImRhdGFcIiBwb3J0aW9uc1xuICAgIGNvbnN0IGZpcnN0Q29tbWEgPSB1cmkuaW5kZXhPZignLCcpO1xuICAgIGlmIChmaXJzdENvbW1hID09PSAtMSB8fCBmaXJzdENvbW1hIDw9IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWFsZm9ybWVkIGRhdGE6IFVSSScpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgdGhlIFwiZGF0YTpcIiBzY2hlbWUgYW5kIHBhcnNlIHRoZSBtZXRhZGF0YVxuICAgIGNvbnN0IG1ldGEgPSB1cmkuc3Vic3RyaW5nKDUsIGZpcnN0Q29tbWEpLnNwbGl0KCc7Jyk7XG4gICAgbGV0IGNoYXJzZXQgPSAnJztcbiAgICBsZXQgYmFzZTY0ID0gZmFsc2U7XG4gICAgY29uc3QgdHlwZSA9IG1ldGFbMF0gfHwgJ3RleHQvcGxhaW4nO1xuICAgIGxldCB0eXBlRnVsbCA9IHR5cGU7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtZXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtZXRhW2ldID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgYmFzZTY0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVGdWxsICs9IGA7JHttZXRhW2ldfWA7XG4gICAgICAgICAgICBpZiAobWV0YVtpXS5pbmRleE9mKCdjaGFyc2V0PScpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldCA9IG1ldGFbaV0uc3Vic3RyaW5nKDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRlZmF1bHRzIHRvIFVTLUFTQ0lJIG9ubHkgaWYgdHlwZSBpcyBub3QgcHJvdmlkZWRcbiAgICBpZiAoIW1ldGFbMF0gJiYgIWNoYXJzZXQubGVuZ3RoKSB7XG4gICAgICAgIHR5cGVGdWxsICs9ICc7Y2hhcnNldD1VUy1BU0NJSSc7XG4gICAgICAgIGNoYXJzZXQgPSAnVVMtQVNDSUknO1xuICAgIH1cbiAgICAvLyBnZXQgdGhlIGVuY29kZWQgZGF0YSBwb3J0aW9uIGFuZCBkZWNvZGUgVVJJLWVuY29kZWQgY2hhcnNcbiAgICBjb25zdCBlbmNvZGluZyA9IGJhc2U2NCA/ICdiYXNlNjQnIDogJ2FzY2lpJztcbiAgICBjb25zdCBkYXRhID0gdW5lc2NhcGUodXJpLnN1YnN0cmluZyhmaXJzdENvbW1hICsgMSkpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKTtcbiAgICAvLyBzZXQgYC50eXBlYCBhbmQgYC50eXBlRnVsbGAgcHJvcGVydGllcyB0byBNSU1FIHR5cGVcbiAgICBidWZmZXIudHlwZSA9IHR5cGU7XG4gICAgYnVmZmVyLnR5cGVGdWxsID0gdHlwZUZ1bGw7XG4gICAgLy8gc2V0IHRoZSBgLmNoYXJzZXRgIHByb3BlcnR5XG4gICAgYnVmZmVyLmNoYXJzZXQgPSBjaGFyc2V0O1xuICAgIHJldHVybiBidWZmZXI7XG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgcG9ueWZpbGxfZXMyMDE4ID0ge2V4cG9ydHM6IHt9fTtcblxuLyoqXG4gKiB3ZWItc3RyZWFtcy1wb2x5ZmlsbCB2My4yLjFcbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRQb255ZmlsbF9lczIwMTg7XG5cbmZ1bmN0aW9uIHJlcXVpcmVQb255ZmlsbF9lczIwMTggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRQb255ZmlsbF9lczIwMTgpIHJldHVybiBwb255ZmlsbF9lczIwMTguZXhwb3J0cztcblx0aGFzUmVxdWlyZWRQb255ZmlsbF9lczIwMTggPSAxO1xuXHQoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdChmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdFx0ICAgIGZhY3RvcnkoZXhwb3J0cykgO1xuXHRcdH0oY29tbW9uanNHbG9iYWwsIChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdCAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuc3ltYm9sXCIgLz5cblx0XHQgICAgY29uc3QgU3ltYm9sUG9seWZpbGwgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnID9cblx0XHQgICAgICAgIFN5bWJvbCA6XG5cdFx0ICAgICAgICBkZXNjcmlwdGlvbiA9PiBgU3ltYm9sKCR7ZGVzY3JpcHRpb259KWA7XG5cblx0XHQgICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cblx0XHQgICAgZnVuY3Rpb24gbm9vcCgpIHtcblx0XHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZ2V0R2xvYmFscygpIHtcblx0XHQgICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gc2VsZjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb21tb25qc0dsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gY29tbW9uanNHbG9iYWw7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IGdsb2JhbHMgPSBnZXRHbG9iYWxzKCk7XG5cblx0XHQgICAgZnVuY3Rpb24gdHlwZUlzT2JqZWN0KHgpIHtcblx0XHQgICAgICAgIHJldHVybiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbiA9IG5vb3A7XG5cblx0XHQgICAgY29uc3Qgb3JpZ2luYWxQcm9taXNlID0gUHJvbWlzZTtcblx0XHQgICAgY29uc3Qgb3JpZ2luYWxQcm9taXNlVGhlbiA9IFByb21pc2UucHJvdG90eXBlLnRoZW47XG5cdFx0ICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZVJlc29sdmUgPSBQcm9taXNlLnJlc29sdmUuYmluZChvcmlnaW5hbFByb21pc2UpO1xuXHRcdCAgICBjb25zdCBvcmlnaW5hbFByb21pc2VSZWplY3QgPSBQcm9taXNlLnJlamVjdC5iaW5kKG9yaWdpbmFsUHJvbWlzZSk7XG5cdFx0ICAgIGZ1bmN0aW9uIG5ld1Byb21pc2UoZXhlY3V0b3IpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgb3JpZ2luYWxQcm9taXNlKGV4ZWN1dG9yKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBwcm9taXNlUmVzb2x2ZWRXaXRoKHZhbHVlKSB7XG5cdFx0ICAgICAgICByZXR1cm4gb3JpZ2luYWxQcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFzb24pIHtcblx0XHQgICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2VSZWplY3QocmVhc29uKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcblx0XHQgICAgICAgIC8vIFRoZXJlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGFueSB3YXkgdG8gY29ycmVjdGx5IGVtdWxhdGUgdGhlIGJlaGF2aW91ciBmcm9tIEphdmFTY3JpcHQsIHNvIHRoaXMgaXMganVzdCBhblxuXHRcdCAgICAgICAgLy8gYXBwcm94aW1hdGlvbi5cblx0XHQgICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2VUaGVuLmNhbGwocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIHVwb25Qcm9taXNlKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG5cdFx0ICAgICAgICBQZXJmb3JtUHJvbWlzZVRoZW4oUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSwgdW5kZWZpbmVkLCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIHVwb25GdWxmaWxsbWVudChwcm9taXNlLCBvbkZ1bGZpbGxlZCkge1xuXHRcdCAgICAgICAgdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIHVwb25SZWplY3Rpb24ocHJvbWlzZSwgb25SZWplY3RlZCkge1xuXHRcdCAgICAgICAgdXBvblByb21pc2UocHJvbWlzZSwgdW5kZWZpbmVkLCBvblJlamVjdGVkKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChwcm9taXNlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcblx0XHQgICAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHByb21pc2UpIHtcblx0XHQgICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCB1bmRlZmluZWQsIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbik7XG5cdFx0ICAgIH1cblx0XHQgICAgY29uc3QgcXVldWVNaWNyb3Rhc2sgPSAoKCkgPT4ge1xuXHRcdCAgICAgICAgY29uc3QgZ2xvYmFsUXVldWVNaWNyb3Rhc2sgPSBnbG9iYWxzICYmIGdsb2JhbHMucXVldWVNaWNyb3Rhc2s7XG5cdFx0ICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFF1ZXVlTWljcm90YXNrO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChmbikgPT4gUGVyZm9ybVByb21pc2VUaGVuKHJlc29sdmVkUHJvbWlzZSwgZm4pO1xuXHRcdCAgICB9KSgpO1xuXHRcdCAgICBmdW5jdGlvbiByZWZsZWN0Q2FsbChGLCBWLCBhcmdzKSB7XG5cdFx0ICAgICAgICBpZiAodHlwZW9mIEYgIT09ICdmdW5jdGlvbicpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKEYsIFYsIGFyZ3MpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIHByb21pc2VDYWxsKEYsIFYsIGFyZ3MpIHtcblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgocmVmbGVjdENhbGwoRiwgViwgYXJncykpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY2F0Y2ggKHZhbHVlKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodmFsdWUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cblx0XHQgICAgLy8gT3JpZ2luYWwgZnJvbSBDaHJvbWl1bVxuXHRcdCAgICAvLyBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLysvMGFlZTQ0MzRhNGRiYTQyYTQyYWJhZWE5YmZiYzBjZDE5NmE2M2JjMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL3N0cmVhbXMvU2ltcGxlUXVldWUuanNcblx0XHQgICAgY29uc3QgUVVFVUVfTUFYX0FSUkFZX1NJWkUgPSAxNjM4NDtcblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIFNpbXBsZSBxdWV1ZSBzdHJ1Y3R1cmUuXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEF2b2lkcyBzY2FsYWJpbGl0eSBpc3N1ZXMgd2l0aCB1c2luZyBhIHBhY2tlZCBhcnJheSBkaXJlY3RseSBieSB1c2luZ1xuXHRcdCAgICAgKiBtdWx0aXBsZSBhcnJheXMgaW4gYSBsaW5rZWQgbGlzdCBhbmQga2VlcGluZyB0aGUgYXJyYXkgc2l6ZSBib3VuZGVkLlxuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgU2ltcGxlUXVldWUge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IoKSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gMDtcblx0XHQgICAgICAgICAgICB0aGlzLl9zaXplID0gMDtcblx0XHQgICAgICAgICAgICAvLyBfZnJvbnQgYW5kIF9iYWNrIGFyZSBhbHdheXMgZGVmaW5lZC5cblx0XHQgICAgICAgICAgICB0aGlzLl9mcm9udCA9IHtcblx0XHQgICAgICAgICAgICAgICAgX2VsZW1lbnRzOiBbXSxcblx0XHQgICAgICAgICAgICAgICAgX25leHQ6IHVuZGVmaW5lZFxuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgdGhpcy5fYmFjayA9IHRoaXMuX2Zyb250O1xuXHRcdCAgICAgICAgICAgIC8vIFRoZSBjdXJzb3IgaXMgdXNlZCB0byBhdm9pZCBjYWxsaW5nIEFycmF5LnNoaWZ0KCkuXG5cdFx0ICAgICAgICAgICAgLy8gSXQgY29udGFpbnMgdGhlIGluZGV4IG9mIHRoZSBmcm9udCBlbGVtZW50IG9mIHRoZSBhcnJheSBpbnNpZGUgdGhlXG5cdFx0ICAgICAgICAgICAgLy8gZnJvbnQtbW9zdCBub2RlLiBJdCBpcyBhbHdheXMgaW4gdGhlIHJhbmdlIFswLCBRVUVVRV9NQVhfQVJSQVlfU0laRSkuXG5cdFx0ICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gMDtcblx0XHQgICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIG9ubHkgb25lIG5vZGUsIHNpemUgPT09IGVsZW1lbnRzLmxlbmd0aCAtIGN1cnNvci5cblx0XHQgICAgICAgICAgICB0aGlzLl9zaXplID0gMDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGdldCBsZW5ndGgoKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBGb3IgZXhjZXB0aW9uIHNhZmV0eSwgdGhpcyBtZXRob2QgaXMgc3RydWN0dXJlZCBpbiBvcmRlcjpcblx0XHQgICAgICAgIC8vIDEuIFJlYWQgc3RhdGVcblx0XHQgICAgICAgIC8vIDIuIENhbGN1bGF0ZSByZXF1aXJlZCBzdGF0ZSBtdXRhdGlvbnNcblx0XHQgICAgICAgIC8vIDMuIFBlcmZvcm0gc3RhdGUgbXV0YXRpb25zXG5cdFx0ICAgICAgICBwdXNoKGVsZW1lbnQpIHtcblx0XHQgICAgICAgICAgICBjb25zdCBvbGRCYWNrID0gdGhpcy5fYmFjaztcblx0XHQgICAgICAgICAgICBsZXQgbmV3QmFjayA9IG9sZEJhY2s7XG5cdFx0ICAgICAgICAgICAgaWYgKG9sZEJhY2suX2VsZW1lbnRzLmxlbmd0aCA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUgLSAxKSB7XG5cdFx0ICAgICAgICAgICAgICAgIG5ld0JhY2sgPSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBfZWxlbWVudHM6IFtdLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgX25leHQ6IHVuZGVmaW5lZFxuXHRcdCAgICAgICAgICAgICAgICB9O1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAvLyBwdXNoKCkgaXMgdGhlIG11dGF0aW9uIG1vc3QgbGlrZWx5IHRvIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gaXRcblx0XHQgICAgICAgICAgICAvLyBnb2VzIGZpcnN0LlxuXHRcdCAgICAgICAgICAgIG9sZEJhY2suX2VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0ICAgICAgICAgICAgaWYgKG5ld0JhY2sgIT09IG9sZEJhY2spIHtcblx0XHQgICAgICAgICAgICAgICAgdGhpcy5fYmFjayA9IG5ld0JhY2s7XG5cdFx0ICAgICAgICAgICAgICAgIG9sZEJhY2suX25leHQgPSBuZXdCYWNrO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICArK3RoaXMuX3NpemU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBMaWtlIHB1c2goKSwgc2hpZnQoKSBmb2xsb3dzIHRoZSByZWFkIC0+IGNhbGN1bGF0ZSAtPiBtdXRhdGUgcGF0dGVybiBmb3Jcblx0XHQgICAgICAgIC8vIGV4Y2VwdGlvbiBzYWZldHkuXG5cdFx0ICAgICAgICBzaGlmdCgpIHsgLy8gbXVzdCBub3QgYmUgY2FsbGVkIG9uIGFuIGVtcHR5IHF1ZXVlXG5cdFx0ICAgICAgICAgICAgY29uc3Qgb2xkRnJvbnQgPSB0aGlzLl9mcm9udDtcblx0XHQgICAgICAgICAgICBsZXQgbmV3RnJvbnQgPSBvbGRGcm9udDtcblx0XHQgICAgICAgICAgICBjb25zdCBvbGRDdXJzb3IgPSB0aGlzLl9jdXJzb3I7XG5cdFx0ICAgICAgICAgICAgbGV0IG5ld0N1cnNvciA9IG9sZEN1cnNvciArIDE7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBvbGRGcm9udC5fZWxlbWVudHM7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW29sZEN1cnNvcl07XG5cdFx0ICAgICAgICAgICAgaWYgKG5ld0N1cnNvciA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUpIHtcblx0XHQgICAgICAgICAgICAgICAgbmV3RnJvbnQgPSBvbGRGcm9udC5fbmV4dDtcblx0XHQgICAgICAgICAgICAgICAgbmV3Q3Vyc29yID0gMDtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgLy8gTm8gbXV0YXRpb25zIGJlZm9yZSB0aGlzIHBvaW50LlxuXHRcdCAgICAgICAgICAgIC0tdGhpcy5fc2l6ZTtcblx0XHQgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBuZXdDdXJzb3I7XG5cdFx0ICAgICAgICAgICAgaWYgKG9sZEZyb250ICE9PSBuZXdGcm9udCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aGlzLl9mcm9udCA9IG5ld0Zyb250O1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAvLyBQZXJtaXQgc2hpZnRlZCBlbGVtZW50IHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuXHRcdCAgICAgICAgICAgIGVsZW1lbnRzW29sZEN1cnNvcl0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBUaGUgdHJpY2t5IHRoaW5nIGFib3V0IGZvckVhY2goKSBpcyB0aGF0IGl0IGNhbiBiZSBjYWxsZWRcblx0XHQgICAgICAgIC8vIHJlLWVudHJhbnRseS4gVGhlIHF1ZXVlIG1heSBiZSBtdXRhdGVkIGluc2lkZSB0aGUgY2FsbGJhY2suIEl0IGlzIGVhc3kgdG9cblx0XHQgICAgICAgIC8vIHNlZSB0aGF0IHB1c2goKSB3aXRoaW4gdGhlIGNhbGxiYWNrIGhhcyBubyBuZWdhdGl2ZSBlZmZlY3RzIHNpbmNlIHRoZSBlbmRcblx0XHQgICAgICAgIC8vIG9mIHRoZSBxdWV1ZSBpcyBjaGVja2VkIGZvciBvbiBldmVyeSBpdGVyYXRpb24uIElmIHNoaWZ0KCkgaXMgY2FsbGVkXG5cdFx0ICAgICAgICAvLyByZXBlYXRlZGx5IHdpdGhpbiB0aGUgY2FsbGJhY2sgdGhlbiB0aGUgbmV4dCBpdGVyYXRpb24gbWF5IHJldHVybiBhblxuXHRcdCAgICAgICAgLy8gZWxlbWVudCB0aGF0IGhhcyBiZWVuIHJlbW92ZWQuIEluIHRoaXMgY2FzZSB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcblx0XHQgICAgICAgIC8vIHdpdGggdW5kZWZpbmVkIHZhbHVlcyB1bnRpbCB3ZSBlaXRoZXIgXCJjYXRjaCB1cFwiIHdpdGggZWxlbWVudHMgdGhhdCBzdGlsbFxuXHRcdCAgICAgICAgLy8gZXhpc3Qgb3IgcmVhY2ggdGhlIGJhY2sgb2YgdGhlIHF1ZXVlLlxuXHRcdCAgICAgICAgZm9yRWFjaChjYWxsYmFjaykge1xuXHRcdCAgICAgICAgICAgIGxldCBpID0gdGhpcy5fY3Vyc29yO1xuXHRcdCAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5fZnJvbnQ7XG5cdFx0ICAgICAgICAgICAgbGV0IGVsZW1lbnRzID0gbm9kZS5fZWxlbWVudHM7XG5cdFx0ICAgICAgICAgICAgd2hpbGUgKGkgIT09IGVsZW1lbnRzLmxlbmd0aCB8fCBub2RlLl9uZXh0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKGkgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuX25leHQ7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IG5vZGUuX2VsZW1lbnRzO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgY2FsbGJhY2soZWxlbWVudHNbaV0pO1xuXHRcdCAgICAgICAgICAgICAgICArK2k7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gUmV0dXJuIHRoZSBlbGVtZW50IHRoYXQgd291bGQgYmUgcmV0dXJuZWQgaWYgc2hpZnQoKSB3YXMgY2FsbGVkIG5vdyxcblx0XHQgICAgICAgIC8vIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBxdWV1ZS5cblx0XHQgICAgICAgIHBlZWsoKSB7IC8vIG11c3Qgbm90IGJlIGNhbGxlZCBvbiBhbiBlbXB0eSBxdWV1ZVxuXHRcdCAgICAgICAgICAgIGNvbnN0IGZyb250ID0gdGhpcy5fZnJvbnQ7XG5cdFx0ICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5fY3Vyc29yO1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmcm9udC5fZWxlbWVudHNbY3Vyc29yXTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUocmVhZGVyLCBzdHJlYW0pIHtcblx0XHQgICAgICAgIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9IHN0cmVhbTtcblx0XHQgICAgICAgIHN0cmVhbS5fcmVhZGVyID0gcmVhZGVyO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZChyZWFkZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZChyZWFkZXIsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEEgY2xpZW50IG9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciBhbmQgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZVxuXHRcdCAgICAvLyBjaGVjay5cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHJlYWRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG5cdFx0ICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKSB7XG5cdFx0ICAgICAgICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgbmV3IFR5cGVFcnJvcihgUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZChyZWFkZXIsIG5ldyBUeXBlRXJyb3IoYFJlYWRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCkpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtLl9yZWFkZXIgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXG5cdFx0ICAgIGZ1bmN0aW9uIHJlYWRlckxvY2tFeGNlcHRpb24obmFtZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCAnICsgbmFtZSArICcgYSBzdHJlYW0gdXNpbmcgYSByZWxlYXNlZCByZWFkZXInKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLlxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKSB7XG5cdFx0ICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQgICAgICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0ICAgICAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCByZWFzb24pIHtcblx0XHQgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuXHRcdCAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCByZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQocmVhZGVyKSB7XG5cdFx0ICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcblx0XHQgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBpZiAocmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShyZWFkZXIuX2Nsb3NlZFByb21pc2UpO1xuXHRcdCAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuXHRcdCAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHJlYWRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgcmVhc29uKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKSB7XG5cdFx0ICAgICAgICBpZiAocmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBjb25zdCBBYm9ydFN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbQWJvcnRTdGVwc11dJyk7XG5cdFx0ICAgIGNvbnN0IEVycm9yU3RlcHMgPSBTeW1ib2xQb2x5ZmlsbCgnW1tFcnJvclN0ZXBzXV0nKTtcblx0XHQgICAgY29uc3QgQ2FuY2VsU3RlcHMgPSBTeW1ib2xQb2x5ZmlsbCgnW1tDYW5jZWxTdGVwc11dJyk7XG5cdFx0ICAgIGNvbnN0IFB1bGxTdGVwcyA9IFN5bWJvbFBvbHlmaWxsKCdbW1B1bGxTdGVwc11dJyk7XG5cblx0XHQgICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuXHRcdCAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNGaW5pdGUjUG9seWZpbGxcblx0XHQgICAgY29uc3QgTnVtYmVySXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gKHgpIHtcblx0XHQgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoeCk7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuXHRcdCAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jI1BvbHlmaWxsXG5cdFx0ICAgIGNvbnN0IE1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcblx0XHQgICAgICAgIHJldHVybiB2IDwgMCA/IE1hdGguY2VpbCh2KSA6IE1hdGguZmxvb3Iodik7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLWRpY3Rpb25hcmllc1xuXHRcdCAgICBmdW5jdGlvbiBpc0RpY3Rpb25hcnkoeCkge1xuXHRcdCAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBhc3NlcnREaWN0aW9uYXJ5KG9iaiwgY29udGV4dCkge1xuXHRcdCAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkICYmICFpc0RpY3Rpb25hcnkob2JqKSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIG9iamVjdC5gKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtY2FsbGJhY2stZnVuY3Rpb25zXG5cdFx0ICAgIGZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHgsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgZnVuY3Rpb24uYCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLW9iamVjdFxuXHRcdCAgICBmdW5jdGlvbiBpc09iamVjdCh4KSB7XG5cdFx0ICAgICAgICByZXR1cm4gKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBhc3NlcnRPYmplY3QoeCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgaWYgKCFpc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIG9iamVjdC5gKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHgsIHBvc2l0aW9uLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICR7cG9zaXRpb259IGlzIHJlcXVpcmVkIGluICcke2NvbnRleHR9Jy5gKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBhc3NlcnRSZXF1aXJlZEZpZWxkKHgsIGZpZWxkLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmaWVsZH0gaXMgcmVxdWlyZWQgaW4gJyR7Y29udGV4dH0nLmApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC11bnJlc3RyaWN0ZWQtZG91YmxlXG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUodmFsdWUpIHtcblx0XHQgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNlbnNvck5lZ2F0aXZlWmVybyh4KSB7XG5cdFx0ICAgICAgICByZXR1cm4geCA9PT0gMCA/IDAgOiB4O1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGludGVnZXJQYXJ0KHgpIHtcblx0XHQgICAgICAgIHJldHVybiBjZW5zb3JOZWdhdGl2ZVplcm8oTWF0aFRydW5jKHgpKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtdW5zaWduZWQtbG9uZy1sb25nXG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSh2YWx1ZSwgY29udGV4dCkge1xuXHRcdCAgICAgICAgY29uc3QgbG93ZXJCb3VuZCA9IDA7XG5cdFx0ICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cdFx0ICAgICAgICBsZXQgeCA9IE51bWJlcih2YWx1ZSk7XG5cdFx0ICAgICAgICB4ID0gY2Vuc29yTmVnYXRpdmVaZXJvKHgpO1xuXHRcdCAgICAgICAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgZmluaXRlIG51bWJlcmApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgeCA9IGludGVnZXJQYXJ0KHgpO1xuXHRcdCAgICAgICAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBvdXRzaWRlIHRoZSBhY2NlcHRlZCByYW5nZSBvZiAke2xvd2VyQm91bmR9IHRvICR7dXBwZXJCb3VuZH0sIGluY2x1c2l2ZWApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSB8fCB4ID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIDA7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBUT0RPIFVzZSBCaWdJbnQgaWYgc3VwcG9ydGVkP1xuXHRcdCAgICAgICAgLy8gbGV0IHhCaWdJbnQgPSBCaWdJbnQoaW50ZWdlclBhcnQoeCkpO1xuXHRcdCAgICAgICAgLy8geEJpZ0ludCA9IEJpZ0ludC5hc1VpbnROKDY0LCB4QmlnSW50KTtcblx0XHQgICAgICAgIC8vIHJldHVybiBOdW1iZXIoeEJpZ0ludCk7XG5cdFx0ICAgICAgICByZXR1cm4geDtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGFzc2VydFJlYWRhYmxlU3RyZWFtKHgsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh4KSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgUmVhZGFibGVTdHJlYW0uYCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cdFx0ICAgIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0sIHJlYWRSZXF1ZXN0KSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX3JlYWRlci5fcmVhZFJlcXVlc3RzLnB1c2gocmVhZFJlcXVlc3QpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGRvbmUpIHtcblx0XHQgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSByZWFkZXIuX3JlYWRSZXF1ZXN0cy5zaGlmdCgpO1xuXHRcdCAgICAgICAgaWYgKGRvbmUpIHtcblx0XHQgICAgICAgICAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkge1xuXHRcdCAgICAgICAgcmV0dXJuIHN0cmVhbS5fcmVhZGVyLl9yZWFkUmVxdWVzdHMubGVuZ3RoO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pIHtcblx0XHQgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXHRcdCAgICAgICAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgIH1cblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEEgZGVmYXVsdCByZWFkZXIgdmVuZGVkIGJ5IGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtfS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuXHRcdCAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyJyk7XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHJlYWRpbmcgYnkgYW5vdGhlciByZWFkZXInKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSh0aGlzLCBzdHJlYW0pO1xuXHRcdCAgICAgICAgICAgIHRoaXMuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCxcblx0XHQgICAgICAgICAqIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3IgdGhlIHJlYWRlcidzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGNsb3NlZCgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgUmVhZGFibGVTdHJlYW0uY2FuY2VsIHwgc3RyZWFtLmNhbmNlbChyZWFzb24pfS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgY2FuY2VsKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwodGhpcywgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBhbGxvd3MgYWNjZXNzIHRvIHRoZSBuZXh0IGNodW5rIGZyb20gdGhlIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLCBpZiBhdmFpbGFibGUuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogSWYgcmVhZGluZyBhIGNodW5rIGNhdXNlcyB0aGUgcXVldWUgdG8gYmVjb21lIGVtcHR5LCBtb3JlIGRhdGEgd2lsbCBiZSBwdWxsZWQgZnJvbSB0aGUgdW5kZXJseWluZyBzb3VyY2UuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIHJlYWQoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdyZWFkIGZyb20nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGxldCByZXNvbHZlUHJvbWlzZTtcblx0XHQgICAgICAgICAgICBsZXQgcmVqZWN0UHJvbWlzZTtcblx0XHQgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcblx0XHQgICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcblx0XHQgICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSxcblx0XHQgICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KSxcblx0XHQgICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6IGUgPT4gcmVqZWN0UHJvbWlzZShlKVxuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCh0aGlzLCByZWFkUmVxdWVzdCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJlbGVhc2VzIHRoZSByZWFkZXIncyBsb2NrIG9uIHRoZSBjb3JyZXNwb25kaW5nIHN0cmVhbS4gQWZ0ZXIgdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgaXMgbm8gbG9uZ2VyIGFjdGl2ZS5cblx0XHQgICAgICAgICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXlcblx0XHQgICAgICAgICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIEEgcmVhZGVyJ3MgbG9jayBjYW5ub3QgYmUgcmVsZWFzZWQgd2hpbGUgaXQgc3RpbGwgaGFzIGEgcGVuZGluZyByZWFkIHJlcXVlc3QsIGkuZS4sIGlmIGEgcHJvbWlzZSByZXR1cm5lZCBieVxuXHRcdCAgICAgICAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xuXHRcdCAgICAgICAgICogZG8gc28gd2lsbCB0aHJvdyBhIGBUeXBlRXJyb3JgIGFuZCBsZWF2ZSB0aGUgcmVhZGVyIGxvY2tlZCB0byB0aGUgc3RyZWFtLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICByZWxlYXNlTG9jaygpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWRSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RyaWVkIHRvIHJlbGVhc2UgYSByZWFkZXIgbG9jayB3aGVuIHRoYXQgcmVhZGVyIGhhcyBwZW5kaW5nIHJlYWQoKSBjYWxscyB1bi1zZXR0bGVkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHJlYWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuXHRcdCAgICAgICAgICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSByZWFkZXJzLlxuXHRcdCAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZFJlcXVlc3RzJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcblx0XHQgICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhzdHJlYW0uX3N0b3JlZEVycm9yKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW1B1bGxTdGVwc10ocmVhZFJlcXVlc3QpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcmApO1xuXHRcdCAgICB9XG5cblx0XHQgICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE4LmFzeW5jaXRlcmFibGVcIiAvPlxuXHRcdCAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24gKi9cblx0XHQgICAgY29uc3QgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXN5bmMgZnVuY3Rpb24qICgpIHsgfSkucHJvdG90eXBlKTtcblxuXHRcdCAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTguYXN5bmNpdGVyYWJsZVwiIC8+XG5cdFx0ICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IocmVhZGVyLCBwcmV2ZW50Q2FuY2VsKSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgIHRoaXMuX3JlYWRlciA9IHJlYWRlcjtcblx0XHQgICAgICAgICAgICB0aGlzLl9wcmV2ZW50Q2FuY2VsID0gcHJldmVudENhbmNlbDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIG5leHQoKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgbmV4dFN0ZXBzID0gKCkgPT4gdGhpcy5fbmV4dFN0ZXBzKCk7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/XG5cdFx0ICAgICAgICAgICAgICAgIHRyYW5zZm9ybVByb21pc2VXaXRoKHRoaXMuX29uZ29pbmdQcm9taXNlLCBuZXh0U3RlcHMsIG5leHRTdGVwcykgOlxuXHRcdCAgICAgICAgICAgICAgICBuZXh0U3RlcHMoKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4odmFsdWUpIHtcblx0XHQgICAgICAgICAgICBjb25zdCByZXR1cm5TdGVwcyA9ICgpID0+IHRoaXMuX3JldHVyblN0ZXBzKHZhbHVlKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2UgP1xuXHRcdCAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0aGlzLl9vbmdvaW5nUHJvbWlzZSwgcmV0dXJuU3RlcHMsIHJldHVyblN0ZXBzKSA6XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVyblN0ZXBzKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBfbmV4dFN0ZXBzKCkge1xuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkZXI7XG5cdFx0ICAgICAgICAgICAgaWYgKHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2l0ZXJhdGUnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGxldCByZXNvbHZlUHJvbWlzZTtcblx0XHQgICAgICAgICAgICBsZXQgcmVqZWN0UHJvbWlzZTtcblx0XHQgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcblx0XHQgICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcblx0XHQgICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGJ5IG9uZSBtaWNyb3Rhc2ssIG90aGVyd2lzZSB3ZSBzdG9wIHB1bGxpbmcgdG9vIGVhcmx5IHdoaWNoIGJyZWFrcyBhIHRlc3QuXG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBJcyB0aGlzIGEgYnVnIGluIHRoZSBzcGVjaWZpY2F0aW9uLCBvciBpbiB0aGUgdGVzdD9cblx0XHQgICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSk7XG5cdFx0ICAgICAgICAgICAgICAgIH0sXG5cdFx0ICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuXHRcdCAgICAgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogcmVhc29uID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlKHJlYXNvbik7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9O1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBfcmV0dXJuU3RlcHModmFsdWUpIHtcblx0XHQgICAgICAgICAgICBpZiAodGhpcy5faXNGaW5pc2hlZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuX3JlYWRlcjtcblx0XHQgICAgICAgICAgICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbignZmluaXNoIGl0ZXJhdGluZycpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKCF0aGlzLl9wcmV2ZW50Q2FuY2VsKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbChyZWFkZXIsIHZhbHVlKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgocmVzdWx0LCAoKSA9PiAoeyB2YWx1ZSwgZG9uZTogdHJ1ZSB9KSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh7IHZhbHVlLCBkb25lOiB0cnVlIH0pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IHtcblx0XHQgICAgICAgIG5leHQoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbignbmV4dCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLm5leHQoKTtcblx0XHQgICAgICAgIH0sXG5cdFx0ICAgICAgICByZXR1cm4odmFsdWUpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXR1cm4nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hc3luY0l0ZXJhdG9ySW1wbC5yZXR1cm4odmFsdWUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9O1xuXHRcdCAgICBpZiAoQXN5bmNJdGVyYXRvclByb3RvdHlwZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cdFx0ICAgIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtLCBwcmV2ZW50Q2FuY2VsKSB7XG5cdFx0ICAgICAgICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG5cdFx0ICAgICAgICBjb25zdCBpbXBsID0gbmV3IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwocmVhZGVyLCBwcmV2ZW50Q2FuY2VsKTtcblx0XHQgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXHRcdCAgICAgICAgaXRlcmF0b3IuX2FzeW5jSXRlcmF0b3JJbXBsID0gaW1wbDtcblx0XHQgICAgICAgIHJldHVybiBpdGVyYXRvcjtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXN5bmNJdGVyYXRvckltcGwnKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFN1c3BpY2lvdXNUeXBlT2ZHdWFyZFxuXHRcdCAgICAgICAgICAgIHJldHVybiB4Ll9hc3luY0l0ZXJhdG9ySW1wbCBpbnN0YW5jZW9mXG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGw7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjYXRjaCAoX2EpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXHRcdCAgICBmdW5jdGlvbiBzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RlYW1Bc3luY0l0ZXJhdG9yYCk7XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuY29yZVwiIC8+XG5cdFx0ICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc05hTiNQb2x5ZmlsbFxuXHRcdCAgICBjb25zdCBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAoeCkge1xuXHRcdCAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXHRcdCAgICAgICAgcmV0dXJuIHggIT09IHg7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgZnVuY3Rpb24gQ3JlYXRlQXJyYXlGcm9tTGlzdChlbGVtZW50cykge1xuXHRcdCAgICAgICAgLy8gV2UgdXNlIGFycmF5cyB0byByZXByZXNlbnQgbGlzdHMsIHNvIHRoaXMgaXMgYmFzaWNhbGx5IGEgbm8tb3AuXG5cdFx0ICAgICAgICAvLyBEbyBhIHNsaWNlIHRob3VnaCBqdXN0IGluIGNhc2Ugd2UgaGFwcGVuIHRvIGRlcGVuZCBvbiB0aGUgdW5pcXVlLW5lc3MuXG5cdFx0ICAgICAgICByZXR1cm4gZWxlbWVudHMuc2xpY2UoKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBDb3B5RGF0YUJsb2NrQnl0ZXMoZGVzdCwgZGVzdE9mZnNldCwgc3JjLCBzcmNPZmZzZXQsIG4pIHtcblx0XHQgICAgICAgIG5ldyBVaW50OEFycmF5KGRlc3QpLnNldChuZXcgVWludDhBcnJheShzcmMsIHNyY09mZnNldCwgbiksIGRlc3RPZmZzZXQpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHlcblx0XHQgICAgZnVuY3Rpb24gVHJhbnNmZXJBcnJheUJ1ZmZlcihPKSB7XG5cdFx0ICAgICAgICByZXR1cm4gTztcblx0XHQgICAgfVxuXHRcdCAgICAvLyBOb3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5XG5cdFx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcblx0XHQgICAgZnVuY3Rpb24gSXNEZXRhY2hlZEJ1ZmZlcihPKSB7XG5cdFx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gQXJyYXlCdWZmZXJTbGljZShidWZmZXIsIGJlZ2luLCBlbmQpIHtcblx0XHQgICAgICAgIC8vIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3QgYXZhaWxhYmxlIG9uIElFMTBcblx0XHQgICAgICAgIC8vIGh0dHBzOi8vd3d3LmNhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX2FycmF5YnVmZmVyX3NsaWNlXG5cdFx0ICAgICAgICBpZiAoYnVmZmVyLnNsaWNlKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZShiZWdpbiwgZW5kKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCAtIGJlZ2luO1xuXHRcdCAgICAgICAgY29uc3Qgc2xpY2UgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcblx0XHQgICAgICAgIENvcHlEYXRhQmxvY2tCeXRlcyhzbGljZSwgMCwgYnVmZmVyLCBiZWdpbiwgbGVuZ3RoKTtcblx0XHQgICAgICAgIHJldHVybiBzbGljZTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIElzTm9uTmVnYXRpdmVOdW1iZXIodikge1xuXHRcdCAgICAgICAgaWYgKHR5cGVvZiB2ICE9PSAnbnVtYmVyJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChOdW1iZXJJc05hTih2KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh2IDwgMCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIENsb25lQXNVaW50OEFycmF5KE8pIHtcblx0XHQgICAgICAgIGNvbnN0IGJ1ZmZlciA9IEFycmF5QnVmZmVyU2xpY2UoTy5idWZmZXIsIE8uYnl0ZU9mZnNldCwgTy5ieXRlT2Zmc2V0ICsgTy5ieXRlTGVuZ3RoKTtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gRGVxdWV1ZVZhbHVlKGNvbnRhaW5lcikge1xuXHRcdCAgICAgICAgY29uc3QgcGFpciA9IGNvbnRhaW5lci5fcXVldWUuc2hpZnQoKTtcblx0XHQgICAgICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgLT0gcGFpci5zaXplO1xuXHRcdCAgICAgICAgaWYgKGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPCAwKSB7XG5cdFx0ICAgICAgICAgICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA9IDA7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gcGFpci52YWx1ZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250YWluZXIsIHZhbHVlLCBzaXplKSB7XG5cdFx0ICAgICAgICBpZiAoIUlzTm9uTmVnYXRpdmVOdW1iZXIoc2l6ZSkgfHwgc2l6ZSA9PT0gSW5maW5pdHkpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignU2l6ZSBtdXN0IGJlIGEgZmluaXRlLCBub24tTmFOLCBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29udGFpbmVyLl9xdWV1ZS5wdXNoKHsgdmFsdWUsIHNpemUgfSk7XG5cdFx0ICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplICs9IHNpemU7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUGVla1F1ZXVlVmFsdWUoY29udGFpbmVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5wZWVrKCk7XG5cdFx0ICAgICAgICByZXR1cm4gcGFpci52YWx1ZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZXNldFF1ZXVlKGNvbnRhaW5lcikge1xuXHRcdCAgICAgICAgY29udGFpbmVyLl9xdWV1ZSA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA9IDA7XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvKipcblx0XHQgICAgICogQSBwdWxsLWludG8gcmVxdWVzdCBpbiBhIHtAbGluayBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyfS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB7XG5cdFx0ICAgICAgICBjb25zdHJ1Y3RvcigpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJldHVybnMgdGhlIHZpZXcgZm9yIHdyaXRpbmcgaW4gdG8sIG9yIGBudWxsYCBpZiB0aGUgQllPQiByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gcmVzcG9uZGVkIHRvLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgdmlldygpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3ZpZXcnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXc7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXNwb25kKGJ5dGVzV3JpdHRlbikge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigncmVzcG9uZCcpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGJ5dGVzV3JpdHRlbiwgMSwgJ3Jlc3BvbmQnKTtcblx0XHQgICAgICAgICAgICBieXRlc1dyaXR0ZW4gPSBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoYnl0ZXNXcml0dGVuLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodGhpcy5fdmlldy5idWZmZXIpKSA7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXNwb25kV2l0aE5ld1ZpZXcodmlldykge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQodmlldywgMSwgJ3Jlc3BvbmRXaXRoTmV3VmlldycpO1xuXHRcdCAgICAgICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW4gb25seSByZXNwb25kIHdpdGggYXJyYXkgYnVmZmVyIHZpZXdzJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHZpZXcuYnVmZmVyKSkgO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIHZpZXcpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLCB7XG5cdFx0ICAgICAgICByZXNwb25kOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHJlc3BvbmRXaXRoTmV3VmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICB2aWV3OiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QnLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgYnl0ZSBzdHJlYW19J3Mgc3RhdGUgYW5kIGludGVybmFsIHF1ZXVlLlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBCWU9CIHB1bGwgcmVxdWVzdCwgb3IgYG51bGxgIGlmIHRoZXJlIGlzbid0IG9uZS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGJ5b2JSZXF1ZXN0KCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYnlvYlJlcXVlc3QnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdCh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIGNvbnRyb2xsZWQgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzXG5cdFx0ICAgICAgICAgKiBvdmVyLWZ1bGwuIEFuIHVuZGVybHlpbmcgYnl0ZSBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCBkZXNpcmVkU2l6ZSgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxuXHRcdCAgICAgICAgICogdGhlIHN0cmVhbSwgYnV0IG9uY2UgdGhvc2UgYXJlIHJlYWQsIHRoZSBzdHJlYW0gd2lsbCBiZWNvbWUgY2xvc2VkLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBjbG9zZSgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkOyBkbyBub3QgY2xvc2UgaXQgYWdhaW4hJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICAgICAgaWYgKHN0YXRlICE9PSAncmVhZGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7c3RhdGV9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgY2xvc2VkYCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVucXVldWUoY2h1bmspIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChjaHVuaywgMSwgJ2VucXVldWUnKTtcblx0XHQgICAgICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2h1bmsgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlldycpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaHVuayBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aCcpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoY2h1bmsuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgY2h1bmsncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhgKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmVhbSBpcyBjbG9zZWQgb3IgZHJhaW5pbmcnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgICAgICBpZiAoc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtzdGF0ZX0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgcmVhZGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBlbnF1ZXVlZCB0b2ApO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBlcnJvcihlID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IodGhpcywgZSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKiogQGludGVybmFsICovXG5cdFx0ICAgICAgICBbQ2FuY2VsU3RlcHNdKHJlYXNvbikge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3ModGhpcyk7XG5cdFx0ICAgICAgICAgICAgUmVzZXRRdWV1ZSh0aGlzKTtcblx0XHQgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKiogQGludGVybmFsICovXG5cdFx0ICAgICAgICBbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCkge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cdFx0ICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlVG90YWxTaXplIC09IGVudHJ5LmJ5dGVMZW5ndGg7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKHRoaXMpO1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW50cnkuYnVmZmVyLCBlbnRyeS5ieXRlT2Zmc2V0LCBlbnRyeS5ieXRlTGVuZ3RoKTtcblx0XHQgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHModmlldyk7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdGhpcy5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuXHRcdCAgICAgICAgICAgIGlmIChhdXRvQWxsb2NhdGVDaHVua1NpemUgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICBsZXQgYnVmZmVyO1xuXHRcdCAgICAgICAgICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgY2F0Y2ggKGJ1ZmZlckUpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKGJ1ZmZlckUpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcixcblx0XHQgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckJ5dGVMZW5ndGg6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcblx0XHQgICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IDAsXG5cdFx0ICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoOiBhdXRvQWxsb2NhdGVDaHVua1NpemUsXG5cdFx0ICAgICAgICAgICAgICAgICAgICBieXRlc0ZpbGxlZDogMCxcblx0XHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTaXplOiAxLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgdmlld0NvbnN0cnVjdG9yOiBVaW50OEFycmF5LFxuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVhZGVyVHlwZTogJ2RlZmF1bHQnXG5cdFx0ICAgICAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0KHN0cmVhbSwgcmVhZFJlcXVlc3QpO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCB7XG5cdFx0ICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGJ5b2JSZXF1ZXN0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcblx0XHQgICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbScpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzaG91bGRQdWxsID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgaWYgKCFzaG91bGRQdWxsKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxpbmcpIHtcblx0XHQgICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSB0cnVlO1xuXHRcdCAgICAgICAgLy8gVE9ETzogVGVzdCBjb250cm9sbGVyIGFyZ3VtZW50XG5cdFx0ICAgICAgICBjb25zdCBwdWxsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0oKTtcblx0XHQgICAgICAgIHVwb25Qcm9taXNlKHB1bGxQcm9taXNlLCAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsQWdhaW4pIHtcblx0XHQgICAgICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0sIGUgPT4ge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKHN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG5cdFx0ICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKTtcblx0XHQgICAgICAgIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IucmVhZGVyVHlwZSA9PT0gJ2RlZmF1bHQnKSB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCBmaWxsZWRWaWV3LCBkb25lKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIGZpbGxlZFZpZXcsIGRvbmUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yKHB1bGxJbnRvRGVzY3JpcHRvcikge1xuXHRcdCAgICAgICAgY29uc3QgYnl0ZXNGaWxsZWQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG5cdFx0ICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcblx0XHQgICAgICAgIHJldHVybiBuZXcgcHVsbEludG9EZXNjcmlwdG9yLnZpZXdDb25zdHJ1Y3RvcihwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCwgYnl0ZXNGaWxsZWQgLyBlbGVtZW50U2l6ZSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9xdWV1ZS5wdXNoKHsgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0pO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgKz0gYnl0ZUxlbmd0aDtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcblx0XHQgICAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuXHRcdCAgICAgICAgY29uc3QgY3VycmVudEFsaWduZWRCeXRlcyA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAlIGVsZW1lbnRTaXplO1xuXHRcdCAgICAgICAgY29uc3QgbWF4Qnl0ZXNUb0NvcHkgPSBNYXRoLm1pbihjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVMZW5ndGggLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQpO1xuXHRcdCAgICAgICAgY29uc3QgbWF4Qnl0ZXNGaWxsZWQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyBtYXhCeXRlc1RvQ29weTtcblx0XHQgICAgICAgIGNvbnN0IG1heEFsaWduZWRCeXRlcyA9IG1heEJ5dGVzRmlsbGVkIC0gbWF4Qnl0ZXNGaWxsZWQgJSBlbGVtZW50U2l6ZTtcblx0XHQgICAgICAgIGxldCB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID0gbWF4Qnl0ZXNUb0NvcHk7XG5cdFx0ICAgICAgICBsZXQgcmVhZHkgPSBmYWxzZTtcblx0XHQgICAgICAgIGlmIChtYXhBbGlnbmVkQnl0ZXMgPiBjdXJyZW50QWxpZ25lZEJ5dGVzKSB7XG5cdFx0ICAgICAgICAgICAgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA9IG1heEFsaWduZWRCeXRlcyAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcblx0XHQgICAgICAgICAgICByZWFkeSA9IHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBxdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlO1xuXHRcdCAgICAgICAgd2hpbGUgKHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgaGVhZE9mUXVldWUgPSBxdWV1ZS5wZWVrKCk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgYnl0ZXNUb0NvcHkgPSBNYXRoLm1pbih0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nLCBoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoKTtcblx0XHQgICAgICAgICAgICBjb25zdCBkZXN0U3RhcnQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcblx0XHQgICAgICAgICAgICBDb3B5RGF0YUJsb2NrQnl0ZXMocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgZGVzdFN0YXJ0LCBoZWFkT2ZRdWV1ZS5idWZmZXIsIGhlYWRPZlF1ZXVlLmJ5dGVPZmZzZXQsIGJ5dGVzVG9Db3B5KTtcblx0XHQgICAgICAgICAgICBpZiAoaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCA9PT0gYnl0ZXNUb0NvcHkpIHtcblx0XHQgICAgICAgICAgICAgICAgcXVldWUuc2hpZnQoKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGhlYWRPZlF1ZXVlLmJ5dGVPZmZzZXQgKz0gYnl0ZXNUb0NvcHk7XG5cdFx0ICAgICAgICAgICAgICAgIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGggLT0gYnl0ZXNUb0NvcHk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplIC09IGJ5dGVzVG9Db3B5O1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBieXRlc1RvQ29weSwgcHVsbEludG9EZXNjcmlwdG9yKTtcblx0XHQgICAgICAgICAgICB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nIC09IGJ5dGVzVG9Db3B5O1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHJlYWR5O1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBzaXplLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcblx0XHQgICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArPSBzaXplO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCAmJiBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCkge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QuX3ZpZXcgPSBudWxsO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBudWxsO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgd2hpbGUgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuXHRcdCAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuXHRcdCAgICAgICAgICAgIGlmIChSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8oY29udHJvbGxlciwgdmlldywgcmVhZEludG9SZXF1ZXN0KSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXHRcdCAgICAgICAgbGV0IGVsZW1lbnRTaXplID0gMTtcblx0XHQgICAgICAgIGlmICh2aWV3LmNvbnN0cnVjdG9yICE9PSBEYXRhVmlldykge1xuXHRcdCAgICAgICAgICAgIGVsZW1lbnRTaXplID0gdmlldy5jb25zdHJ1Y3Rvci5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IGN0b3IgPSB2aWV3LmNvbnN0cnVjdG9yO1xuXHRcdCAgICAgICAgLy8gdHJ5IHtcblx0XHQgICAgICAgIGNvbnN0IGJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIodmlldy5idWZmZXIpO1xuXHRcdCAgICAgICAgLy8gfSBjYXRjaCAoZSkge1xuXHRcdCAgICAgICAgLy8gICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG5cdFx0ICAgICAgICAvLyAgIHJldHVybjtcblx0XHQgICAgICAgIC8vIH1cblx0XHQgICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IHtcblx0XHQgICAgICAgICAgICBidWZmZXIsXG5cdFx0ICAgICAgICAgICAgYnVmZmVyQnl0ZUxlbmd0aDogYnVmZmVyLmJ5dGVMZW5ndGgsXG5cdFx0ICAgICAgICAgICAgYnl0ZU9mZnNldDogdmlldy5ieXRlT2Zmc2V0LFxuXHRcdCAgICAgICAgICAgIGJ5dGVMZW5ndGg6IHZpZXcuYnl0ZUxlbmd0aCxcblx0XHQgICAgICAgICAgICBieXRlc0ZpbGxlZDogMCxcblx0XHQgICAgICAgICAgICBlbGVtZW50U2l6ZSxcblx0XHQgICAgICAgICAgICB2aWV3Q29uc3RydWN0b3I6IGN0b3IsXG5cdFx0ICAgICAgICAgICAgcmVhZGVyVHlwZTogJ2J5b2InXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXHRcdCAgICAgICAgICAgIC8vIE5vIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKCkgY2FsbCBzaW5jZTpcblx0XHQgICAgICAgICAgICAvLyAtIE5vIGNoYW5nZSBoYXBwZW5zIG9uIGRlc2lyZWRTaXplXG5cdFx0ICAgICAgICAgICAgLy8gLSBUaGUgc291cmNlIGhhcyBhbHJlYWR5IGJlZW4gbm90aWZpZWQgb2YgdGhhdCB0aGVyZSdzIGF0IGxlYXN0IDEgcGVuZGluZyByZWFkKHZpZXcpXG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpO1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGVtcHR5VmlldyA9IG5ldyBjdG9yKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCAwKTtcblx0XHQgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Nsb3NlU3RlcHMoZW1wdHlWaWV3KTtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgZmlsbGVkVmlldyA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yKHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoZmlsbGVkVmlldyk7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcblx0XHQgICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cdFx0ICAgICAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCk7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUoY29udHJvbGxlciwgZmlyc3REZXNjcmlwdG9yKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXHRcdCAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW0pKSB7XG5cdFx0ICAgICAgICAgICAgd2hpbGUgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3IgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3Ioc3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZShjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuXHRcdCAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgcHVsbEludG9EZXNjcmlwdG9yKTtcblx0XHQgICAgICAgIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPCBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemUpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBjb25zdCByZW1haW5kZXJTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuXHRcdCAgICAgICAgaWYgKHJlbWFpbmRlclNpemUgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZW5kID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVtYWluZGVyID0gQXJyYXlCdWZmZXJTbGljZShwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBlbmQgLSByZW1haW5kZXJTaXplLCBlbmQpO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHJlbWFpbmRlciwgMCwgcmVtYWluZGVyLmJ5dGVMZW5ndGgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIC09IHJlbWFpbmRlclNpemU7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKSB7XG5cdFx0ICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcblx0XHQgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgZmlyc3REZXNjcmlwdG9yKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5zaGlmdCgpO1xuXHRcdCAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgZGVzaXJlZFNpemUgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBpZiAoZGVzaXJlZFNpemUgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEEgY2xpZW50IG9mIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblx0XHQgICAgICAgIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCB8fCBzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZmlyc3RQZW5kaW5nUHVsbEludG8gPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcblx0XHQgICAgICAgICAgICBpZiAoZmlyc3RQZW5kaW5nUHVsbEludG8uYnl0ZXNGaWxsZWQgPiAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBidWZmZXIgPSBjaHVuay5idWZmZXI7XG5cdFx0ICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gY2h1bmsuYnl0ZU9mZnNldDtcblx0XHQgICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBjaHVuay5ieXRlTGVuZ3RoO1xuXHRcdCAgICAgICAgY29uc3QgdHJhbnNmZXJyZWRCdWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGJ1ZmZlcik7XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZmlyc3RQZW5kaW5nUHVsbEludG8gPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcblx0XHQgICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpKSA7XG5cdFx0ICAgICAgICAgICAgZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSkge1xuXHRcdCAgICAgICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2ZlcnJlZFZpZXcgPSBuZXcgVWludDhBcnJheSh0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgdHJhbnNmZXJyZWRWaWV3LCBmYWxzZSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcblx0XHQgICAgICAgICAgICAvLyBUT0RPOiBJZGVhbGx5IGluIHRoaXMgYnJhbmNoIGRldGFjaGluZyBzaG91bGQgaGFwcGVuIG9ubHkgaWYgdGhlIGJ1ZmZlciBpcyBub3QgY29uc3VtZWQgZnVsbHkuXG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSkge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwgJiYgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGZpcnN0RGVzY3JpcHRvci5idWZmZXIsIGZpcnN0RGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkLCBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCAtIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgYnlvYlJlcXVlc3QgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlKTtcblx0XHQgICAgICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QoYnlvYlJlcXVlc3QsIGNvbnRyb2xsZXIsIHZpZXcpO1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gYnlvYlJlcXVlc3Q7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gY29udHJvbGxlci5fYnlvYlJlcXVlc3Q7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiAwO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKSB7XG5cdFx0ICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG5cdFx0ICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKGJ5dGVzV3JpdHRlbiAhPT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1dyaXR0ZW4gbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSBjbG9zZWQgc3RyZWFtJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1dyaXR0ZW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gMCB3aGVuIGNhbGxpbmcgcmVzcG9uZCgpIG9uIGEgcmVhZGFibGUgc3RyZWFtJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyBieXRlc1dyaXR0ZW4gPiBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYnl0ZXNXcml0dGVuIG91dCBvZiByYW5nZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZpcnN0RGVzY3JpcHRvci5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGZpcnN0RGVzY3JpcHRvci5idWZmZXIpO1xuXHRcdCAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoY29udHJvbGxlciwgdmlldykge1xuXHRcdCAgICAgICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG5cdFx0ICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggIT09IDApIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZpZXdcXCdzIGxlbmd0aCBtdXN0IGJlIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgY2xvc2VkIHN0cmVhbScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZpZXdcXCdzIGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kV2l0aE5ld1ZpZXcoKSBvbiBhIHJlYWRhYmxlIHN0cmVhbScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZU9mZnNldCArIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAhPT0gdmlldy5ieXRlT2Zmc2V0KSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSByZWdpb24gc3BlY2lmaWVkIGJ5IHZpZXcgZG9lcyBub3QgbWF0Y2ggYnlvYlJlcXVlc3QnKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnVmZmVyQnl0ZUxlbmd0aCAhPT0gdmlldy5idWZmZXIuYnl0ZUxlbmd0aCkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgYnVmZmVyIG9mIHZpZXcgaGFzIGRpZmZlcmVudCBjYXBhY2l0eSB0aGFuIGJ5b2JSZXF1ZXN0Jyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgdmlldy5ieXRlTGVuZ3RoID4gZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGgpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHJlZ2lvbiBzcGVjaWZpZWQgYnkgdmlldyBpcyBsYXJnZXIgdGhhbiBieW9iUmVxdWVzdCcpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3Qgdmlld0J5dGVMZW5ndGggPSB2aWV3LmJ5dGVMZW5ndGg7XG5cdFx0ICAgICAgICBmaXJzdERlc2NyaXB0b3IuYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcih2aWV3LmJ1ZmZlcik7XG5cdFx0ICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsKGNvbnRyb2xsZXIsIHZpZXdCeXRlTGVuZ3RoKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBhdXRvQWxsb2NhdGVDaHVua1NpemUpIHtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0gPSBzdHJlYW07XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gbnVsbDtcblx0XHQgICAgICAgIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxuXHRcdCAgICAgICAgY29udHJvbGxlci5fcXVldWUgPSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHB1bGxBbGdvcml0aG07XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9hdXRvQWxsb2NhdGVDaHVua1NpemUgPSBhdXRvQWxsb2NhdGVDaHVua1NpemU7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cdFx0ICAgICAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfSwgciA9PiB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIHIpO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2Uoc3RyZWFtLCB1bmRlcmx5aW5nQnl0ZVNvdXJjZSwgaGlnaFdhdGVyTWFyaykge1xuXHRcdCAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xuXHRcdCAgICAgICAgbGV0IHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgbGV0IHB1bGxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBsZXQgY2FuY2VsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdCeXRlU291cmNlLnN0YXJ0KGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLnB1bGwgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHB1bGxBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5wdWxsKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLmNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgY2FuY2VsQWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdCeXRlU291cmNlLmNhbmNlbChyZWFzb24pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdW5kZXJseWluZ0J5dGVTb3VyY2UuYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuXHRcdCAgICAgICAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBhdXRvQWxsb2NhdGVDaHVua1NpemUpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdChyZXF1ZXN0LCBjb250cm9sbGVyLCB2aWV3KSB7XG5cdFx0ICAgICAgICByZXF1ZXN0Ll9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICByZXF1ZXN0Ll92aWV3ID0gdmlldztcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5cblx0XHQgICAgZnVuY3Rpb24gYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0YCk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcmApO1xuXHRcdCAgICB9XG5cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXHRcdCAgICBmdW5jdGlvbiBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBSZWFkYWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgcmVhZEludG9SZXF1ZXN0KSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX3JlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5wdXNoKHJlYWRJbnRvUmVxdWVzdCk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGRvbmUpIHtcblx0XHQgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZEludG9SZXF1ZXN0ID0gcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLnNoaWZ0KCk7XG5cdFx0ICAgICAgICBpZiAoZG9uZSkge1xuXHRcdCAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pIHtcblx0XHQgICAgICAgIHJldHVybiBzdHJlYW0uX3JlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5sZW5ndGg7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkge1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cdFx0ICAgICAgICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgfVxuXHRcdCAgICAvKipcblx0XHQgICAgICogQSBCWU9CIHJlYWRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW19LlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXInKTtcblx0XHQgICAgICAgICAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlcicpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBmb3IgYSBzdHJlYW0gbm90IGNvbnN0cnVjdGVkIHdpdGggYSBieXRlICcgK1xuXHRcdCAgICAgICAgICAgICAgICAgICAgJ3NvdXJjZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCwgb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvclxuXHRcdCAgICAgICAgICogdGhlIHJlYWRlcidzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGNsb3NlZCgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgUmVhZGFibGVTdHJlYW0uY2FuY2VsIHwgc3RyZWFtLmNhbmNlbChyZWFzb24pfS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgY2FuY2VsKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwodGhpcywgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogQXR0ZW1wdHMgdG8gcmVhZHMgYnl0ZXMgaW50byB2aWV3LCBhbmQgcmV0dXJucyBhIHByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0LlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIElmIHJlYWRpbmcgYSBjaHVuayBjYXVzZXMgdGhlIHF1ZXVlIHRvIGJlY29tZSBlbXB0eSwgbW9yZSBkYXRhIHdpbGwgYmUgcHVsbGVkIGZyb20gdGhlIHVuZGVybHlpbmcgc291cmNlLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICByZWFkKHZpZXcpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3IG11c3QgYmUgYW4gYXJyYXkgYnVmZmVyIHZpZXcnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcigndmlldyBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHZpZXcuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihgdmlldydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aGApKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKSA7XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdyZWFkIGZyb20nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGxldCByZXNvbHZlUHJvbWlzZTtcblx0XHQgICAgICAgICAgICBsZXQgcmVqZWN0UHJvbWlzZTtcblx0XHQgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcblx0XHQgICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICBjb25zdCByZWFkSW50b1JlcXVlc3QgPSB7XG5cdFx0ICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSksXG5cdFx0ICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogdHJ1ZSB9KSxcblx0XHQgICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6IGUgPT4gcmVqZWN0UHJvbWlzZShlKVxuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZCh0aGlzLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZWxlYXNlcyB0aGUgcmVhZGVyJ3MgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXG5cdFx0ICAgICAgICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5XG5cdFx0ICAgICAgICAgKiBmcm9tIG5vdyBvbjsgb3RoZXJ3aXNlLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGNsb3NlZC5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBBIHJlYWRlcidzIGxvY2sgY2Fubm90IGJlIHJlbGVhc2VkIHdoaWxlIGl0IHN0aWxsIGhhcyBhIHBlbmRpbmcgcmVhZCByZXF1ZXN0LCBpLmUuLCBpZiBhIHByb21pc2UgcmV0dXJuZWQgYnlcblx0XHQgICAgICAgICAqIHRoZSByZWFkZXIncyB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnJlYWQgfCByZWFkKCl9IG1ldGhvZCBoYXMgbm90IHlldCBiZWVuIHNldHRsZWQuIEF0dGVtcHRpbmcgdG9cblx0XHQgICAgICAgICAqIGRvIHNvIHdpbGwgdGhyb3cgYSBgVHlwZUVycm9yYCBhbmQgbGVhdmUgdGhlIHJlYWRlciBsb2NrZWQgdG8gdGhlIHN0cmVhbS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgcmVsZWFzZUxvY2soKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aCA+IDApIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHJpZWQgdG8gcmVsZWFzZSBhIHJlYWRlciBsb2NrIHdoZW4gdGhhdCByZWFkZXIgaGFzIHBlbmRpbmcgcmVhZCgpIGNhbGxzIHVuLXNldHRsZWQnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLCB7XG5cdFx0ICAgICAgICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXInLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXG5cdFx0ICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkSW50b1JlcXVlc3RzJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHJlYWRlciwgdmlldywgcmVhZEludG9SZXF1ZXN0KSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcmApO1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIGRlZmF1bHRIV00pIHtcblx0XHQgICAgICAgIGNvbnN0IHsgaGlnaFdhdGVyTWFyayB9ID0gc3RyYXRlZ3k7XG5cdFx0ICAgICAgICBpZiAoaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRIV007XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoTnVtYmVySXNOYU4oaGlnaFdhdGVyTWFyaykgfHwgaGlnaFdhdGVyTWFyayA8IDApIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBoaWdoV2F0ZXJNYXJrJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gaGlnaFdhdGVyTWFyaztcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSkge1xuXHRcdCAgICAgICAgY29uc3QgeyBzaXplIH0gPSBzdHJhdGVneTtcblx0XHQgICAgICAgIGlmICghc2l6ZSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiAoKSA9PiAxO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHNpemU7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KGluaXQsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydERpY3Rpb25hcnkoaW5pdCwgY29udGV4dCk7XG5cdFx0ICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmhpZ2hXYXRlck1hcms7XG5cdFx0ICAgICAgICBjb25zdCBzaXplID0gaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LnNpemU7XG5cdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IGhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoaGlnaFdhdGVyTWFyayksXG5cdFx0ICAgICAgICAgICAgc2l6ZTogc2l6ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUoc2l6ZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2l6ZScgdGhhdGApXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplKGZuLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG5cdFx0ICAgICAgICByZXR1cm4gY2h1bmsgPT4gY29udmVydFVucmVzdHJpY3RlZERvdWJsZShmbihjaHVuaykpO1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rKG9yaWdpbmFsLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9yaWdpbmFsLCBjb250ZXh0KTtcblx0XHQgICAgICAgIGNvbnN0IGFib3J0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmFib3J0O1xuXHRcdCAgICAgICAgY29uc3QgY2xvc2UgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuY2xvc2U7XG5cdFx0ICAgICAgICBjb25zdCBzdGFydCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5zdGFydDtcblx0XHQgICAgICAgIGNvbnN0IHR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHlwZTtcblx0XHQgICAgICAgIGNvbnN0IHdyaXRlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLndyaXRlO1xuXHRcdCAgICAgICAgcmV0dXJuIHtcblx0XHQgICAgICAgICAgICBhYm9ydDogYWJvcnQgPT09IHVuZGVmaW5lZCA/XG5cdFx0ICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2soYWJvcnQsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdhYm9ydCcgdGhhdGApLFxuXHRcdCAgICAgICAgICAgIGNsb3NlOiBjbG9zZSA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayhjbG9zZSwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2Nsb3NlJyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuXHRcdCAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuXHRcdCAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcblx0XHQgICAgICAgICAgICB3cml0ZTogd3JpdGUgPT09IHVuZGVmaW5lZCA/XG5cdFx0ICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2sod3JpdGUsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd3cml0ZScgdGhhdGApLFxuXHRcdCAgICAgICAgICAgIHR5cGVcblx0XHQgICAgICAgIH07XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiAocmVhc29uKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuICgpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW10pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG5cdFx0ICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChjaHVuaywgY29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGFzc2VydFdyaXRhYmxlU3RyZWFtKHgsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh4KSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgV3JpdGFibGVTdHJlYW0uYCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBpc0Fib3J0U2lnbmFsKHZhbHVlKSB7XG5cdFx0ICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5hYm9ydGVkID09PSAnYm9vbGVhbic7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjYXRjaCAoX2EpIHtcblx0XHQgICAgICAgICAgICAvLyBBYm9ydFNpZ25hbC5wcm90b3R5cGUuYWJvcnRlZCB0aHJvd3MgaWYgaXRzIGJyYW5kIGNoZWNrIGZhaWxzXG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IHN1cHBvcnRzQWJvcnRDb250cm9sbGVyID0gdHlwZW9mIEFib3J0Q29udHJvbGxlciA9PT0gJ2Z1bmN0aW9uJztcblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIENvbnN0cnVjdCBhIG5ldyBBYm9ydENvbnRyb2xsZXIsIGlmIHN1cHBvcnRlZCBieSB0aGUgcGxhdGZvcm0uXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEBpbnRlcm5hbFxuXHRcdCAgICAgKi9cblx0XHQgICAgZnVuY3Rpb24gY3JlYXRlQWJvcnRDb250cm9sbGVyKCkge1xuXHRcdCAgICAgICAgaWYgKHN1cHBvcnRzQWJvcnRDb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvKipcblx0XHQgICAgICogQSB3cml0YWJsZSBzdHJlYW0gcmVwcmVzZW50cyBhIGRlc3RpbmF0aW9uIGZvciBkYXRhLCBpbnRvIHdoaWNoIHlvdSBjYW4gd3JpdGUuXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEBwdWJsaWNcblx0XHQgICAgICovXG5cdFx0ICAgIGNsYXNzIFdyaXRhYmxlU3RyZWFtIHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKHJhd1VuZGVybHlpbmdTaW5rID0ge30sIHJhd1N0cmF0ZWd5ID0ge30pIHtcblx0XHQgICAgICAgICAgICBpZiAocmF3VW5kZXJseWluZ1NpbmsgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByYXdVbmRlcmx5aW5nU2luayA9IG51bGw7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICBhc3NlcnRPYmplY3QocmF3VW5kZXJseWluZ1NpbmssICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHVuZGVybHlpbmdTaW5rID0gY29udmVydFVuZGVybHlpbmdTaW5rKHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB1bmRlcmx5aW5nU2luay50eXBlO1xuXHRcdCAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZSBpcyBzcGVjaWZpZWQnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHN0cmF0ZWd5KTtcblx0XHQgICAgICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xuXHRcdCAgICAgICAgICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayh0aGlzLCB1bmRlcmx5aW5nU2luaywgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHdyaXRhYmxlIHN0cmVhbSBpcyBsb2NrZWQgdG8gYSB3cml0ZXIuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCBsb2NrZWQoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMignbG9ja2VkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBBYm9ydHMgdGhlIHN0cmVhbSwgc2lnbmFsaW5nIHRoYXQgdGhlIHByb2R1Y2VyIGNhbiBubyBsb25nZXIgc3VjY2Vzc2Z1bGx5IHdyaXRlIHRvIHRoZSBzdHJlYW0gYW5kIGl0IGlzIHRvIGJlXG5cdFx0ICAgICAgICAgKiBpbW1lZGlhdGVseSBtb3ZlZCB0byBhbiBlcnJvcmVkIHN0YXRlLCB3aXRoIGFueSBxdWV1ZWQtdXAgd3JpdGVzIGRpc2NhcmRlZC4gVGhpcyB3aWxsIGFsc28gZXhlY3V0ZSBhbnkgYWJvcnRcblx0XHQgICAgICAgICAqIG1lY2hhbmlzbSBvZiB0aGUgdW5kZXJseWluZyBzaW5rLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgZnVsZmlsbCBpZiB0aGUgc3RyZWFtIHNodXRzIGRvd24gc3VjY2Vzc2Z1bGx5LCBvciByZWplY3QgaWYgdGhlIHVuZGVybHlpbmcgc2luayBzaWduYWxlZFxuXHRcdCAgICAgICAgICogdGhhdCB0aGVyZSB3YXMgYW4gZXJyb3IgZG9pbmcgc28uIEFkZGl0aW9uYWxseSwgaXQgd2lsbCByZWplY3Qgd2l0aCBhIGBUeXBlRXJyb3JgICh3aXRob3V0IGF0dGVtcHRpbmcgdG8gY2FuY2VsXG5cdFx0ICAgICAgICAgKiB0aGUgc3RyZWFtKSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2NrZWQuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGFib3J0KHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2Fib3J0JykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgYWJvcnQgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQodGhpcywgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogQ2xvc2VzIHRoZSBzdHJlYW0uIFRoZSB1bmRlcmx5aW5nIHNpbmsgd2lsbCBmaW5pc2ggcHJvY2Vzc2luZyBhbnkgcHJldmlvdXNseS13cml0dGVuIGNodW5rcywgYmVmb3JlIGludm9raW5nIGl0c1xuXHRcdCAgICAgICAgICogY2xvc2UgYmVoYXZpb3IuIER1cmluZyB0aGlzIHRpbWUgYW55IGZ1cnRoZXIgYXR0ZW1wdHMgdG8gd3JpdGUgd2lsbCBmYWlsICh3aXRob3V0IGVycm9yaW5nIHRoZSBzdHJlYW0pLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIFRoZSBtZXRob2QgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgaWYgYWxsIHJlbWFpbmluZyBjaHVua3MgYXJlIHN1Y2Nlc3NmdWxseSB3cml0dGVuIGFuZCB0aGUgc3RyZWFtXG5cdFx0ICAgICAgICAgKiBzdWNjZXNzZnVsbHkgY2xvc2VzLCBvciByZWplY3RzIGlmIGFuIGVycm9yIGlzIGVuY291bnRlcmVkIGR1cmluZyB0aGlzIHByb2Nlc3MuIEFkZGl0aW9uYWxseSwgaXQgd2lsbCByZWplY3Qgd2l0aFxuXHRcdCAgICAgICAgICogYSBgVHlwZUVycm9yYCAod2l0aG91dCBhdHRlbXB0aW5nIHRvIGNhbmNlbCB0aGUgc3RyZWFtKSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2NrZWQuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGNsb3NlKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2Nsb3NlJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1DbG9zZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogQ3JlYXRlcyBhIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgfCB3cml0ZXJ9IGFuZCBsb2NrcyB0aGUgc3RyZWFtIHRvIHRoZSBuZXcgd3JpdGVyLiBXaGlsZSB0aGUgc3RyZWFtXG5cdFx0ICAgICAgICAgKiBpcyBsb2NrZWQsIG5vIG90aGVyIHdyaXRlciBjYW4gYmUgYWNxdWlyZWQgdW50aWwgdGhpcyBvbmUgaXMgcmVsZWFzZWQuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogVGhpcyBmdW5jdGlvbmFsaXR5IGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBjcmVhdGluZyBhYnN0cmFjdGlvbnMgdGhhdCBkZXNpcmUgdGhlIGFiaWxpdHkgdG8gd3JpdGUgdG8gYSBzdHJlYW1cblx0XHQgICAgICAgICAqIHdpdGhvdXQgaW50ZXJydXB0aW9uIG9yIGludGVybGVhdmluZy4gQnkgZ2V0dGluZyBhIHdyaXRlciBmb3IgdGhlIHN0cmVhbSwgeW91IGNhbiBlbnN1cmUgbm9ib2R5IGVsc2UgY2FuIHdyaXRlIGF0XG5cdFx0ICAgICAgICAgKiB0aGUgc2FtZSB0aW1lLCB3aGljaCB3b3VsZCBjYXVzZSB0aGUgcmVzdWx0aW5nIHdyaXR0ZW4gZGF0YSB0byBiZSB1bnByZWRpY3RhYmxlIGFuZCBwcm9iYWJseSB1c2VsZXNzLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXRXcml0ZXIoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMignZ2V0V3JpdGVyJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgZ2V0V3JpdGVyOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGxvY2tlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cblx0XHQgICAgfSk7XG5cdFx0ICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuXHRcdCAgICAgICAgICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW0nLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtLlxuXHRcdCAgICBmdW5jdGlvbiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHN0cmVhbSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoc3RyZWFtKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuXHRcdCAgICBmdW5jdGlvbiBDcmVhdGVXcml0YWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyayA9IDEsIHNpemVBbGdvcml0aG0gPSAoKSA9PiAxKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0oc3RyZWFtKTtcblx0XHQgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblx0XHQgICAgICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcblx0XHQgICAgICAgIHJldHVybiBzdHJlYW07XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHN0cmVhbSkge1xuXHRcdCAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICd3cml0YWJsZSc7XG5cdFx0ICAgICAgICAvLyBUaGUgZXJyb3IgdGhhdCB3aWxsIGJlIHJlcG9ydGVkIGJ5IG5ldyBtZXRob2QgY2FsbHMgb25jZSB0aGUgc3RhdGUgYmVjb21lcyBlcnJvcmVkLiBPbmx5IHNldCB3aGVuIFtbc3RhdGVdXSBpc1xuXHRcdCAgICAgICAgLy8gJ2Vycm9yaW5nJyBvciAnZXJyb3JlZCcuIE1heSBiZSBzZXQgdG8gYW4gdW5kZWZpbmVkIHZhbHVlLlxuXHRcdCAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHN0cmVhbS5fd3JpdGVyID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byB1bmRlZmluZWQgZmlyc3QgYmVjYXVzZSB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNvbnRyb2xsZXIgY2hlY2tzIHRoaXNcblx0XHQgICAgICAgIC8vIHZhcmlhYmxlIHRvIHZhbGlkYXRlIHRoZSBjYWxsZXIuXG5cdFx0ICAgICAgICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIC8vIFRoaXMgcXVldWUgaXMgcGxhY2VkIGhlcmUgaW5zdGVhZCBvZiB0aGUgd3JpdGVyIGNsYXNzIGluIG9yZGVyIHRvIGFsbG93IGZvciBwYXNzaW5nIGEgd3JpdGVyIHRvIHRoZSBuZXh0IGRhdGFcblx0XHQgICAgICAgIC8vIHByb2R1Y2VyIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIHF1ZXVlZCB3cml0ZXMgdG8gZmluaXNoLlxuXHRcdCAgICAgICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cdFx0ICAgICAgICAvLyBXcml0ZSByZXF1ZXN0cyBhcmUgcmVtb3ZlZCBmcm9tIF93cml0ZVJlcXVlc3RzIHdoZW4gd3JpdGUoKSBpcyBjYWxsZWQgb24gdGhlIHVuZGVybHlpbmcgc2luay4gVGhpcyBwcmV2ZW50c1xuXHRcdCAgICAgICAgLy8gdGhlbSBmcm9tIGJlaW5nIGVycm9uZW91c2x5IHJlamVjdGVkIG9uIGVycm9yLiBJZiBhIHdyaXRlKCkgY2FsbCBpcyBpbi1mbGlnaHQsIHRoZSByZXF1ZXN0IGlzIHN0b3JlZCBoZXJlLlxuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIC8vIFRoZSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gd3JpdGVyLmNsb3NlKCkuIFN0b3JlZCBoZXJlIGJlY2F1c2UgaXQgbWF5IGJlIGZ1bGZpbGxlZCBhZnRlciB0aGUgd3JpdGVyXG5cdFx0ICAgICAgICAvLyBoYXMgYmVlbiBkZXRhY2hlZC5cblx0XHQgICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgLy8gQ2xvc2UgcmVxdWVzdCBpcyByZW1vdmVkIGZyb20gX2Nsb3NlUmVxdWVzdCB3aGVuIGNsb3NlKCkgaXMgY2FsbGVkIG9uIHRoZSB1bmRlcmx5aW5nIHNpbmsuIFRoaXMgcHJldmVudHMgaXRcblx0XHQgICAgICAgIC8vIGZyb20gYmVpbmcgZXJyb25lb3VzbHkgcmVqZWN0ZWQgb24gZXJyb3IuIElmIGEgY2xvc2UoKSBjYWxsIGlzIGluLWZsaWdodCwgdGhlIHJlcXVlc3QgaXMgc3RvcmVkIGhlcmUuXG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgLy8gVGhlIHByb21pc2UgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB3cml0ZXIuYWJvcnQoKS4gVGhpcyBtYXkgYWxzbyBiZSBmdWxmaWxsZWQgYWZ0ZXIgdGhlIHdyaXRlciBoYXMgZGV0YWNoZWQuXG5cdFx0ICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAvLyBUaGUgYmFja3ByZXNzdXJlIHNpZ25hbCBzZXQgYnkgdGhlIGNvbnRyb2xsZXIuXG5cdFx0ICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGZhbHNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW0oeCkge1xuXHRcdCAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcicpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkge1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fd3JpdGVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUFib3J0KHN0cmVhbSwgcmVhc29uKSB7XG5cdFx0ICAgICAgICB2YXIgX2E7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLl9hYm9ydFJlYXNvbiA9IHJlYXNvbjtcblx0XHQgICAgICAgIChfYSA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLl9hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYm9ydCgpO1xuXHRcdCAgICAgICAgLy8gVHlwZVNjcmlwdCBuYXJyb3dzIHRoZSB0eXBlIG9mIGBzdHJlYW0uX3N0YXRlYCBkb3duIHRvICd3cml0YWJsZScgfCAnZXJyb3JpbmcnLFxuXHRcdCAgICAgICAgLy8gYnV0IGl0IGRvZXNuJ3Qga25vdyB0aGF0IHNpZ25hbGluZyBhYm9ydCBydW5zIGF1dGhvciBjb2RlIHRoYXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHRoZSBzdGF0ZS5cblx0XHQgICAgICAgIC8vIFdpZGVuIHRoZSB0eXBlIGFnYWluIGJ5IGNhc3RpbmcgdG8gV3JpdGFibGVTdHJlYW1TdGF0ZS5cblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmVkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9wcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgbGV0IHdhc0FscmVhZHlFcnJvcmluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG5cdFx0ICAgICAgICAgICAgd2FzQWxyZWFkeUVycm9yaW5nID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICAvLyByZWFzb24gd2lsbCBub3QgYmUgdXNlZCwgc28gZG9uJ3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdC5cblx0XHQgICAgICAgICAgICByZWFzb24gPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfcHJvbWlzZTogdW5kZWZpbmVkLFxuXHRcdCAgICAgICAgICAgICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcblx0XHQgICAgICAgICAgICAgICAgX3JlamVjdDogcmVqZWN0LFxuXHRcdCAgICAgICAgICAgICAgICBfcmVhc29uOiByZWFzb24sXG5cdFx0ICAgICAgICAgICAgICAgIF93YXNBbHJlYWR5RXJyb3Jpbmc6IHdhc0FscmVhZHlFcnJvcmluZ1xuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcHJvbWlzZSA9IHByb21pc2U7XG5cdFx0ICAgICAgICBpZiAoIXdhc0FscmVhZHlFcnJvcmluZykge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIHJlYXNvbik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbSkge1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtzdGF0ZX0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgd3JpdGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBjbG9zZWRgKSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgY2xvc2VSZXF1ZXN0ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcblx0XHQgICAgICAgICAgICAgICAgX3JlamVjdDogcmVqZWN0XG5cdFx0ICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IGNsb3NlUmVxdWVzdDtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG5cdFx0ICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9iYWNrcHJlc3N1cmUgJiYgc3RhdGUgPT09ICd3cml0YWJsZScpIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKTtcblx0XHQgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFdyaXRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3Qoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgd3JpdGVSZXF1ZXN0ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcblx0XHQgICAgICAgICAgICAgICAgX3JlamVjdDogcmVqZWN0XG5cdFx0ICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMucHVzaCh3cml0ZVJlcXVlc3QpO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIGVycm9yKTtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yaW5nJztcblx0XHQgICAgICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSByZWFzb247XG5cdFx0ICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcblx0XHQgICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodChzdHJlYW0pICYmIGNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pIHtcblx0XHQgICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JlZCc7XG5cdFx0ICAgICAgICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcltFcnJvclN0ZXBzXSgpO1xuXHRcdCAgICAgICAgY29uc3Qgc3RvcmVkRXJyb3IgPSBzdHJlYW0uX3N0b3JlZEVycm9yO1xuXHRcdCAgICAgICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzLmZvckVhY2god3JpdGVSZXF1ZXN0ID0+IHtcblx0XHQgICAgICAgICAgICB3cml0ZVJlcXVlc3QuX3JlamVjdChzdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IGFib3J0UmVxdWVzdCA9IHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdDtcblx0XHQgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGlmIChhYm9ydFJlcXVlc3QuX3dhc0FscmVhZHlFcnJvcmluZykge1xuXHRcdCAgICAgICAgICAgIGFib3J0UmVxdWVzdC5fcmVqZWN0KHN0b3JlZEVycm9yKTtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgcHJvbWlzZSA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Fib3J0U3RlcHNdKGFib3J0UmVxdWVzdC5fcmVhc29uKTtcblx0XHQgICAgICAgIHVwb25Qcm9taXNlKHByb21pc2UsICgpID0+IHtcblx0XHQgICAgICAgICAgICBhYm9ydFJlcXVlc3QuX3Jlc29sdmUoKTtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9LCAocmVhc29uKSA9PiB7XG5cdFx0ICAgICAgICAgICAgYWJvcnRSZXF1ZXN0Ll9yZWplY3QocmVhc29uKTtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0Ll9yZXNvbHZlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW0sIGVycm9yKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlKHN0cmVhbSkge1xuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdC5fcmVzb2x2ZSh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuXHRcdCAgICAgICAgICAgIC8vIFRoZSBlcnJvciB3YXMgdG9vIGxhdGUgdG8gZG8gYW55dGhpbmcsIHNvIGl0IGlzIGlnbm9yZWQuXG5cdFx0ICAgICAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9yZXNvbHZlKCk7XG5cdFx0ICAgICAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG5cdFx0ICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcblx0XHQgICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW0sIGVycm9yKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIC8vIE5ldmVyIGV4ZWN1dGUgc2luayBhYm9ydCgpIGFmdGVyIHNpbmsgY2xvc2UoKS5cblx0XHQgICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcmVqZWN0KGVycm9yKTtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFRPRE8ocmljZWEpOiBGaXggYWxwaGFiZXRpY2FsIG9yZGVyLlxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSkge1xuXHRcdCAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHN0cmVhbS5fY2xvc2VSZXF1ZXN0O1xuXHRcdCAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pIHtcblx0XHQgICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSBzdHJlYW0uX3dyaXRlUmVxdWVzdHMuc2hpZnQoKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSkge1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fY2xvc2VSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdC5fcmVqZWN0KHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG5cdFx0ICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKSB7XG5cdFx0ICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcblx0XHQgICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCAmJiBiYWNrcHJlc3N1cmUgIT09IHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKGJhY2twcmVzc3VyZSkge1xuXHRcdCAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXQod3JpdGVyKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBiYWNrcHJlc3N1cmU7XG5cdFx0ICAgIH1cblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEEgZGVmYXVsdCB3cml0ZXIgdmVuZGVkIGJ5IGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtfS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuXHRcdCAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyJyk7XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0V3JpdGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHdyaXRpbmcgYnkgYW5vdGhlciB3cml0ZXInKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9IHN0cmVhbTtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX3dyaXRlciA9IHRoaXM7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHRoaXMpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcblx0XHQgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHRoaXMsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuXHRcdCAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBzdG9yZWRFcnJvciA9IHN0cmVhbS5fc3RvcmVkRXJyb3I7XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3Jcblx0XHQgICAgICAgICAqIHRoZSB3cml0ZXLigJlzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGNsb3NlZCgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgc3RyZWFt4oCZcyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXMgb3Zlci1mdWxsLlxuXHRcdCAgICAgICAgICogQSBwcm9kdWNlciBjYW4gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHRoZSByaWdodCBhbW91bnQgb2YgZGF0YSB0byB3cml0ZS5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBJdCB3aWxsIGJlIGBudWxsYCBpZiB0aGUgc3RyZWFtIGNhbm5vdCBiZSBzdWNjZXNzZnVsbHkgd3JpdHRlbiB0byAoZHVlIHRvIGVpdGhlciBiZWluZyBlcnJvcmVkLCBvciBoYXZpbmcgYW4gYWJvcnRcblx0XHQgICAgICAgICAqIHF1ZXVlZCB1cCkuIEl0IHdpbGwgcmV0dXJuIHplcm8gaWYgdGhlIHN0cmVhbSBpcyBjbG9zZWQuIEFuZCB0aGUgZ2V0dGVyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGludm9rZWQgd2hlblxuXHRcdCAgICAgICAgICogdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZC5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgc3RyZWFt4oCZcyBpbnRlcm5hbCBxdWV1ZSB0cmFuc2l0aW9uc1xuXHRcdCAgICAgICAgICogZnJvbSBub24tcG9zaXRpdmUgdG8gcG9zaXRpdmUsIHNpZ25hbGluZyB0aGF0IGl0IGlzIG5vIGxvbmdlciBhcHBseWluZyBiYWNrcHJlc3N1cmUuIE9uY2UgdGhlIGRlc2lyZWQgc2l6ZSBkaXBzXG5cdFx0ICAgICAgICAgKiBiYWNrIHRvIHplcm8gb3IgYmVsb3csIHRoZSBnZXR0ZXIgd2lsbCByZXR1cm4gYSBuZXcgcHJvbWlzZSB0aGF0IHN0YXlzIHBlbmRpbmcgdW50aWwgdGhlIG5leHQgdHJhbnNpdGlvbi5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBJZiB0aGUgc3RyZWFtIGJlY29tZXMgZXJyb3JlZCBvciBhYm9ydGVkLCBvciB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlY29tZVxuXHRcdCAgICAgICAgICogcmVqZWN0ZWQuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCByZWFkeSgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkeScpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5UHJvbWlzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFdyaXRhYmxlU3RyZWFtLmFib3J0IHwgc3RyZWFtLmFib3J0KHJlYXNvbil9LlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBhYm9ydChyZWFzb24gPSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdhYm9ydCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignYWJvcnQnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCh0aGlzLCByZWFzb24pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgV3JpdGFibGVTdHJlYW0uY2xvc2UgfCBzdHJlYW0uY2xvc2UoKX0uXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGNsb3NlKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignY2xvc2UnKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2UodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJlbGVhc2VzIHRoZSB3cml0ZXLigJlzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHdyaXRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuXHRcdCAgICAgICAgICogSWYgdGhlIGFzc29jaWF0ZWQgc3RyZWFtIGlzIGVycm9yZWQgd2hlbiB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHdyaXRlciB3aWxsIGFwcGVhciBlcnJvcmVkIGluIHRoZSBzYW1lIHdheSBmcm9tXG5cdFx0ICAgICAgICAgKiBub3cgb247IG90aGVyd2lzZSwgdGhlIHdyaXRlciB3aWxsIGFwcGVhciBjbG9zZWQuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBsb2NrIGNhbiBzdGlsbCBiZSByZWxlYXNlZCBldmVuIGlmIHNvbWUgb25nb2luZyB3cml0ZXMgaGF2ZSBub3QgeWV0IGZpbmlzaGVkIChpLmUuIGV2ZW4gaWYgdGhlXG5cdFx0ICAgICAgICAgKiBwcm9taXNlcyByZXR1cm5lZCBmcm9tIHByZXZpb3VzIGNhbGxzIHRvIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIud3JpdGUgfCB3cml0ZSgpfSBoYXZlIG5vdCB5ZXQgc2V0dGxlZCkuXG5cdFx0ICAgICAgICAgKiBJdOKAmXMgbm90IG5lY2Vzc2FyeSB0byBob2xkIHRoZSBsb2NrIG9uIHRoZSB3cml0ZXIgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgd3JpdGU7IHRoZSBsb2NrIGluc3RlYWQgc2ltcGx5IHByZXZlbnRzXG5cdFx0ICAgICAgICAgKiBvdGhlciBwcm9kdWNlcnMgZnJvbSB3cml0aW5nIGluIGFuIGludGVybGVhdmVkIG1hbm5lci5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgcmVsZWFzZUxvY2soKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcblx0XHQgICAgICAgICAgICBpZiAoc3RyZWFtID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgd3JpdGUoY2h1bmsgPSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCd3cml0ZScpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignd3JpdGUgdG8nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh0aGlzLCBjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgd3JpdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHJlYWR5OiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuXHRcdCAgICAgICAgICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19vd25lcldyaXRhYmxlU3RyZWFtJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBIGNsaWVudCBvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCh3cml0ZXIsIHJlYXNvbikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoc3RyZWFtLCByZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHdyaXRlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uKHdyaXRlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgfHwgc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2Uod3JpdGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCBlcnJvcikge1xuXHRcdCAgICAgICAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID09PSAncGVuZGluZycpIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgZXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgZXJyb3IpIHtcblx0XHQgICAgICAgIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID09PSAncGVuZGluZycpIHtcblx0XHQgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgZXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIGVycm9yKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh3cml0ZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIDA7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHdyaXRlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgY29uc3QgcmVsZWFzZWRFcnJvciA9IG5ldyBUeXBlRXJyb3IoYFdyaXRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCk7XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlbGVhc2VkRXJyb3IpO1xuXHRcdCAgICAgICAgLy8gVGhlIHN0YXRlIHRyYW5zaXRpb25zIHRvIFwiZXJyb3JlZFwiIGJlZm9yZSB0aGUgc2luayBhYm9ydCgpIG1ldGhvZCBydW5zLCBidXQgdGhlIHdyaXRlci5jbG9zZWQgcHJvbWlzZSBpcyBub3Rcblx0XHQgICAgICAgIC8vIHJlamVjdGVkIHVudGlsIGFmdGVyd2FyZHMuIFRoaXMgbWVhbnMgdGhhdCBzaW1wbHkgdGVzdGluZyBzdGF0ZSB3aWxsIG5vdCB3b3JrLlxuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVsZWFzZWRFcnJvcik7XG5cdFx0ICAgICAgICBzdHJlYW0uX3dyaXRlciA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSA9IHVuZGVmaW5lZDtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh3cml0ZXIsIGNodW5rKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICBjb25zdCBjaHVua1NpemUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplKGNvbnRyb2xsZXIsIGNodW5rKTtcblx0XHQgICAgICAgIGlmIChzdHJlYW0gIT09IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCd3cml0ZSB0bycpKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB8fCBzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIGNsb3Npbmcgb3IgY2xvc2VkIGFuZCBjYW5ub3QgYmUgd3JpdHRlbiB0bycpKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgcHJvbWlzZSA9IFdyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0KHN0cmVhbSk7XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyV3JpdGUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG5cdFx0ICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0XHQgICAgfVxuXHRcdCAgICBjb25zdCBjbG9zZVNlbnRpbmVsID0ge307XG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBXcml0YWJsZVN0cmVhbSB8IHdyaXRhYmxlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEBwdWJsaWNcblx0XHQgICAgICovXG5cdFx0ICAgIGNsYXNzIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IoKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBUaGUgcmVhc29uIHdoaWNoIHdhcyBwYXNzZWQgdG8gYFdyaXRhYmxlU3RyZWFtLmFib3J0KHJlYXNvbilgIHdoZW4gdGhlIHN0cmVhbSB3YXMgYWJvcnRlZC5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBAZGVwcmVjYXRlZFxuXHRcdCAgICAgICAgICogIFRoaXMgcHJvcGVydHkgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBzcGVjaWZpY2F0aW9uLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9zdHJlYW1zL3B1bGwvMTE3Ny5cblx0XHQgICAgICAgICAqICBVc2Uge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuc2lnbmFsfSdzIGByZWFzb25gIGluc3RlYWQuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCBhYm9ydFJlYXNvbigpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMignYWJvcnRSZWFzb24nKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0UmVhc29uO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBBbiBgQWJvcnRTaWduYWxgIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWJvcnQgdGhlIHBlbmRpbmcgd3JpdGUgb3IgY2xvc2Ugb3BlcmF0aW9uIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm9ydGVkLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgc2lnbmFsKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdzaWduYWwnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuX2Fib3J0Q29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIC8vIE9sZGVyIGJyb3dzZXJzIG9yIG9sZGVyIE5vZGUgdmVyc2lvbnMgbWF5IG5vdCBzdXBwb3J0IGBBYm9ydENvbnRyb2xsZXJgIG9yIGBBYm9ydFNpZ25hbGAuXG5cdFx0ICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYnVuZGxlIGFuZCBzaGlwIGFuIGBBYm9ydENvbnRyb2xsZXJgIHBvbHlmaWxsIHRvZ2V0aGVyIHdpdGggb3VyIHBvbHlmaWxsLFxuXHRcdCAgICAgICAgICAgICAgICAvLyBzbyBpbnN0ZWFkIHdlIG9ubHkgaW1wbGVtZW50IHN1cHBvcnQgZm9yIGBzaWduYWxgIGlmIHdlIGZpbmQgYSBnbG9iYWwgYEFib3J0Q29udHJvbGxlcmAgY29uc3RydWN0b3IuXG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLnNpZ25hbCBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBDbG9zZXMgdGhlIGNvbnRyb2xsZWQgd3JpdGFibGUgc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZSBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyByYXJlbHkgdXNlZCwgc2luY2UgdXN1YWxseSBpdCBzdWZmaWNlcyB0byByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIGZyb20gb25lIG9mIHRoZSB1bmRlcmx5aW5nXG5cdFx0ICAgICAgICAgKiBzaW5rJ3MgbWV0aG9kcy4gSG93ZXZlciwgaXQgY2FuIGJlIHVzZWZ1bCBmb3Igc3VkZGVubHkgc2h1dHRpbmcgZG93biBhIHN0cmVhbSBpbiByZXNwb25zZSB0byBhbiBldmVudCBvdXRzaWRlIHRoZVxuXHRcdCAgICAgICAgICogbm9ybWFsIGxpZmVjeWNsZSBvZiBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgdW5kZXJseWluZyBzaW5rLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBlcnJvcihlID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2Vycm9yJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgICAgICBpZiAoc3RhdGUgIT09ICd3cml0YWJsZScpIHtcblx0XHQgICAgICAgICAgICAgICAgLy8gVGhlIHN0cmVhbSBpcyBjbG9zZWQsIGVycm9yZWQgb3Igd2lsbCBiZSBzb29uLiBUaGUgc2luayBjYW4ndCBkbyBhbnl0aGluZyB1c2VmdWwgaWYgaXQgZ2V0cyBhbiBlcnJvciBoZXJlLCBzb1xuXHRcdCAgICAgICAgICAgICAgICAvLyBqdXN0IHRyZWF0IGl0IGFzIGEgbm8tb3AuXG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIGUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuXHRcdCAgICAgICAgW0Fib3J0U3RlcHNdKHJlYXNvbikge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2Fib3J0QWxnb3JpdGhtKHJlYXNvbik7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuXHRcdCAgICAgICAgW0Vycm9yU3RlcHNdKCkge1xuXHRcdCAgICAgICAgICAgIFJlc2V0UXVldWUodGhpcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcblx0XHQgICAgICAgIGFib3J0UmVhc29uOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHNpZ25hbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH1cblx0XHQgICAgfSk7XG5cdFx0ICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgaW1wbGVtZW50aW5nIGludGVyZmFjZSByZXF1aXJlZCBieSB0aGUgV3JpdGFibGVTdHJlYW0uXG5cdFx0ICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbSA9IHN0cmVhbTtcblx0XHQgICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcblx0XHQgICAgICAgIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxuXHRcdCAgICAgICAgY29udHJvbGxlci5fcXVldWUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9hYm9ydFJlYXNvbiA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2Fib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcigpO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gc2l6ZUFsZ29yaXRobTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtID0gd3JpdGVBbGdvcml0aG07XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSA9IGNsb3NlQWxnb3JpdGhtO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fYWJvcnRBbGdvcml0aG0gPSBhYm9ydEFsZ29yaXRobTtcblx0XHQgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG5cdFx0ICAgICAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICBjb25zdCBzdGFydFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KTtcblx0XHQgICAgICAgIHVwb25Qcm9taXNlKHN0YXJ0UHJvbWlzZSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH0sIHIgPT4ge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCByKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayhzdHJlYW0sIHVuZGVybHlpbmdTaW5rLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBsZXQgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBsZXQgd3JpdGVBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBsZXQgY2xvc2VBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBsZXQgYWJvcnRBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ1Npbmsuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1Npbmsuc3RhcnQoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ1Npbmsud3JpdGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHdyaXRlQWxnb3JpdGhtID0gY2h1bmsgPT4gdW5kZXJseWluZ1Npbmsud3JpdGUoY2h1bmssIGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHVuZGVybHlpbmdTaW5rLmNsb3NlICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBjbG9zZUFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTaW5rLmNsb3NlKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ1NpbmsuYWJvcnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGFib3J0QWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdTaW5rLmFib3J0KHJlYXNvbik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQ2xlYXJBbGdvcml0aG1zIG1heSBiZSBjYWxsZWQgdHdpY2UuIEVycm9yaW5nIHRoZSBzYW1lIHN0cmVhbSBpbiBtdWx0aXBsZSB3YXlzIHdpbGwgb2Z0ZW4gcmVzdWx0IGluIHJlZHVuZGFudCBjYWxscy5cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fYWJvcnRBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNsb3NlU2VudGluZWwsIDApO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemUoY29udHJvbGxlciwgY2h1bmspIHtcblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjYXRjaCAoY2h1bmtTaXplRSkge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGNodW5rU2l6ZUUpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiAxO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyV3JpdGUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSkge1xuXHRcdCAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNhdGNoIChlbnF1ZXVlRSkge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGVucXVldWVFKTtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgaWYgKCFjb250cm9sbGVyLl9zdGFydGVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgdmFsdWUgPSBQZWVrUXVldWVWYWx1ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGlmICh2YWx1ZSA9PT0gY2xvc2VTZW50aW5lbCkge1xuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlKGNvbnRyb2xsZXIsIHZhbHVlKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBlcnJvcikge1xuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcblx0XHQgICAgICAgIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgIGNvbnN0IHNpbmtDbG9zZVByb21pc2UgPSBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgIHVwb25Qcm9taXNlKHNpbmtDbG9zZVByb21pc2UsICgpID0+IHtcblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2Uoc3RyZWFtKTtcblx0XHQgICAgICAgIH0sIHJlYXNvbiA9PiB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzV3JpdGUoY29udHJvbGxlciwgY2h1bmspIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcblx0XHQgICAgICAgIFdyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcblx0XHQgICAgICAgIGNvbnN0IHNpbmtXcml0ZVByb21pc2UgPSBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobShjaHVuayk7XG5cdFx0ICAgICAgICB1cG9uUHJvbWlzZShzaW5rV3JpdGVQcm9taXNlLCAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlKHN0cmVhbSk7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgICAgIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RhdGUgPT09ICd3cml0YWJsZScpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9LCByZWFzb24gPT4ge1xuXHRcdCAgICAgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW0sIHJlYXNvbik7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgcmV0dXJuIGRlc2lyZWRTaXplIDw9IDA7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gQSBjbGllbnQgb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG5cdFx0ICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlcnJvcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIGVycm9yKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW0uXG5cdFx0ICAgIGZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtYCk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyYCk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24obmFtZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCAnICsgbmFtZSArICcgYSBzdHJlYW0gdXNpbmcgYSByZWxlYXNlZCB3cml0ZXInKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKSB7XG5cdFx0ICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHQgICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0ICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcblx0XHQgICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdwZW5kaW5nJztcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcblx0XHQgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuXHRcdCAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyKSB7XG5cdFx0ICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcblx0XHQgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSh3cml0ZXIuX2Nsb3NlZFByb21pc2UpO1xuXHRcdCAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuXHRcdCAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncmVqZWN0ZWQnO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKSB7XG5cdFx0ICAgICAgICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZXNvbHZlZCc7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKSB7XG5cdFx0ICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdCAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuXHRcdCAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdwZW5kaW5nJztcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcblx0XHQgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG5cdFx0ICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyKSB7XG5cdFx0ICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuXHRcdCAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHdyaXRlci5fcmVhZHlQcm9taXNlKTtcblx0XHQgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdChyZWFzb24pO1xuXHRcdCAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAncmVqZWN0ZWQnO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXIpIHtcblx0XHQgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuXHRcdCAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpIHtcblx0XHQgICAgICAgIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdmdWxmaWxsZWQnO1xuXHRcdCAgICB9XG5cblx0XHQgICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cblx0XHQgICAgY29uc3QgTmF0aXZlRE9NRXhjZXB0aW9uID0gdHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBET01FeGNlcHRpb24gOiB1bmRlZmluZWQ7XG5cblx0XHQgICAgLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJub2RlXCIgLz5cblx0XHQgICAgZnVuY3Rpb24gaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvcihjdG9yKSB7XG5cdFx0ICAgICAgICBpZiAoISh0eXBlb2YgY3RvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY3RvciA9PT0gJ29iamVjdCcpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICBuZXcgY3RvcigpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY2F0Y2ggKF9hKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNyZWF0ZURPTUV4Y2VwdGlvblBvbHlmaWxsKCkge1xuXHRcdCAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuXHRcdCAgICAgICAgY29uc3QgY3RvciA9IGZ1bmN0aW9uIERPTUV4Y2VwdGlvbihtZXNzYWdlLCBuYW1lKSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcblx0XHQgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICdFcnJvcic7XG5cdFx0ICAgICAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG5cdFx0ICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH07XG5cdFx0ICAgICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgeyB2YWx1ZTogY3Rvciwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblx0XHQgICAgICAgIHJldHVybiBjdG9yO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblx0XHQgICAgY29uc3QgRE9NRXhjZXB0aW9uJDEgPSBpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKE5hdGl2ZURPTUV4Y2VwdGlvbikgPyBOYXRpdmVET01FeGNlcHRpb24gOiBjcmVhdGVET01FeGNlcHRpb25Qb2x5ZmlsbCgpO1xuXG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUGlwZVRvKHNvdXJjZSwgZGVzdCwgcHJldmVudENsb3NlLCBwcmV2ZW50QWJvcnQsIHByZXZlbnRDYW5jZWwsIHNpZ25hbCkge1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzb3VyY2UpO1xuXHRcdCAgICAgICAgY29uc3Qgd3JpdGVyID0gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcihkZXN0KTtcblx0XHQgICAgICAgIHNvdXJjZS5fZGlzdHVyYmVkID0gdHJ1ZTtcblx0XHQgICAgICAgIGxldCBzaHV0dGluZ0Rvd24gPSBmYWxzZTtcblx0XHQgICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBzcGVjJ3MgcmVxdWlyZW1lbnQgdGhhdCB3ZSB3YWl0IGZvciBvbmdvaW5nIHdyaXRlcyBkdXJpbmcgc2h1dGRvd24uXG5cdFx0ICAgICAgICBsZXQgY3VycmVudFdyaXRlID0gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdCAgICAgICAgICAgIGxldCBhYm9ydEFsZ29yaXRobTtcblx0XHQgICAgICAgICAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0gPSAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBET01FeGNlcHRpb24kMSgnQWJvcnRlZCcsICdBYm9ydEVycm9yJyk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb25zID0gW107XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRBYm9ydCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCgoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgZXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHNvdXJjZSwgZXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUHJvbWlzZS5hbGwoYWN0aW9ucy5tYXAoYWN0aW9uID0+IGFjdGlvbigpKSksIHRydWUsIGVycm9yKTtcblx0XHQgICAgICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBhYm9ydEFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QWxnb3JpdGhtKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgLy8gVXNpbmcgcmVhZGVyIGFuZCB3cml0ZXIsIHJlYWQgYWxsIGNodW5rcyBmcm9tIHRoaXMgYW5kIHdyaXRlIHRoZW0gdG8gZGVzdFxuXHRcdCAgICAgICAgICAgIC8vIC0gQmFja3ByZXNzdXJlIG11c3QgYmUgZW5mb3JjZWRcblx0XHQgICAgICAgICAgICAvLyAtIFNodXRkb3duIG11c3Qgc3RvcCBhbGwgYWN0aXZpdHlcblx0XHQgICAgICAgICAgICBmdW5jdGlvbiBwaXBlTG9vcCgpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmVMb29wLCByZWplY3RMb29wKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBuZXh0KGRvbmUpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlTG9vcCgpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGBQZXJmb3JtUHJvbWlzZVRoZW5gIGluc3RlYWQgb2YgYHVwb25Qcm9taXNlYCB0byBhdm9pZFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRpbmcgdW5uZWNlc3NhcnkgYC5jYXRjaChyZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pYCBoYW5kbGVyc1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBQZXJmb3JtUHJvbWlzZVRoZW4ocGlwZVN0ZXAoKSwgbmV4dCwgcmVqZWN0TG9vcCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgbmV4dChmYWxzZSk7XG5cdFx0ICAgICAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBmdW5jdGlvbiBwaXBlU3RlcCgpIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodHJ1ZSk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbih3cml0ZXIuX3JlYWR5UHJvbWlzZSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmVSZWFkLCByZWplY3RSZWFkKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXcml0ZSA9IFBlcmZvcm1Qcm9taXNlVGhlbihXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh3cml0ZXIsIGNodW5rKSwgdW5kZWZpbmVkLCBub29wKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVSZWFkKGZhbHNlKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHJlc29sdmVSZWFkKHRydWUpLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogcmVqZWN0UmVhZFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAvLyBFcnJvcnMgbXVzdCBiZSBwcm9wYWdhdGVkIGZvcndhcmRcblx0XHQgICAgICAgICAgICBpc09yQmVjb21lc0Vycm9yZWQoc291cmNlLCByZWFkZXIuX2Nsb3NlZFByb21pc2UsIHN0b3JlZEVycm9yID0+IHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBXcml0YWJsZVN0cmVhbUFib3J0KGRlc3QsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgLy8gRXJyb3JzIG11c3QgYmUgcHJvcGFnYXRlZCBiYWNrd2FyZFxuXHRcdCAgICAgICAgICAgIGlzT3JCZWNvbWVzRXJyb3JlZChkZXN0LCB3cml0ZXIuX2Nsb3NlZFByb21pc2UsIHN0b3JlZEVycm9yID0+IHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBzdG9yZWRFcnJvciksIHRydWUsIHN0b3JlZEVycm9yKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHNodXRkb3duKHRydWUsIHN0b3JlZEVycm9yKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIC8vIENsb3NpbmcgbXVzdCBiZSBwcm9wYWdhdGVkIGZvcndhcmRcblx0XHQgICAgICAgICAgICBpc09yQmVjb21lc0Nsb3NlZChzb3VyY2UsIHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDbG9zZSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24od3JpdGVyKSk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bigpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgLy8gQ2xvc2luZyBtdXN0IGJlIHByb3BhZ2F0ZWQgYmFja3dhcmRcblx0XHQgICAgICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkgfHwgZGVzdC5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RDbG9zZWQgPSBuZXcgVHlwZUVycm9yKCd0aGUgZGVzdGluYXRpb24gd3JpdGFibGUgc3RyZWFtIGNsb3NlZCBiZWZvcmUgYWxsIGRhdGEgY291bGQgYmUgcGlwZWQgdG8gaXQnKTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBkZXN0Q2xvc2VkKSwgdHJ1ZSwgZGVzdENsb3NlZCk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bih0cnVlLCBkZXN0Q2xvc2VkKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHBpcGVMb29wKCkpO1xuXHRcdCAgICAgICAgICAgIGZ1bmN0aW9uIHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpIHtcblx0XHQgICAgICAgICAgICAgICAgLy8gQW5vdGhlciB3cml0ZSBtYXkgaGF2ZSBzdGFydGVkIHdoaWxlIHdlIHdlcmUgd2FpdGluZyBvbiB0aGlzIGN1cnJlbnRXcml0ZSwgc28gd2UgaGF2ZSB0byBiZSBzdXJlIHRvIHdhaXRcblx0XHQgICAgICAgICAgICAgICAgLy8gZm9yIHRoYXQgdG9vLlxuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBvbGRDdXJyZW50V3JpdGUgPSBjdXJyZW50V3JpdGU7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4oY3VycmVudFdyaXRlLCAoKSA9PiBvbGRDdXJyZW50V3JpdGUgIT09IGN1cnJlbnRXcml0ZSA/IHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpIDogdW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZnVuY3Rpb24gaXNPckJlY29tZXNFcnJvcmVkKHN0cmVhbSwgcHJvbWlzZSwgYWN0aW9uKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGFjdGlvbihzdHJlYW0uX3N0b3JlZEVycm9yKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHVwb25SZWplY3Rpb24ocHJvbWlzZSwgYWN0aW9uKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBmdW5jdGlvbiBpc09yQmVjb21lc0Nsb3NlZChzdHJlYW0sIHByb21pc2UsIGFjdGlvbikge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGFjdGlvbigpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHByb21pc2UsIGFjdGlvbik7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZnVuY3Rpb24gc2h1dGRvd25XaXRoQWN0aW9uKGFjdGlvbiwgb3JpZ2luYWxJc0Vycm9yLCBvcmlnaW5hbEVycm9yKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBzaHV0dGluZ0Rvd24gPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScgJiYgIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksIGRvVGhlUmVzdCk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBkb1RoZVJlc3QoKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb1RoZVJlc3QoKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB1cG9uUHJvbWlzZShhY3Rpb24oKSwgKCkgPT4gZmluYWxpemUob3JpZ2luYWxJc0Vycm9yLCBvcmlnaW5hbEVycm9yKSwgbmV3RXJyb3IgPT4gZmluYWxpemUodHJ1ZSwgbmV3RXJyb3IpKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBmdW5jdGlvbiBzaHV0ZG93bihpc0Vycm9yLCBlcnJvcikge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnICYmICFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpLCAoKSA9PiBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcikpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgZmluYWxpemUoaXNFcnJvciwgZXJyb3IpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2Uod3JpdGVyKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QWxnb3JpdGhtKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cblx0XHQgICAgLyoqXG5cdFx0ICAgICAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciB7XG5cdFx0ICAgICAgICBjb25zdHJ1Y3RvcigpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBjb250cm9sbGVkIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpc1xuXHRcdCAgICAgICAgICogb3Zlci1mdWxsLiBBbiB1bmRlcmx5aW5nIHNvdXJjZSBvdWdodCB0byB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgd2hlbiBhbmQgaG93IHRvIGFwcGx5IGJhY2twcmVzc3VyZS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdkZXNpcmVkU2l6ZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBDbG9zZXMgdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLiBDb25zdW1lcnMgd2lsbCBzdGlsbCBiZSBhYmxlIHRvIHJlYWQgYW55IHByZXZpb3VzbHktZW5xdWV1ZWQgY2h1bmtzIGZyb21cblx0XHQgICAgICAgICAqIHRoZSBzdHJlYW0sIGJ1dCBvbmNlIHRob3NlIGFyZSByZWFkLCB0aGUgc3RyZWFtIHdpbGwgYmVjb21lIGNsb3NlZC5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgY2xvc2UoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2Nsb3NlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGNsb3NlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVucXVldWUoY2h1bmsgPSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZW5xdWV1ZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBlbnF1ZXVlJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBlcnJvcihlID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2Vycm9yJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cblx0XHQgICAgICAgIFtDYW5jZWxTdGVwc10ocmVhc29uKSB7XG5cdFx0ICAgICAgICAgICAgUmVzZXRRdWV1ZSh0aGlzKTtcblx0XHQgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKiogQGludGVybmFsICovXG5cdFx0ICAgICAgICBbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCkge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblx0XHQgICAgICAgICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IERlcXVldWVWYWx1ZSh0aGlzKTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKGNodW5rKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgZW5xdWV1ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cblx0XHQgICAgfSk7XG5cdFx0ICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXHRcdCAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoeCkge1xuXHRcdCAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbScpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IHNob3VsZFB1bGwgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICBpZiAoIXNob3VsZFB1bGwpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuXHRcdCAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IHRydWU7XG5cdFx0ICAgICAgICBjb25zdCBwdWxsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0oKTtcblx0XHQgICAgICAgIHVwb25Qcm9taXNlKHB1bGxQcm9taXNlLCAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsQWdhaW4pIHtcblx0XHQgICAgICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0sIGUgPT4ge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG5cdFx0ICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgaWYgKGRlc2lyZWRTaXplID4gMCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBIGNsaWVudCBvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG5cdFx0ICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblx0XHQgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGNodW5rLCBmYWxzZSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBsZXQgY2h1bmtTaXplO1xuXHRcdCAgICAgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNodW5rU2l6ZSA9IGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNhdGNoIChjaHVua1NpemVFKSB7XG5cdFx0ICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBjaHVua1NpemVFKTtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgY2h1bmtTaXplRTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICAgICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNhdGNoIChlbnF1ZXVlRSkge1xuXHRcdCAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZW5xdWV1ZUUpO1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBlbnF1ZXVlRTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSkge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcblx0XHQgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gMDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneUhXTSAtIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFRoaXMgaXMgdXNlZCBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVHJhbnNmb3JtU3RyZWFtLlxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpIHtcblx0XHQgICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcikpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xuXHRcdCAgICAgICAgaWYgKCFjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCAmJiBzdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSA9IHN0cmVhbTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSBmYWxzZTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gc2l6ZUFsZ29yaXRobTtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gY2FuY2VsQWxnb3JpdGhtO1xuXHRcdCAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXHRcdCAgICAgICAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgdXBvblByb21pc2UocHJvbWlzZVJlc29sdmVkV2l0aChzdGFydFJlc3VsdCksICgpID0+IHtcblx0XHQgICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH0sIHIgPT4ge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCByKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKHN0cmVhbSwgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuXHRcdCAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuXHRcdCAgICAgICAgbGV0IHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgbGV0IHB1bGxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICBsZXQgY2FuY2VsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NvdXJjZS5zdGFydChjb250cm9sbGVyKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh1bmRlcmx5aW5nU291cmNlLnB1bGwgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHB1bGxBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU291cmNlLnB1bGwoY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS5jYW5jZWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobSA9IHJlYXNvbiA9PiB1bmRlcmx5aW5nU291cmNlLmNhbmNlbChyZWFzb24pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVRlZShzdHJlYW0sIGNsb25lRm9yQnJhbmNoMikge1xuXHRcdCAgICAgICAgaWYgKElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtVGVlKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0VGVlKHN0cmVhbSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0VGVlKHN0cmVhbSwgY2xvbmVGb3JCcmFuY2gyKSB7XG5cdFx0ICAgICAgICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG5cdFx0ICAgICAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IHJlYWRBZ2FpbiA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IGNhbmNlbGVkMSA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IGNhbmNlbGVkMiA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IHJlYXNvbjE7XG5cdFx0ICAgICAgICBsZXQgcmVhc29uMjtcblx0XHQgICAgICAgIGxldCBicmFuY2gxO1xuXHRcdCAgICAgICAgbGV0IGJyYW5jaDI7XG5cdFx0ICAgICAgICBsZXQgcmVzb2x2ZUNhbmNlbFByb21pc2U7XG5cdFx0ICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHQgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSA9IHJlc29sdmU7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKHJlYWRpbmcpIHtcblx0XHQgICAgICAgICAgICAgICAgcmVhZEFnYWluID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmVhZGluZyA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XG5cdFx0ICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIHN5bmNocm9ub3VzbHktYXZhaWxhYmxlIHJlYWRzIGdldCBhaGVhZCBvZiBhc3luY2hyb25vdXNseS1hdmFpbGFibGUgZXJyb3JzLlxuXHRcdCAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbiA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rMSA9IGNodW5rO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rMiA9IGNodW5rO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHdheSB0byBhY2Nlc3MgdGhlIGNsb25pbmcgY29kZSByaWdodCBub3cgaW4gdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi5cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhZGQgb25lIHRoZW4gd2UnbGwgbmVlZCBhbiBpbXBsZW1lbnRhdGlvbiBmb3Igc2VyaWFsaXphYmxlIG9iamVjdHMuXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCFjYW5jZWxlZDIgJiYgY2xvbmVGb3JCcmFuY2gyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjaHVuazIgPSBTdHJ1Y3R1cmVkRGVzZXJpYWxpemUoU3RydWN0dXJlZFNlcmlhbGl6ZShjaHVuazIpKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazEpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEFnYWluKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxBbGdvcml0aG0oKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICAgICAgfSxcblx0XHQgICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIH0sXG5cdFx0ICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9O1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uKSB7XG5cdFx0ICAgICAgICAgICAgY2FuY2VsZWQxID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICByZWFzb24xID0gcmVhc29uO1xuXHRcdCAgICAgICAgICAgIGlmIChjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG5cdFx0ICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gY2FuY2VsMkFsZ29yaXRobShyZWFzb24pIHtcblx0XHQgICAgICAgICAgICBjYW5jZWxlZDIgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIHJlYXNvbjIgPSByZWFzb247XG5cdFx0ICAgICAgICAgICAgaWYgKGNhbmNlbGVkMSkge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcblx0XHQgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpIHtcblx0XHQgICAgICAgICAgICAvLyBkbyBub3RoaW5nXG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBicmFuY2gxID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xuXHRcdCAgICAgICAgYnJhbmNoMiA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwyQWxnb3JpdGhtKTtcblx0XHQgICAgICAgIHVwb25SZWplY3Rpb24ocmVhZGVyLl9jbG9zZWRQcm9taXNlLCAocikgPT4ge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuXHRcdCAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHJldHVybiBbYnJhbmNoMSwgYnJhbmNoMl07XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtVGVlKHN0cmVhbSkge1xuXHRcdCAgICAgICAgbGV0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcblx0XHQgICAgICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICBsZXQgcmVhZEFnYWluRm9yQnJhbmNoMSA9IGZhbHNlO1xuXHRcdCAgICAgICAgbGV0IHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcblx0XHQgICAgICAgIGxldCBjYW5jZWxlZDEgPSBmYWxzZTtcblx0XHQgICAgICAgIGxldCBjYW5jZWxlZDIgPSBmYWxzZTtcblx0XHQgICAgICAgIGxldCByZWFzb24xO1xuXHRcdCAgICAgICAgbGV0IHJlYXNvbjI7XG5cdFx0ICAgICAgICBsZXQgYnJhbmNoMTtcblx0XHQgICAgICAgIGxldCBicmFuY2gyO1xuXHRcdCAgICAgICAgbGV0IHJlc29sdmVDYW5jZWxQcm9taXNlO1xuXHRcdCAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IG5ld1Byb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0ICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UgPSByZXNvbHZlO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgICAgICBmdW5jdGlvbiBmb3J3YXJkUmVhZGVyRXJyb3IodGhpc1JlYWRlcikge1xuXHRcdCAgICAgICAgICAgIHVwb25SZWplY3Rpb24odGhpc1JlYWRlci5fY2xvc2VkUHJvbWlzZSwgciA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmICh0aGlzUmVhZGVyICE9PSByZWFkZXIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcblx0XHQgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG5cdFx0ICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIHB1bGxXaXRoRGVmYXVsdFJlYWRlcigpIHtcblx0XHQgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuXHRcdCAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcblx0XHQgICAgICAgICAgICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRSZXF1ZXN0ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcblx0XHQgICAgICAgICAgICAgICAgICAgIC8vIHJlYWRlci5fY2xvc2VkUHJvbWlzZSBiZWxvdyksIGFuZCB3ZSB3YW50IGVycm9ycyBpbiBzdHJlYW0gdG8gZXJyb3IgYm90aCBicmFuY2hlcyBpbW1lZGlhdGVseS4gV2UgY2Fubm90IGxldFxuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSByZWFkcyBnZXQgYWhlYWQgb2YgYXN5bmNocm9ub3VzbHktYXZhaWxhYmxlIGVycm9ycy5cblx0XHQgICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rMSA9IGNodW5rO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaHVuazIgPSBjaHVuaztcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSAmJiAhY2FuY2VsZWQyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazIgPSBDbG9uZUFzVWludDhBcnJheShjaHVuayk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGNsb25lRSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNsb25lRSkpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsxKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazIpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDEpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbDFBbGdvcml0aG0oKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVhZEFnYWluRm9yQnJhbmNoMikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsMkFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICB9LFxuXHRcdCAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gcHVsbFdpdGhCWU9CUmVhZGVyKHZpZXcsIGZvckJyYW5jaDIpIHtcblx0XHQgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuXHRcdCAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKTtcblx0XHQgICAgICAgICAgICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IGJ5b2JCcmFuY2ggPSBmb3JCcmFuY2gyID8gYnJhbmNoMiA6IGJyYW5jaDE7XG5cdFx0ICAgICAgICAgICAgY29uc3Qgb3RoZXJCcmFuY2ggPSBmb3JCcmFuY2gyID8gYnJhbmNoMSA6IGJyYW5jaDI7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcmVhZEludG9SZXF1ZXN0ID0ge1xuXHRcdCAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcblx0XHQgICAgICAgICAgICAgICAgICAgIC8vIHJlYWRlci5fY2xvc2VkUHJvbWlzZSBiZWxvdyksIGFuZCB3ZSB3YW50IGVycm9ycyBpbiBzdHJlYW0gdG8gZXJyb3IgYm90aCBicmFuY2hlcyBpbW1lZGlhdGVseS4gV2UgY2Fubm90IGxldFxuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSByZWFkcyBnZXQgYWhlYWQgb2YgYXN5bmNocm9ub3VzbHktYXZhaWxhYmxlIGVycm9ycy5cblx0XHQgICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5b2JDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDIgOiBjYW5jZWxlZDE7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDEgOiBjYW5jZWxlZDI7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlckNhbmNlbGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbG9uZWRDaHVuaztcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZENodW5rID0gQ2xvbmVBc1VpbnQ4QXJyYXkoY2h1bmspO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChjbG9uZUUpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3Iob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY2xvbmVFKSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVkQ2h1bmspO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYnlvYkNhbmNlbGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEFnYWluRm9yQnJhbmNoMSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsMUFsZ29yaXRobSgpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGwyQWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgIH0sXG5cdFx0ICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiBjaHVuayA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBjb25zdCBieW9iQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQyIDogY2FuY2VsZWQxO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDEgOiBjYW5jZWxlZDI7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlckNhbmNlbGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQgJiYgb3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkIHx8ICFvdGhlckNhbmNlbGVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgfSxcblx0XHQgICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZChyZWFkZXIsIHZpZXcsIHJlYWRJbnRvUmVxdWVzdCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBmdW5jdGlvbiBwdWxsMUFsZ29yaXRobSgpIHtcblx0XHQgICAgICAgICAgICBpZiAocmVhZGluZykge1xuXHRcdCAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmVhZGluZyA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgY29uc3QgYnlvYlJlcXVlc3QgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcblx0XHQgICAgICAgICAgICBpZiAoYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcblx0XHQgICAgICAgICAgICAgICAgcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICBwdWxsV2l0aEJZT0JSZWFkZXIoYnlvYlJlcXVlc3QuX3ZpZXcsIGZhbHNlKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIHB1bGwyQWxnb3JpdGhtKCkge1xuXHRcdCAgICAgICAgICAgIGlmIChyZWFkaW5nKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZWFkaW5nID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICBjb25zdCBieW9iUmVxdWVzdCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgICAgIGlmIChieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuXHRcdCAgICAgICAgICAgICAgICBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIHB1bGxXaXRoQllPQlJlYWRlcihieW9iUmVxdWVzdC5fdmlldywgdHJ1ZSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBmdW5jdGlvbiBjYW5jZWwxQWxnb3JpdGhtKHJlYXNvbikge1xuXHRcdCAgICAgICAgICAgIGNhbmNlbGVkMSA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgcmVhc29uMSA9IHJlYXNvbjtcblx0XHQgICAgICAgICAgICBpZiAoY2FuY2VsZWQyKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuXHRcdCAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIGNhbmNlbDJBbGdvcml0aG0ocmVhc29uKSB7XG5cdFx0ICAgICAgICAgICAgY2FuY2VsZWQyID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICByZWFzb24yID0gcmVhc29uO1xuXHRcdCAgICAgICAgICAgIGlmIChjYW5jZWxlZDEpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG5cdFx0ICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbDFBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xuXHRcdCAgICAgICAgYnJhbmNoMiA9IENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbDJBbGdvcml0aG0sIGNhbmNlbDJBbGdvcml0aG0pO1xuXHRcdCAgICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG5cdFx0ICAgICAgICByZXR1cm4gW2JyYW5jaDEsIGJyYW5jaDJdO1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlKHNvdXJjZSwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShzb3VyY2UsIGNvbnRleHQpO1xuXHRcdCAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBzb3VyY2U7XG5cdFx0ICAgICAgICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuXHRcdCAgICAgICAgY29uc3QgY2FuY2VsID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmNhbmNlbDtcblx0XHQgICAgICAgIGNvbnN0IHB1bGwgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwucHVsbDtcblx0XHQgICAgICAgIGNvbnN0IHN0YXJ0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnN0YXJ0O1xuXHRcdCAgICAgICAgY29uc3QgdHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC50eXBlO1xuXHRcdCAgICAgICAgcmV0dXJuIHtcblx0XHQgICAgICAgICAgICBhdXRvQWxsb2NhdGVDaHVua1NpemU6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYXV0b0FsbG9jYXRlQ2h1bmtTaXplJyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgY2FuY2VsOiBjYW5jZWwgPT09IHVuZGVmaW5lZCA/XG5cdFx0ICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soY2FuY2VsLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2FuY2VsJyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgcHVsbDogcHVsbCA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2socHVsbCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3B1bGwnIHRoYXRgKSxcblx0XHQgICAgICAgICAgICBzdGFydDogc3RhcnQgPT09IHVuZGVmaW5lZCA/XG5cdFx0ICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgdHlwZTogdHlwZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSh0eXBlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd0eXBlJyB0aGF0YClcblx0XHQgICAgICAgIH07XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiAocmVhc29uKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVN0cmVhbVR5cGUodHlwZSwgY29udGV4dCkge1xuXHRcdCAgICAgICAgdHlwZSA9IGAke3R5cGV9YDtcblx0XHQgICAgICAgIGlmICh0eXBlICE9PSAnYnl0ZXMnKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSAnJHt0eXBlfScgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtVHlwZWApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHR5cGU7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGVyT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuXHRcdCAgICAgICAgY29uc3QgbW9kZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlO1xuXHRcdCAgICAgICAgcmV0dXJuIHtcblx0XHQgICAgICAgICAgICBtb2RlOiBtb2RlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlKG1vZGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ21vZGUnIHRoYXRgKVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlKG1vZGUsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIG1vZGUgPSBgJHttb2RlfWA7XG5cdFx0ICAgICAgICBpZiAobW9kZSAhPT0gJ2J5b2InKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSAnJHttb2RlfScgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZWApO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIG1vZGU7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0SXRlcmF0b3JPcHRpb25zKG9wdGlvbnMsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG5cdFx0ICAgICAgICBjb25zdCBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRDYW5jZWw7XG5cdFx0ICAgICAgICByZXR1cm4geyBwcmV2ZW50Q2FuY2VsOiBCb29sZWFuKHByZXZlbnRDYW5jZWwpIH07XG5cdFx0ICAgIH1cblxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0UGlwZU9wdGlvbnMob3B0aW9ucywgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcblx0XHQgICAgICAgIGNvbnN0IHByZXZlbnRBYm9ydCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV2ZW50QWJvcnQ7XG5cdFx0ICAgICAgICBjb25zdCBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRDYW5jZWw7XG5cdFx0ICAgICAgICBjb25zdCBwcmV2ZW50Q2xvc2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENsb3NlO1xuXHRcdCAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbDtcblx0XHQgICAgICAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2lnbmFsJyB0aGF0YCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgICAgIHByZXZlbnRBYm9ydDogQm9vbGVhbihwcmV2ZW50QWJvcnQpLFxuXHRcdCAgICAgICAgICAgIHByZXZlbnRDYW5jZWw6IEJvb2xlYW4ocHJldmVudENhbmNlbCksXG5cdFx0ICAgICAgICAgICAgcHJldmVudENsb3NlOiBCb29sZWFuKHByZXZlbnRDbG9zZSksXG5cdFx0ICAgICAgICAgICAgc2lnbmFsXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgaWYgKCFpc0Fib3J0U2lnbmFsKHNpZ25hbCkpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBBYm9ydFNpZ25hbC5gKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcihwYWlyLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KHBhaXIsIGNvbnRleHQpO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGFibGUgPSBwYWlyID09PSBudWxsIHx8IHBhaXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhaXIucmVhZGFibGU7XG5cdFx0ICAgICAgICBhc3NlcnRSZXF1aXJlZEZpZWxkKHJlYWRhYmxlLCAncmVhZGFibGUnLCAnUmVhZGFibGVXcml0YWJsZVBhaXInKTtcblx0XHQgICAgICAgIGFzc2VydFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdyZWFkYWJsZScgdGhhdGApO1xuXHRcdCAgICAgICAgY29uc3Qgd3JpdGFibGUgPSBwYWlyID09PSBudWxsIHx8IHBhaXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhaXIud3JpdGFibGU7XG5cdFx0ICAgICAgICBhc3NlcnRSZXF1aXJlZEZpZWxkKHdyaXRhYmxlLCAnd3JpdGFibGUnLCAnUmVhZGFibGVXcml0YWJsZVBhaXInKTtcblx0XHQgICAgICAgIGFzc2VydFdyaXRhYmxlU3RyZWFtKHdyaXRhYmxlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd3cml0YWJsZScgdGhhdGApO1xuXHRcdCAgICAgICAgcmV0dXJuIHsgcmVhZGFibGUsIHdyaXRhYmxlIH07XG5cdFx0ICAgIH1cblxuXHRcdCAgICAvKipcblx0XHQgICAgICogQSByZWFkYWJsZSBzdHJlYW0gcmVwcmVzZW50cyBhIHNvdXJjZSBvZiBkYXRhLCBmcm9tIHdoaWNoIHlvdSBjYW4gcmVhZC5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgUmVhZGFibGVTdHJlYW0ge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IocmF3VW5kZXJseWluZ1NvdXJjZSA9IHt9LCByYXdTdHJhdGVneSA9IHt9KSB7XG5cdFx0ICAgICAgICAgICAgaWYgKHJhd1VuZGVybHlpbmdTb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICByYXdVbmRlcmx5aW5nU291cmNlID0gbnVsbDtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGFzc2VydE9iamVjdChyYXdVbmRlcmx5aW5nU291cmNlLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBjb25zdCB1bmRlcmx5aW5nU291cmNlID0gY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlKHJhd1VuZGVybHlpbmdTb3VyY2UsICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0odGhpcyk7XG5cdFx0ICAgICAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2UudHlwZSA9PT0gJ2J5dGVzJykge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoc3RyYXRlZ3kuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHN0cmF0ZWd5IGZvciBhIGJ5dGUgc3RyZWFtIGNhbm5vdCBoYXZlIGEgc2l6ZSBmdW5jdGlvbicpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMCk7XG5cdFx0ICAgICAgICAgICAgICAgIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKHRoaXMsIHVuZGVybHlpbmdTb3VyY2UsIGhpZ2hXYXRlck1hcmspO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHN0cmF0ZWd5KTtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAxKTtcblx0XHQgICAgICAgICAgICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UodGhpcywgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmVhZGFibGUgc3RyZWFtIGlzIGxvY2tlZCB0byBhIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgfCByZWFkZXJ9LlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgbG9ja2VkKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2xvY2tlZCcpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogQ2FuY2VscyB0aGUgc3RyZWFtLCBzaWduYWxpbmcgYSBsb3NzIG9mIGludGVyZXN0IGluIHRoZSBzdHJlYW0gYnkgYSBjb25zdW1lci5cblx0XHQgICAgICAgICAqXG5cdFx0ICAgICAgICAgKiBUaGUgc3VwcGxpZWQgYHJlYXNvbmAgYXJndW1lbnQgd2lsbCBiZSBnaXZlbiB0byB0aGUgdW5kZXJseWluZyBzb3VyY2UncyB7QGxpbmsgVW5kZXJseWluZ1NvdXJjZS5jYW5jZWwgfCBjYW5jZWwoKX1cblx0XHQgICAgICAgICAqIG1ldGhvZCwgd2hpY2ggbWlnaHQgb3IgbWlnaHQgbm90IHVzZSBpdC5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgY2FuY2VsKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2NhbmNlbCcpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbmNlbCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgcmVhZGVyJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwodGhpcywgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGdldFJlYWRlcihyYXdPcHRpb25zID0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZ2V0UmVhZGVyJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0UmVhZGVyT3B0aW9ucyhyYXdPcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMubW9kZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHBpcGVUaHJvdWdoKHJhd1RyYW5zZm9ybSwgcmF3T3B0aW9ucyA9IHt9KSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgncGlwZVRocm91Z2gnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChyYXdUcmFuc2Zvcm0sIDEsICdwaXBlVGhyb3VnaCcpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcihyYXdUcmFuc2Zvcm0sICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRyYW5zZm9ybS53cml0YWJsZSkpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFdyaXRhYmxlU3RyZWFtJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBSZWFkYWJsZVN0cmVhbVBpcGVUbyh0aGlzLCB0cmFuc2Zvcm0ud3JpdGFibGUsIG9wdGlvbnMucHJldmVudENsb3NlLCBvcHRpb25zLnByZXZlbnRBYm9ydCwgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsLCBvcHRpb25zLnNpZ25hbCk7XG5cdFx0ICAgICAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwcm9taXNlKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtLnJlYWRhYmxlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcGlwZVRvKGRlc3RpbmF0aW9uLCByYXdPcHRpb25zID0ge30pIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdwaXBlVG8nKSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGBQYXJhbWV0ZXIgMSBpcyByZXF1aXJlZCBpbiAncGlwZVRvJy5gKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKGRlc3RpbmF0aW9uKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvJ3MgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFdyaXRhYmxlU3RyZWFtYCkpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBsZXQgb3B0aW9ucztcblx0XHQgICAgICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgICAgICBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNhdGNoIChlKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJykpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChkZXN0aW5hdGlvbikpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbyBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbScpKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUGlwZVRvKHRoaXMsIGRlc3RpbmF0aW9uLCBvcHRpb25zLnByZXZlbnRDbG9zZSwgb3B0aW9ucy5wcmV2ZW50QWJvcnQsIG9wdGlvbnMucHJldmVudENhbmNlbCwgb3B0aW9ucy5zaWduYWwpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBUZWVzIHRoaXMgcmVhZGFibGUgc3RyZWFtLCByZXR1cm5pbmcgYSB0d28tZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSB0d28gcmVzdWx0aW5nIGJyYW5jaGVzIGFzXG5cdFx0ICAgICAgICAgKiBuZXcge0BsaW5rIFJlYWRhYmxlU3RyZWFtfSBpbnN0YW5jZXMuXG5cdFx0ICAgICAgICAgKlxuXHRcdCAgICAgICAgICogVGVlaW5nIGEgc3RyZWFtIHdpbGwgbG9jayBpdCwgcHJldmVudGluZyBhbnkgb3RoZXIgY29uc3VtZXIgZnJvbSBhY3F1aXJpbmcgYSByZWFkZXIuXG5cdFx0ICAgICAgICAgKiBUbyBjYW5jZWwgdGhlIHN0cmVhbSwgY2FuY2VsIGJvdGggb2YgdGhlIHJlc3VsdGluZyBicmFuY2hlczsgYSBjb21wb3NpdGUgY2FuY2VsbGF0aW9uIHJlYXNvbiB3aWxsIHRoZW4gYmVcblx0XHQgICAgICAgICAqIHByb3BhZ2F0ZWQgdG8gdGhlIHN0cmVhbSdzIHVuZGVybHlpbmcgc291cmNlLlxuXHRcdCAgICAgICAgICpcblx0XHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgY2h1bmtzIHNlZW4gaW4gZWFjaCBicmFuY2ggd2lsbCBiZSB0aGUgc2FtZSBvYmplY3QuIElmIHRoZSBjaHVua3MgYXJlIG5vdCBpbW11dGFibGUsXG5cdFx0ICAgICAgICAgKiB0aGlzIGNvdWxkIGFsbG93IGludGVyZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gYnJhbmNoZXMuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIHRlZSgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCd0ZWUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY29uc3QgYnJhbmNoZXMgPSBSZWFkYWJsZVN0cmVhbVRlZSh0aGlzKTtcblx0XHQgICAgICAgICAgICByZXR1cm4gQ3JlYXRlQXJyYXlGcm9tTGlzdChicmFuY2hlcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICB2YWx1ZXMocmF3T3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3ZhbHVlcycpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udmVydEl0ZXJhdG9yT3B0aW9ucyhyYXdPcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcywgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIHtcblx0XHQgICAgICAgIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBnZXRSZWFkZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcGlwZVRocm91Z2g6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgcGlwZVRvOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIHRlZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICB2YWx1ZXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgbG9ja2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbScsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLmFzeW5jSXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC5hc3luY0l0ZXJhdG9yLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6IFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS52YWx1ZXMsXG5cdFx0ICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cdFx0ICAgIC8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG5cdFx0ICAgIGZ1bmN0aW9uIENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmsgPSAxLCBzaXplQWxnb3JpdGhtID0gKCkgPT4gMSkge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuXHRcdCAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG5cdFx0ICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcblx0XHQgICAgICAgIHJldHVybiBzdHJlYW07XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gVGhyb3dzIGlmIGFuZCBvbmx5IGlmIHN0YXJ0QWxnb3JpdGhtIHRocm93cy5cblx0XHQgICAgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0pIHtcblx0XHQgICAgICAgIGNvbnN0IHN0cmVhbSA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlKTtcblx0XHQgICAgICAgIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbShzdHJlYW0pO1xuXHRcdCAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xuXHRcdCAgICAgICAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgMCwgdW5kZWZpbmVkKTtcblx0XHQgICAgICAgIHJldHVybiBzdHJlYW07XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuXHRcdCAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICdyZWFkYWJsZSc7XG5cdFx0ICAgICAgICBzdHJlYW0uX3JlYWRlciA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IGZhbHNlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW0oeCkge1xuXHRcdCAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcicpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkge1xuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fcmVhZGVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBSZWFkYWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgcmVhc29uKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cdFx0ICAgICAgICBpZiAocmVhZGVyICE9PSB1bmRlZmluZWQgJiYgSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuXHRcdCAgICAgICAgICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKHJlYWRJbnRvUmVxdWVzdCA9PiB7XG5cdFx0ICAgICAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyh1bmRlZmluZWQpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3Qgc291cmNlQ2FuY2VsUHJvbWlzZSA9IHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW0NhbmNlbFN0ZXBzXShyZWFzb24pO1xuXHRcdCAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHNvdXJjZUNhbmNlbFByb21pc2UsIG5vb3ApO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG5cdFx0ICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcblx0XHQgICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpO1xuXHRcdCAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcblx0XHQgICAgICAgICAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cy5mb3JFYWNoKHJlYWRSZXF1ZXN0ID0+IHtcblx0XHQgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKSB7XG5cdFx0ICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yZWQnO1xuXHRcdCAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IGU7XG5cdFx0ICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcblx0XHQgICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgZSk7XG5cdFx0ICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuXHRcdCAgICAgICAgICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzLmZvckVhY2gocmVhZFJlcXVlc3QgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmZvckVhY2gocmVhZEludG9SZXF1ZXN0ID0+IHtcblx0XHQgICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cblx0XHQgICAgZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKG5hbWUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1gKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KGluaXQsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydERpY3Rpb25hcnkoaW5pdCwgY29udGV4dCk7XG5cdFx0ICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmhpZ2hXYXRlck1hcms7XG5cdFx0ICAgICAgICBhc3NlcnRSZXF1aXJlZEZpZWxkKGhpZ2hXYXRlck1hcmssICdoaWdoV2F0ZXJNYXJrJywgJ1F1ZXVpbmdTdHJhdGVneUluaXQnKTtcblx0XHQgICAgICAgIHJldHVybiB7XG5cdFx0ICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogY29udmVydFVucmVzdHJpY3RlZERvdWJsZShoaWdoV2F0ZXJNYXJrKVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIC8vIFRoZSBzaXplIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgbm9yIGJlIGEgY29uc3RydWN0b3Jcblx0XHQgICAgY29uc3QgYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiA9IChjaHVuaykgPT4ge1xuXHRcdCAgICAgICAgcmV0dXJuIGNodW5rLmJ5dGVMZW5ndGg7XG5cdFx0ICAgIH07XG5cdFx0ICAgIHRyeSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiwgJ25hbWUnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdzaXplJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNhdGNoIChfYSkge1xuXHRcdCAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBub24tY29uZmlndXJhYmxlIGluIG9sZGVyIGJyb3dzZXJzLCBzbyBpZ25vcmUgaWYgdGhpcyB0aHJvd3MuXG5cdFx0ICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuXHRcdCAgICB9XG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBIHF1ZXVpbmcgc3RyYXRlZ3kgdGhhdCBjb3VudHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiBlYWNoIGNodW5rLlxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcHVibGljXG5cdFx0ICAgICAqL1xuXHRcdCAgICBjbGFzcyBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHQgICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KG9wdGlvbnMsIDEsICdCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5Jyk7XG5cdFx0ICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KG9wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICB0aGlzLl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogUmV0dXJucyB0aGUgaGlnaCB3YXRlciBtYXJrIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGhpZ2hXYXRlck1hcmsoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24oJ2hpZ2hXYXRlck1hcmsnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBNZWFzdXJlcyB0aGUgc2l6ZSBvZiBgY2h1bmtgIGJ5IHJldHVybmluZyB0aGUgdmFsdWUgb2YgaXRzIGBieXRlTGVuZ3RoYCBwcm9wZXJ0eS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IHNpemUoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3NpemUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGJ5dGVMZW5ndGhTaXplRnVuY3Rpb247XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIHtcblx0XHQgICAgICAgIGhpZ2hXYXRlck1hcms6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgc2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cblx0XHQgICAgfSk7XG5cdFx0ICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5Jyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LlxuXHRcdCAgICBmdW5jdGlvbiBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneWApO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsnKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIC8vIFRoZSBzaXplIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgbm9yIGJlIGEgY29uc3RydWN0b3Jcblx0XHQgICAgY29uc3QgY291bnRTaXplRnVuY3Rpb24gPSAoKSA9PiB7XG5cdFx0ICAgICAgICByZXR1cm4gMTtcblx0XHQgICAgfTtcblx0XHQgICAgdHJ5IHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3VudFNpemVGdW5jdGlvbiwgJ25hbWUnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdzaXplJyxcblx0XHQgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNhdGNoIChfYSkge1xuXHRcdCAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBub24tY29uZmlndXJhYmxlIGluIG9sZGVyIGJyb3dzZXJzLCBzbyBpZ25vcmUgaWYgdGhpcyB0aHJvd3MuXG5cdFx0ICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuXHRcdCAgICB9XG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBIHF1ZXVpbmcgc3RyYXRlZ3kgdGhhdCBjb3VudHMgdGhlIG51bWJlciBvZiBjaHVua3MuXG5cdFx0ICAgICAqXG5cdFx0ICAgICAqIEBwdWJsaWNcblx0XHQgICAgICovXG5cdFx0ICAgIGNsYXNzIENvdW50UXVldWluZ1N0cmF0ZWd5IHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHQgICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KG9wdGlvbnMsIDEsICdDb3VudFF1ZXVpbmdTdHJhdGVneScpO1xuXHRcdCAgICAgICAgICAgIG9wdGlvbnMgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChvcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBoaWdoIHdhdGVyIG1hcmsgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgaGlnaFdhdGVyTWFyaygpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzQ291bnRRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKCdoaWdoV2F0ZXJNYXJrJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIE1lYXN1cmVzIHRoZSBzaXplIG9mIGBjaHVua2AgYnkgYWx3YXlzIHJldHVybmluZyAxLlxuXHRcdCAgICAgICAgICogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHRvdGFsIHF1ZXVlIHNpemUgaXMgYSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIGNodW5rcyBpbiB0aGUgcXVldWUuXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIGdldCBzaXplKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3NpemUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGNvdW50U2l6ZUZ1bmN0aW9uO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdFx0ICAgICAgICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdDb3VudFF1ZXVpbmdTdHJhdGVneScsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgQ291bnRRdWV1aW5nU3RyYXRlZ3kuXG5cdFx0ICAgIGZ1bmN0aW9uIGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIENvdW50UXVldWluZ1N0cmF0ZWd5YCk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh4KSB7XG5cdFx0ICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIENvdW50UXVldWluZ1N0cmF0ZWd5O1xuXHRcdCAgICB9XG5cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyKG9yaWdpbmFsLCBjb250ZXh0KSB7XG5cdFx0ICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9yaWdpbmFsLCBjb250ZXh0KTtcblx0XHQgICAgICAgIGNvbnN0IGZsdXNoID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmZsdXNoO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGFibGVUeXBlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnJlYWRhYmxlVHlwZTtcblx0XHQgICAgICAgIGNvbnN0IHN0YXJ0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnN0YXJ0O1xuXHRcdCAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnRyYW5zZm9ybTtcblx0XHQgICAgICAgIGNvbnN0IHdyaXRhYmxlVHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC53cml0YWJsZVR5cGU7XG5cdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgICAgIGZsdXNoOiBmbHVzaCA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayhmbHVzaCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2ZsdXNoJyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgcmVhZGFibGVUeXBlLFxuXHRcdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCA9PT0gdW5kZWZpbmVkID9cblx0XHQgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcblx0XHQgICAgICAgICAgICAgICAgY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG5cdFx0ICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gPT09IHVuZGVmaW5lZCA/XG5cdFx0ICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKHRyYW5zZm9ybSwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3RyYW5zZm9ybScgdGhhdGApLFxuXHRcdCAgICAgICAgICAgIHdyaXRhYmxlVHlwZVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcblx0XHQgICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcblx0XHQgICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuXHRcdCAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuXHRcdCAgICAgICAgcmV0dXJuIChjaHVuaywgY29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIC8vIENsYXNzIFRyYW5zZm9ybVN0cmVhbVxuXHRcdCAgICAvKipcblx0XHQgICAgICogQSB0cmFuc2Zvcm0gc3RyZWFtIGNvbnNpc3RzIG9mIGEgcGFpciBvZiBzdHJlYW1zOiBhIHtAbGluayBXcml0YWJsZVN0cmVhbSB8IHdyaXRhYmxlIHN0cmVhbX0sXG5cdFx0ICAgICAqIGtub3duIGFzIGl0cyB3cml0YWJsZSBzaWRlLCBhbmQgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBzdHJlYW19LCBrbm93biBhcyBpdHMgcmVhZGFibGUgc2lkZS5cblx0XHQgICAgICogSW4gYSBtYW5uZXIgc3BlY2lmaWMgdG8gdGhlIHRyYW5zZm9ybSBzdHJlYW0gaW4gcXVlc3Rpb24sIHdyaXRlcyB0byB0aGUgd3JpdGFibGUgc2lkZSByZXN1bHQgaW4gbmV3IGRhdGEgYmVpbmdcblx0XHQgICAgICogbWFkZSBhdmFpbGFibGUgZm9yIHJlYWRpbmcgZnJvbSB0aGUgcmVhZGFibGUgc2lkZS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgVHJhbnNmb3JtU3RyZWFtIHtcblx0XHQgICAgICAgIGNvbnN0cnVjdG9yKHJhd1RyYW5zZm9ybWVyID0ge30sIHJhd1dyaXRhYmxlU3RyYXRlZ3kgPSB7fSwgcmF3UmVhZGFibGVTdHJhdGVneSA9IHt9KSB7XG5cdFx0ICAgICAgICAgICAgaWYgKHJhd1RyYW5zZm9ybWVyID09PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgcmF3VHJhbnNmb3JtZXIgPSBudWxsO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBjb25zdCB3cml0YWJsZVN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdXcml0YWJsZVN0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlU3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1JlYWRhYmxlU3RyYXRlZ3ksICdUaGlyZCBwYXJhbWV0ZXInKTtcblx0XHQgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNvbnZlcnRUcmFuc2Zvcm1lcihyYXdUcmFuc2Zvcm1lciwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXHRcdCAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lci5yZWFkYWJsZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCByZWFkYWJsZVR5cGUgc3BlY2lmaWVkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lci53cml0YWJsZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB3cml0YWJsZVR5cGUgc3BlY2lmaWVkJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHJlYWRhYmxlU3RyYXRlZ3ksIDApO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHJlYWRhYmxlU3RyYXRlZ3kpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHdyaXRhYmxlU3RyYXRlZ3ksIDEpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHdyaXRhYmxlU3RyYXRlZ3kpO1xuXHRcdCAgICAgICAgICAgIGxldCBzdGFydFByb21pc2VfcmVzb2x2ZTtcblx0XHQgICAgICAgICAgICBjb25zdCBzdGFydFByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdCAgICAgICAgICAgICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbSh0aGlzLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG5cdFx0ICAgICAgICAgICAgU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcih0aGlzLCB0cmFuc2Zvcm1lcik7XG5cdFx0ICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodHJhbnNmb3JtZXIuc3RhcnQodGhpcy5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcikpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSB0cmFuc2Zvcm0gc3RyZWFtLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgcmVhZGFibGUoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkYWJsZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIFRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSB0cmFuc2Zvcm0gc3RyZWFtLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBnZXQgd3JpdGFibGUoKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbSh0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCd3cml0YWJsZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSwge1xuXHRcdCAgICAgICAgcmVhZGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgd3JpdGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuXHRcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW0nLFxuXHRcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbShzdHJlYW0sIHN0YXJ0UHJvbWlzZSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKSB7XG5cdFx0ICAgICAgICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gc3RhcnRQcm9taXNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZnVuY3Rpb24gd3JpdGVBbGdvcml0aG0oY2h1bmspIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobShzdHJlYW0sIGNodW5rKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIGFib3J0QWxnb3JpdGhtKHJlYXNvbikge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Fib3J0QWxnb3JpdGhtKHN0cmVhbSwgcmVhc29uKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGZ1bmN0aW9uIGNsb3NlQWxnb3JpdGhtKCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBzdHJlYW0uX3dyaXRhYmxlID0gQ3JlYXRlV3JpdGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtKTtcblx0XHQgICAgICAgIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBmdW5jdGlvbiBjYW5jZWxBbGdvcml0aG0ocmVhc29uKSB7XG5cdFx0ICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIHJlYXNvbik7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHN0cmVhbS5fcmVhZGFibGUgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG5cdFx0ICAgICAgICAvLyBUaGUgW1tiYWNrcHJlc3N1cmVdXSBzbG90IGlzIHNldCB0byB1bmRlZmluZWQgc28gdGhhdCBpdCBjYW4gYmUgaW5pdGlhbGlzZWQgYnkgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlLlxuXHRcdCAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIHRydWUpO1xuXHRcdCAgICAgICAgc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtKHgpIHtcblx0XHQgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ190cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyJykpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFRyYW5zZm9ybVN0cmVhbTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBUaGlzIGlzIGEgbm8tb3AgaWYgYm90aCBzaWRlcyBhcmUgYWxyZWFkeSBlcnJvcmVkLlxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIGUpIHtcblx0XHQgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGUpO1xuXHRcdCAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKSB7XG5cdFx0ICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoc3RyZWFtLl93cml0YWJsZS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLCBlKTtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuXHRcdCAgICAgICAgICAgIC8vIFByZXRlbmQgdGhhdCBwdWxsKCkgd2FzIGNhbGxlZCB0byBwZXJtaXQgYW55IHBlbmRpbmcgd3JpdGUoKSBjYWxscyB0byBjb21wbGV0ZS4gVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKClcblx0XHQgICAgICAgICAgICAvLyBjYW5ub3QgYmUgY2FsbGVkIGZyb20gZW5xdWV1ZSgpIG9yIHB1bGwoKSBvbmNlIHRoZSBSZWFkYWJsZVN0cmVhbSBpcyBlcnJvcmVkLCBzbyB0aGlzIHdpbGwgd2lsbCBiZSB0aGUgZmluYWwgdGltZVxuXHRcdCAgICAgICAgICAgIC8vIF9iYWNrcHJlc3N1cmUgaXMgc2V0LlxuXHRcdCAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGZhbHNlKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpIHtcblx0XHQgICAgICAgIC8vIFBhc3NlcyBhbHNvIHdoZW4gY2FsbGVkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXG5cdFx0ICAgICAgICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHQgICAgICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gYmFja3ByZXNzdXJlO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIENsYXNzIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyXG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBBbGxvd3MgY29udHJvbCBvZiB0aGUge0BsaW5rIFJlYWRhYmxlU3RyZWFtfSBhbmQge0BsaW5rIFdyaXRhYmxlU3RyZWFtfSBvZiB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgVHJhbnNmb3JtU3RyZWFtfS5cblx0XHQgICAgICpcblx0XHQgICAgICogQHB1YmxpY1xuXHRcdCAgICAgKi9cblx0XHQgICAgY2xhc3MgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIge1xuXHRcdCAgICAgICAgY29uc3RydWN0b3IoKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgcmVhZGFibGUgc2lkZeKAmXMgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzIG92ZXItZnVsbC5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlQ29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZW5xdWV1ZShjaHVuayA9IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogRXJyb3JzIGJvdGggdGhlIHJlYWRhYmxlIHNpZGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlXG5cdFx0ICAgICAgICAgKiBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC4gQW55IGNodW5rcyBxdWV1ZWQgZm9yIHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgZGlzY2FyZGVkLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBlcnJvcihyZWFzb24gPSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIHJlYXNvbik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvKipcblx0XHQgICAgICAgICAqIENsb3NlcyB0aGUgcmVhZGFibGUgc2lkZSBhbmQgZXJyb3JzIHRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0uIFRoaXMgaXMgdXNlZnVsIHdoZW4gdGhlXG5cdFx0ICAgICAgICAgKiB0cmFuc2Zvcm1lciBvbmx5IG5lZWRzIHRvIGNvbnN1bWUgYSBwb3J0aW9uIG9mIHRoZSBjaHVua3Mgd3JpdHRlbiB0byB0aGUgd3JpdGFibGUgc2lkZS5cblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgdGVybWluYXRlKCkge1xuXHRcdCAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3Rlcm1pbmF0ZScpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclRlcm1pbmF0ZSh0aGlzKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcblx0XHQgICAgICAgIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRcdCAgICAgICAgdGVybWluYXRlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0XHQgICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG5cdFx0ICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG5cdFx0ICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBUcmFuc2Zvcm0gU3RyZWFtIERlZmF1bHQgQ29udHJvbGxlciBBYnN0cmFjdCBPcGVyYXRpb25zXG5cdFx0ICAgIGZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoeCkge1xuXHRcdCAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0nKSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHRyYW5zZm9ybUFsZ29yaXRobSwgZmx1c2hBbGdvcml0aG0pIHtcblx0XHQgICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0gPSBzdHJlYW07XG5cdFx0ICAgICAgICBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtID0gdHJhbnNmb3JtQWxnb3JpdGhtO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0gPSBmbHVzaEFsZ29yaXRobTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVRyYW5zZm9ybWVyKHN0cmVhbSwgdHJhbnNmb3JtZXIpIHtcblx0XHQgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cdFx0ICAgICAgICBsZXQgdHJhbnNmb3JtQWxnb3JpdGhtID0gKGNodW5rKSA9PiB7XG5cdFx0ICAgICAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKTtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgY2F0Y2ggKHRyYW5zZm9ybVJlc3VsdEUpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodHJhbnNmb3JtUmVzdWx0RSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgICAgIGxldCBmbHVzaEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgICAgIGlmICh0cmFuc2Zvcm1lci50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIHRyYW5zZm9ybUFsZ29yaXRobSA9IGNodW5rID0+IHRyYW5zZm9ybWVyLnRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAodHJhbnNmb3JtZXIuZmx1c2ggIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGZsdXNoQWxnb3JpdGhtID0gKCkgPT4gdHJhbnNmb3JtZXIuZmx1c2goY29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgdHJhbnNmb3JtQWxnb3JpdGhtLCBmbHVzaEFsZ29yaXRobSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG5cdFx0ICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtO1xuXHRcdCAgICAgICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuXHRcdCAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUocmVhZGFibGVDb250cm9sbGVyKSkge1xuXHRcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlIHNpZGUgaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWUnKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIFdlIHRocm90dGxlIHRyYW5zZm9ybSBpbnZvY2F0aW9ucyBiYXNlZCBvbiB0aGUgYmFja3ByZXNzdXJlIG9mIHRoZSBSZWFkYWJsZVN0cmVhbSwgYnV0IHdlIHN0aWxsXG5cdFx0ICAgICAgICAvLyBhY2NlcHQgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKCkgY2FsbHMuXG5cdFx0ICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHJlYWRhYmxlQ29udHJvbGxlciwgY2h1bmspO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY2F0Y2ggKGUpIHtcblx0XHQgICAgICAgICAgICAvLyBUaGlzIGhhcHBlbnMgd2hlbiByZWFkYWJsZVN0cmF0ZWd5LnNpemUoKSB0aHJvd3MuXG5cdFx0ICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpO1xuXHRcdCAgICAgICAgICAgIHRocm93IHN0cmVhbS5fcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckhhc0JhY2twcmVzc3VyZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgaWYgKGJhY2twcmVzc3VyZSAhPT0gc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCB0cnVlKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpIHtcblx0XHQgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0sIGUpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuaykge1xuXHRcdCAgICAgICAgY29uc3QgdHJhbnNmb3JtUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobShjaHVuayk7XG5cdFx0ICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgodHJhbnNmb3JtUHJvbWlzZSwgdW5kZWZpbmVkLCByID0+IHtcblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLCByKTtcblx0XHQgICAgICAgICAgICB0aHJvdyByO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUoY29udHJvbGxlcikge1xuXHRcdCAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcblx0XHQgICAgICAgIGNvbnN0IHJlYWRhYmxlQ29udHJvbGxlciA9IHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtcblx0XHQgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuXHRcdCAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKCdUcmFuc2Zvcm1TdHJlYW0gdGVybWluYXRlZCcpO1xuXHRcdCAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGVycm9yKTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2luayBBbGdvcml0aG1zXG5cdFx0ICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rV3JpdGVBbGdvcml0aG0oc3RyZWFtLCBjaHVuaykge1xuXHRcdCAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcblx0XHQgICAgICAgIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2U7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKGJhY2twcmVzc3VyZUNoYW5nZVByb21pc2UsICgpID0+IHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3Qgd3JpdGFibGUgPSBzdHJlYW0uX3dyaXRhYmxlO1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHdyaXRhYmxlLl9zdGF0ZTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyB3cml0YWJsZS5fc3RvcmVkRXJyb3I7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuayk7XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtKGNvbnRyb2xsZXIsIGNodW5rKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Fib3J0QWxnb3JpdGhtKHN0cmVhbSwgcmVhc29uKSB7XG5cdFx0ICAgICAgICAvLyBhYm9ydCgpIGlzIG5vdCBjYWxsZWQgc3luY2hyb25vdXNseSwgc28gaXQgaXMgcG9zc2libGUgZm9yIGFib3J0KCkgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHN0cmVhbSBpcyBhbHJlYWR5XG5cdFx0ICAgICAgICAvLyBlcnJvcmVkLlxuXHRcdCAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCByZWFzb24pO1xuXHRcdCAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblx0XHQgICAgfVxuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtKHN0cmVhbSkge1xuXHRcdCAgICAgICAgLy8gc3RyZWFtLl9yZWFkYWJsZSBjYW5ub3QgY2hhbmdlIGFmdGVyIGNvbnN0cnVjdGlvbiwgc28gY2FjaGluZyBpdCBhY3Jvc3MgYSBjYWxsIHRvIHVzZXIgY29kZSBpcyBzYWZlLlxuXHRcdCAgICAgICAgY29uc3QgcmVhZGFibGUgPSBzdHJlYW0uX3JlYWRhYmxlO1xuXHRcdCAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcblx0XHQgICAgICAgIGNvbnN0IGZsdXNoUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtKCk7XG5cdFx0ICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcblx0XHQgICAgICAgIC8vIFJldHVybiBhIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWQgb24gc3VjY2Vzcy5cblx0XHQgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChmbHVzaFByb21pc2UsICgpID0+IHtcblx0XHQgICAgICAgICAgICBpZiAocmVhZGFibGUuX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG5cdFx0ICAgICAgICB9LCByID0+IHtcblx0XHQgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIHIpO1xuXHRcdCAgICAgICAgICAgIHRocm93IHJlYWRhYmxlLl9zdG9yZWRFcnJvcjtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2UgQWxnb3JpdGhtc1xuXHRcdCAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobShzdHJlYW0pIHtcblx0XHQgICAgICAgIC8vIEludmFyaWFudC4gRW5mb3JjZWQgYnkgdGhlIHByb21pc2VzIHJldHVybmVkIGJ5IHN0YXJ0KCkgYW5kIHB1bGwoKS5cblx0XHQgICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGZhbHNlKTtcblx0XHQgICAgICAgIC8vIFByZXZlbnQgdGhlIG5leHQgcHVsbCgpIGNhbGwgdW50aWwgdGhlcmUgaXMgYmFja3ByZXNzdXJlLlxuXHRcdCAgICAgICAgcmV0dXJuIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cdFx0ICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG5cdFx0ICAgIH1cblx0XHQgICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFRyYW5zZm9ybVN0cmVhbS5cblx0XHQgICAgZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBUcmFuc2Zvcm1TdHJlYW1gKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGV4cG9ydHMuQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSA9IEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3k7XG5cdFx0ICAgIGV4cG9ydHMuQ291bnRRdWV1aW5nU3RyYXRlZ3kgPSBDb3VudFF1ZXVpbmdTdHJhdGVneTtcblx0XHQgICAgZXhwb3J0cy5SZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcblx0XHQgICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbSA9IFJlYWRhYmxlU3RyZWFtO1xuXHRcdCAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciA9IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcblx0XHQgICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0ID0gUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcblx0XHQgICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcblx0XHQgICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI7XG5cdFx0ICAgIGV4cG9ydHMuVHJhbnNmb3JtU3RyZWFtID0gVHJhbnNmb3JtU3RyZWFtO1xuXHRcdCAgICBleHBvcnRzLlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG5cdFx0ICAgIGV4cG9ydHMuV3JpdGFibGVTdHJlYW0gPSBXcml0YWJsZVN0cmVhbTtcblx0XHQgICAgZXhwb3J0cy5Xcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcblx0XHQgICAgZXhwb3J0cy5Xcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI7XG5cblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRcdH0pKSk7XG5cdFx0XG59IChwb255ZmlsbF9lczIwMTgsIHBvbnlmaWxsX2VzMjAxOC5leHBvcnRzKSk7XG5cdHJldHVybiBwb255ZmlsbF9lczIwMTguZXhwb3J0cztcbn1cblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5cbi8vIDY0IEtpQiAoc2FtZSBzaXplIGNocm9tZSBzbGljZSB0aGVpcnMgYmxvYiBpbnRvIFVpbnQ4YXJyYXkncylcbmNvbnN0IFBPT0xfU0laRSQxID0gNjU1MzY7XG5cbmlmICghZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSkge1xuICAvLyBgbm9kZTpzdHJlYW0vd2ViYCBnb3QgaW50cm9kdWNlZCBpbiB2MTYuNS4wIGFzIGV4cGVyaW1lbnRhbFxuICAvLyBhbmQgaXQncyBwcmVmZXJyZWQgb3ZlciB0aGUgcG9seWZpbGxlZCB2ZXJzaW9uLiBTbyB3ZSBhbHNvXG4gIC8vIHN1cHByZXNzIHRoZSB3YXJuaW5nIHRoYXQgZ2V0cyBlbWl0dGVkIGJ5IE5vZGVKUyBmb3IgdXNpbmcgaXQuXG4gIHRyeSB7XG4gICAgY29uc3QgcHJvY2VzcyA9IHJlcXVpcmUoJ25vZGU6cHJvY2VzcycpO1xuICAgIGNvbnN0IHsgZW1pdFdhcm5pbmcgfSA9IHByb2Nlc3M7XG4gICAgdHJ5IHtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcgPSAoKSA9PiB7fTtcbiAgICAgIE9iamVjdC5hc3NpZ24oZ2xvYmFsVGhpcywgcmVxdWlyZSgnbm9kZTpzdHJlYW0vd2ViJykpO1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyA9IGVtaXRXYXJuaW5nO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nID0gZW1pdFdhcm5pbmc7XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBmYWxsYmFjayB0byBwb2x5ZmlsbCBpbXBsZW1lbnRhdGlvblxuICAgIE9iamVjdC5hc3NpZ24oZ2xvYmFsVGhpcywgcmVxdWlyZVBvbnlmaWxsX2VzMjAxOCgpKTtcbiAgfVxufVxuXG50cnkge1xuICAvLyBEb24ndCB1c2Ugbm9kZTogcHJlZml4IGZvciB0aGlzLCByZXF1aXJlK25vZGU6IGlzIG5vdCBzdXBwb3J0ZWQgdW50aWwgbm9kZSB2MTQuMTRcbiAgLy8gT25seSBgaW1wb3J0KClgIGNhbiB1c2UgcHJlZml4IGluIDEyLjIwIGFuZCBsYXRlclxuICBjb25zdCB7IEJsb2IgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuICBpZiAoQmxvYiAmJiAhQmxvYi5wcm90b3R5cGUuc3RyZWFtKSB7XG4gICAgQmxvYi5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24gbmFtZSAocGFyYW1zKSB7XG4gICAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgICAgY29uc3QgYmxvYiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICBhc3luYyBwdWxsIChjdHJsKSB7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBibG9iLnNsaWNlKHBvc2l0aW9uLCBNYXRoLm1pbihibG9iLnNpemUsIHBvc2l0aW9uICsgUE9PTF9TSVpFJDEpKTtcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjaHVuay5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgIHBvc2l0aW9uICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGN0cmwuZW5xdWV1ZShuZXcgVWludDhBcnJheShidWZmZXIpKTtcblxuICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gYmxvYi5zaXplKSB7XG4gICAgICAgICAgICBjdHJsLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH1cbn0gY2F0Y2ggKGVycm9yKSB7fVxuXG4vKiEgZmV0Y2gtYmxvYi4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cblxuLy8gNjQgS2lCIChzYW1lIHNpemUgY2hyb21lIHNsaWNlIHRoZWlycyBibG9iIGludG8gVWludDhhcnJheSdzKVxuY29uc3QgUE9PTF9TSVpFID0gNjU1MzY7XG5cbi8qKiBAcGFyYW0geyhCbG9iIHwgVWludDhBcnJheSlbXX0gcGFydHMgKi9cbmFzeW5jIGZ1bmN0aW9uICogdG9JdGVyYXRvciAocGFydHMsIGNsb25lID0gdHJ1ZSkge1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBpZiAoJ3N0cmVhbScgaW4gcGFydCkge1xuICAgICAgeWllbGQgKiAoLyoqIEB0eXBlIHtBc3luY0l0ZXJhYmxlSXRlcmF0b3I8VWludDhBcnJheT59ICovIChwYXJ0LnN0cmVhbSgpKSk7XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkpIHtcbiAgICAgIGlmIChjbG9uZSkge1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBwYXJ0LmJ5dGVPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHBhcnQuYnl0ZU9mZnNldCArIHBhcnQuYnl0ZUxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHBvc2l0aW9uICE9PSBlbmQpIHtcbiAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5taW4oZW5kIC0gcG9zaXRpb24sIFBPT0xfU0laRSk7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBwYXJ0LmJ1ZmZlci5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBzaXplKTtcbiAgICAgICAgICBwb3NpdGlvbiArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgIHlpZWxkIG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgcGFydDtcbiAgICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAxMCAqL1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYmxvYnMgdGhhdCBoYXZlIGFycmF5QnVmZmVyIGJ1dCBubyBzdHJlYW0gbWV0aG9kIChub2RlcyBidWZmZXIuQmxvYilcbiAgICAgIGxldCBwb3NpdGlvbiA9IDAsIGIgPSAoLyoqIEB0eXBlIHtCbG9ifSAqLyAocGFydCkpO1xuICAgICAgd2hpbGUgKHBvc2l0aW9uICE9PSBiLnNpemUpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBiLnNsaWNlKHBvc2l0aW9uLCBNYXRoLm1pbihiLnNpemUsIHBvc2l0aW9uICsgUE9PTF9TSVpFKSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNodW5rLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIHBvc2l0aW9uICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICB5aWVsZCBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBfQmxvYiA9IGNsYXNzIEJsb2Ige1xuICAvKiogQHR5cGUge0FycmF5LjwoQmxvYnxVaW50OEFycmF5KT59ICovXG4gICNwYXJ0cyA9IFtdXG4gICN0eXBlID0gJydcbiAgI3NpemUgPSAwXG4gICNlbmRpbmdzID0gJ3RyYW5zcGFyZW50J1xuXG4gIC8qKlxuICAgKiBUaGUgQmxvYigpIGNvbnN0cnVjdG9yIHJldHVybnMgYSBuZXcgQmxvYiBvYmplY3QuIFRoZSBjb250ZW50XG4gICAqIG9mIHRoZSBibG9iIGNvbnNpc3RzIG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSB2YWx1ZXMgZ2l2ZW5cbiAgICogaW4gdGhlIHBhcmFtZXRlciBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBibG9iUGFydHNcbiAgICogQHBhcmFtIHt7IHR5cGU/OiBzdHJpbmcsIGVuZGluZ3M/OiBzdHJpbmcgfX0gW29wdGlvbnNdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYmxvYlBhcnRzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgYmxvYlBhcnRzICE9PSAnb2JqZWN0JyB8fCBibG9iUGFydHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnQmxvYlxcJzogVGhlIHByb3ZpZGVkIHZhbHVlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBzZXF1ZW5jZS4nKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYmxvYlBhcnRzW1N5bWJvbC5pdGVyYXRvcl0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnQmxvYlxcJzogVGhlIG9iamVjdCBtdXN0IGhhdmUgYSBjYWxsYWJsZSBAQGl0ZXJhdG9yIHByb3BlcnR5LicpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIGNvbnN0cnVjdCBcXCdCbG9iXFwnOiBwYXJhbWV0ZXIgMiBjYW5ub3QgY29udmVydCB0byBkaWN0aW9uYXJ5LicpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwpIG9wdGlvbnMgPSB7fTtcblxuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYmxvYlBhcnRzKSB7XG4gICAgICBsZXQgcGFydDtcbiAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZWxlbWVudCkpIHtcbiAgICAgICAgcGFydCA9IG5ldyBVaW50OEFycmF5KGVsZW1lbnQuYnVmZmVyLnNsaWNlKGVsZW1lbnQuYnl0ZU9mZnNldCwgZWxlbWVudC5ieXRlT2Zmc2V0ICsgZWxlbWVudC5ieXRlTGVuZ3RoKSk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBwYXJ0ID0gbmV3IFVpbnQ4QXJyYXkoZWxlbWVudC5zbGljZSgwKSk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHBhcnQgPSBlbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydCA9IGVuY29kZXIuZW5jb2RlKGAke2VsZW1lbnR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpemUgPSBBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkgPyBwYXJ0LmJ5dGVMZW5ndGggOiBwYXJ0LnNpemU7XG4gICAgICAvLyBBdm9pZCBwdXNoaW5nIGVtcHR5IHBhcnRzIGludG8gdGhlIGFycmF5IHRvIGJldHRlciBHQyB0aGVtXG4gICAgICBpZiAoc2l6ZSkge1xuICAgICAgICB0aGlzLiNzaXplICs9IHNpemU7XG4gICAgICAgIHRoaXMuI3BhcnRzLnB1c2gocGFydCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4jZW5kaW5ncyA9IGAke29wdGlvbnMuZW5kaW5ncyA9PT0gdW5kZWZpbmVkID8gJ3RyYW5zcGFyZW50JyA6IG9wdGlvbnMuZW5kaW5nc31gO1xuICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGUgPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKG9wdGlvbnMudHlwZSk7XG4gICAgdGhpcy4jdHlwZSA9IC9eW1xceDIwLVxceDdFXSokLy50ZXN0KHR5cGUpID8gdHlwZSA6ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBCbG9iIGludGVyZmFjZSdzIHNpemUgcHJvcGVydHkgcmV0dXJucyB0aGVcbiAgICogc2l6ZSBvZiB0aGUgQmxvYiBpbiBieXRlcy5cbiAgICovXG4gIGdldCBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2l6ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIHByb3BlcnR5IG9mIGEgQmxvYiBvYmplY3QgcmV0dXJucyB0aGUgTUlNRSB0eXBlIG9mIHRoZSBmaWxlLlxuICAgKi9cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLiN0eXBlXG4gIH1cblxuICAvKipcbiAgICogVGhlIHRleHQoKSBtZXRob2QgaW4gdGhlIEJsb2IgaW50ZXJmYWNlIHJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHN0cmluZyBjb250YWluaW5nIHRoZSBjb250ZW50cyBvZlxuICAgKiB0aGUgYmxvYiwgaW50ZXJwcmV0ZWQgYXMgVVRGLTguXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICovXG4gIGFzeW5jIHRleHQgKCkge1xuICAgIC8vIE1vcmUgb3B0aW1pemVkIHRoYW4gdXNpbmcgdGhpcy5hcnJheUJ1ZmZlcigpXG4gICAgLy8gdGhhdCByZXF1aXJlcyB0d2ljZSBhcyBtdWNoIHJhbVxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIHRvSXRlcmF0b3IodGhpcy4jcGFydHMsIGZhbHNlKSkge1xuICAgICAgc3RyICs9IGRlY29kZXIuZGVjb2RlKHBhcnQsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBSZW1haW5pbmdcbiAgICBzdHIgKz0gZGVjb2Rlci5kZWNvZGUoKTtcbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICAvKipcbiAgICogVGhlIGFycmF5QnVmZmVyKCkgbWV0aG9kIGluIHRoZSBCbG9iIGludGVyZmFjZSByZXR1cm5zIGFcbiAgICogUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBibG9iIGFzXG4gICAqIGJpbmFyeSBkYXRhIGNvbnRhaW5lZCBpbiBhbiBBcnJheUJ1ZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBhc3luYyBhcnJheUJ1ZmZlciAoKSB7XG4gICAgLy8gRWFzaWVyIHdheS4uLiBKdXN0IGEgdW5uZWNlc3Nhcnkgb3ZlcmhlYWRcbiAgICAvLyBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplKTtcbiAgICAvLyBhd2FpdCB0aGlzLnN0cmVhbSgpLmdldFJlYWRlcih7bW9kZTogJ2J5b2InfSkucmVhZCh2aWV3KTtcbiAgICAvLyByZXR1cm4gdmlldy5idWZmZXI7XG5cbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRvSXRlcmF0b3IodGhpcy4jcGFydHMsIGZhbHNlKSkge1xuICAgICAgZGF0YS5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhLmJ1ZmZlclxuICB9XG5cbiAgc3RyZWFtICgpIHtcbiAgICBjb25zdCBpdCA9IHRvSXRlcmF0b3IodGhpcy4jcGFydHMsIHRydWUpO1xuXG4gICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICBhc3luYyBwdWxsIChjdHJsKSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgICBjaHVuay5kb25lID8gY3RybC5jbG9zZSgpIDogY3RybC5lbnF1ZXVlKGNodW5rLnZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIGFzeW5jIGNhbmNlbCAoKSB7XG4gICAgICAgIGF3YWl0IGl0LnJldHVybigpO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVGhlIEJsb2IgaW50ZXJmYWNlJ3Mgc2xpY2UoKSBtZXRob2QgY3JlYXRlcyBhbmQgcmV0dXJucyBhXG4gICAqIG5ldyBCbG9iIG9iamVjdCB3aGljaCBjb250YWlucyBkYXRhIGZyb20gYSBzdWJzZXQgb2YgdGhlXG4gICAqIGJsb2Igb24gd2hpY2ggaXQncyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdXG4gICAqL1xuICBzbGljZSAoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLnNpemUsIHR5cGUgPSAnJykge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gdGhpcztcblxuICAgIGxldCByZWxhdGl2ZVN0YXJ0ID0gc3RhcnQgPCAwID8gTWF0aC5tYXgoc2l6ZSArIHN0YXJ0LCAwKSA6IE1hdGgubWluKHN0YXJ0LCBzaXplKTtcbiAgICBsZXQgcmVsYXRpdmVFbmQgPSBlbmQgPCAwID8gTWF0aC5tYXgoc2l6ZSArIGVuZCwgMCkgOiBNYXRoLm1pbihlbmQsIHNpemUpO1xuXG4gICAgY29uc3Qgc3BhbiA9IE1hdGgubWF4KHJlbGF0aXZlRW5kIC0gcmVsYXRpdmVTdGFydCwgMCk7XG4gICAgY29uc3QgcGFydHMgPSB0aGlzLiNwYXJ0cztcbiAgICBjb25zdCBibG9iUGFydHMgPSBbXTtcbiAgICBsZXQgYWRkZWQgPSAwO1xuXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAvLyBkb24ndCBhZGQgdGhlIG92ZXJmbG93IHRvIG5ldyBibG9iUGFydHNcbiAgICAgIGlmIChhZGRlZCA+PSBzcGFuKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpemUgPSBBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkgPyBwYXJ0LmJ5dGVMZW5ndGggOiBwYXJ0LnNpemU7XG4gICAgICBpZiAocmVsYXRpdmVTdGFydCAmJiBzaXplIDw9IHJlbGF0aXZlU3RhcnQpIHtcbiAgICAgICAgLy8gU2tpcCB0aGUgYmVnaW5uaW5nIGFuZCBjaGFuZ2UgdGhlIHJlbGF0aXZlXG4gICAgICAgIC8vIHN0YXJ0ICYgZW5kIHBvc2l0aW9uIGFzIHdlIHNraXAgdGhlIHVud2FudGVkIHBhcnRzXG4gICAgICAgIHJlbGF0aXZlU3RhcnQgLT0gc2l6ZTtcbiAgICAgICAgcmVsYXRpdmVFbmQgLT0gc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSkge1xuICAgICAgICAgIGNodW5rID0gcGFydC5zdWJhcnJheShyZWxhdGl2ZVN0YXJ0LCBNYXRoLm1pbihzaXplLCByZWxhdGl2ZUVuZCkpO1xuICAgICAgICAgIGFkZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2h1bmsgPSBwYXJ0LnNsaWNlKHJlbGF0aXZlU3RhcnQsIE1hdGgubWluKHNpemUsIHJlbGF0aXZlRW5kKSk7XG4gICAgICAgICAgYWRkZWQgKz0gY2h1bmsuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZWxhdGl2ZUVuZCAtPSBzaXplO1xuICAgICAgICBibG9iUGFydHMucHVzaChjaHVuayk7XG4gICAgICAgIHJlbGF0aXZlU3RhcnQgPSAwOyAvLyBBbGwgbmV4dCBzZXF1ZW50aWFsIHBhcnRzIHNob3VsZCBzdGFydCBhdCAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtdLCB7IHR5cGU6IFN0cmluZyh0eXBlKS50b0xvd2VyQ2FzZSgpIH0pO1xuICAgIGJsb2IuI3NpemUgPSBzcGFuO1xuICAgIGJsb2IuI3BhcnRzID0gYmxvYlBhcnRzO1xuXG4gICAgcmV0dXJuIGJsb2JcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdCbG9iJ1xuICB9XG5cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdIChvYmplY3QpIHtcbiAgICByZXR1cm4gKFxuICAgICAgb2JqZWN0ICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKFxuICAgICAgICB0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nXG4gICAgICApICYmXG4gICAgICAvXihCbG9ifEZpbGUpJC8udGVzdChvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSlcbiAgICApXG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF9CbG9iLnByb3RvdHlwZSwge1xuICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgdHlwZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHNsaWNlOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5cbi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXMuQmxvYn0gKi9cbmNvbnN0IEJsb2IgPSBfQmxvYjtcbmNvbnN0IF9CbG9iJDEgPSBCbG9iO1xuXG5jb25zdCBfRmlsZSA9IGNsYXNzIEZpbGUgZXh0ZW5kcyBfQmxvYiQxIHtcbiAgI2xhc3RNb2RpZmllZCA9IDBcbiAgI25hbWUgPSAnJ1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geypbXX0gZmlsZUJpdHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVOYW1lXG4gICAqIEBwYXJhbSB7e2xhc3RNb2RpZmllZD86IG51bWJlciwgdHlwZT86IHN0cmluZ319IG9wdGlvbnNcbiAgICovLy8gQHRzLWlnbm9yZVxuICBjb25zdHJ1Y3RvciAoZmlsZUJpdHMsIGZpbGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ0ZpbGUnOiAyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmApXG4gICAgfVxuICAgIHN1cGVyKGZpbGVCaXRzLCBvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zID09PSBudWxsKSBvcHRpb25zID0ge307XG5cbiAgICAvLyBTaW11bGF0ZSBXZWJJREwgdHlwZSBjYXN0aW5nIGZvciBOYU4gdmFsdWUgaW4gbGFzdE1vZGlmaWVkIG9wdGlvbi5cbiAgICBjb25zdCBsYXN0TW9kaWZpZWQgPSBvcHRpb25zLmxhc3RNb2RpZmllZCA9PT0gdW5kZWZpbmVkID8gRGF0ZS5ub3coKSA6IE51bWJlcihvcHRpb25zLmxhc3RNb2RpZmllZCk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obGFzdE1vZGlmaWVkKSkge1xuICAgICAgdGhpcy4jbGFzdE1vZGlmaWVkID0gbGFzdE1vZGlmaWVkO1xuICAgIH1cblxuICAgIHRoaXMuI25hbWUgPSBTdHJpbmcoZmlsZU5hbWUpO1xuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLiNuYW1lXG4gIH1cblxuICBnZXQgbGFzdE1vZGlmaWVkICgpIHtcbiAgICByZXR1cm4gdGhpcy4jbGFzdE1vZGlmaWVkXG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10gKCkge1xuICAgIHJldHVybiAnRmlsZSdcbiAgfVxuXG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSAob2JqZWN0KSB7XG4gICAgcmV0dXJuICEhb2JqZWN0ICYmIG9iamVjdCBpbnN0YW5jZW9mIF9CbG9iJDEgJiZcbiAgICAgIC9eKEZpbGUpJC8udGVzdChvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSlcbiAgfVxufTtcblxuLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpcy5GaWxlfSAqLy8vIEB0cy1pZ25vcmVcbmNvbnN0IEZpbGUgPSBfRmlsZTtcbmNvbnN0IEZpbGUkMSA9IEZpbGU7XG5cbi8qISBmb3JtZGF0YS1wb2x5ZmlsbC4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cblxudmFyIHt0b1N0cmluZ1RhZzp0LGl0ZXJhdG9yOmksaGFzSW5zdGFuY2U6aH09U3ltYm9sLFxucj1NYXRoLnJhbmRvbSxcbm09J2FwcGVuZCxzZXQsZ2V0LGdldEFsbCxkZWxldGUsa2V5cyx2YWx1ZXMsZW50cmllcyxmb3JFYWNoLGNvbnN0cnVjdG9yJy5zcGxpdCgnLCcpLFxuZj0oYSxiLGMpPT4oYSs9JycsL14oQmxvYnxGaWxlKSQvLnRlc3QoYiAmJiBiW3RdKT9bKGM9YyE9PXZvaWQgMD9jKycnOmJbdF09PSdGaWxlJz9iLm5hbWU6J2Jsb2InLGEpLGIubmFtZSE9PWN8fGJbdF09PSdibG9iJz9uZXcgRmlsZSQxKFtiXSxjLGIpOmJdOlthLGIrJyddKSxcbmU9KGMsZik9PihmP2M6Yy5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCdcXHJcXG4nKSkucmVwbGFjZSgvXFxuL2csJyUwQScpLnJlcGxhY2UoL1xcci9nLCclMEQnKS5yZXBsYWNlKC9cIi9nLCclMjInKSxcbng9KG4sIGEsIGUpPT57aWYoYS5sZW5ndGg8ZSl7dGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJyR7bn0nIG9uICdGb3JtRGF0YSc6ICR7ZX0gYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2EubGVuZ3RofSBwcmVzZW50LmApfX07XG5cbi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXMuRm9ybURhdGF9ICovXG5jb25zdCBGb3JtRGF0YSA9IGNsYXNzIEZvcm1EYXRhIHtcbiNkPVtdO1xuY29uc3RydWN0b3IoLi4uYSl7aWYoYS5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGNvbnN0cnVjdCAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnSFRNTEZvcm1FbGVtZW50Jy5gKX1cbmdldCBbdF0oKSB7cmV0dXJuICdGb3JtRGF0YSd9XG5baV0oKXtyZXR1cm4gdGhpcy5lbnRyaWVzKCl9XG5zdGF0aWMgW2hdKG8pIHtyZXR1cm4gbyYmdHlwZW9mIG89PT0nb2JqZWN0JyYmb1t0XT09PSdGb3JtRGF0YScmJiFtLnNvbWUobT0+dHlwZW9mIG9bbV0hPSdmdW5jdGlvbicpfVxuYXBwZW5kKC4uLmEpe3goJ2FwcGVuZCcsYXJndW1lbnRzLDIpO3RoaXMuI2QucHVzaChmKC4uLmEpKTt9XG5kZWxldGUoYSl7eCgnZGVsZXRlJyxhcmd1bWVudHMsMSk7YSs9Jyc7dGhpcy4jZD10aGlzLiNkLmZpbHRlcigoW2JdKT0+YiE9PWEpO31cbmdldChhKXt4KCdnZXQnLGFyZ3VtZW50cywxKTthKz0nJztmb3IodmFyIGI9dGhpcy4jZCxsPWIubGVuZ3RoLGM9MDtjPGw7YysrKWlmKGJbY11bMF09PT1hKXJldHVybiBiW2NdWzFdO3JldHVybiBudWxsfVxuZ2V0QWxsKGEsYil7eCgnZ2V0QWxsJyxhcmd1bWVudHMsMSk7Yj1bXTthKz0nJzt0aGlzLiNkLmZvckVhY2goYz0+Y1swXT09PWEmJmIucHVzaChjWzFdKSk7cmV0dXJuIGJ9XG5oYXMoYSl7eCgnaGFzJyxhcmd1bWVudHMsMSk7YSs9Jyc7cmV0dXJuIHRoaXMuI2Quc29tZShiPT5iWzBdPT09YSl9XG5mb3JFYWNoKGEsYil7eCgnZm9yRWFjaCcsYXJndW1lbnRzLDEpO2Zvcih2YXIgW2MsZF1vZiB0aGlzKWEuY2FsbChiLGQsYyx0aGlzKTt9XG5zZXQoLi4uYSl7eCgnc2V0Jyxhcmd1bWVudHMsMik7dmFyIGI9W10sYz0hMDthPWYoLi4uYSk7dGhpcy4jZC5mb3JFYWNoKGQ9PntkWzBdPT09YVswXT9jJiYoYz0hYi5wdXNoKGEpKTpiLnB1c2goZCk7fSk7YyYmYi5wdXNoKGEpO3RoaXMuI2Q9Yjt9XG4qZW50cmllcygpe3lpZWxkKnRoaXMuI2Q7fVxuKmtleXMoKXtmb3IodmFyW2Fdb2YgdGhpcyl5aWVsZCBhO31cbip2YWx1ZXMoKXtmb3IodmFyWyxhXW9mIHRoaXMpeWllbGQgYTt9fTtcblxuLyoqIEBwYXJhbSB7Rm9ybURhdGF9IEYgKi9cbmZ1bmN0aW9uIGZvcm1EYXRhVG9CbG9iIChGLEI9X0Jsb2IkMSl7XG52YXIgYj1gJHtyKCl9JHtyKCl9YC5yZXBsYWNlKC9cXC4vZywgJycpLnNsaWNlKC0yOCkucGFkU3RhcnQoMzIsICctJyksYz1bXSxwPWAtLSR7Yn1cXHJcXG5Db250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCJgO1xuRi5mb3JFYWNoKCh2LG4pPT50eXBlb2Ygdj09J3N0cmluZydcbj9jLnB1c2gocCtlKG4pK2BcIlxcclxcblxcclxcbiR7di5yZXBsYWNlKC9cXHIoPyFcXG4pfCg/PCFcXHIpXFxuL2csICdcXHJcXG4nKX1cXHJcXG5gKVxuOmMucHVzaChwK2UobikrYFwiOyBmaWxlbmFtZT1cIiR7ZSh2Lm5hbWUsIDEpfVwiXFxyXFxuQ29udGVudC1UeXBlOiAke3YudHlwZXx8XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn1cXHJcXG5cXHJcXG5gLCB2LCAnXFxyXFxuJykpO1xuYy5wdXNoKGAtLSR7Yn0tLWApO1xucmV0dXJuIG5ldyBCKGMse3R5cGU6XCJtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT1cIitifSl9XG5cbmNsYXNzIEZldGNoQmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCB0eXBlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0Ly8gSGlkZSBjdXN0b20gZXJyb3IgaW1wbGVtZW50YXRpb24gZGV0YWlscyBmcm9tIGVuZC11c2Vyc1xuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0fVxuXG5cdGdldCBuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0fVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHt7IGFkZHJlc3M/OiBzdHJpbmcsIGNvZGU6IHN0cmluZywgZGVzdD86IHN0cmluZywgZXJybm86IG51bWJlciwgaW5mbz86IG9iamVjdCwgbWVzc2FnZTogc3RyaW5nLCBwYXRoPzogc3RyaW5nLCBwb3J0PzogbnVtYmVyLCBzeXNjYWxsOiBzdHJpbmd9fSBTeXN0ZW1FcnJvclxuKi9cblxuLyoqXG4gKiBGZXRjaEVycm9yIGludGVyZmFjZSBmb3Igb3BlcmF0aW9uYWwgZXJyb3JzXG4gKi9cbmNsYXNzIEZldGNoRXJyb3IgZXh0ZW5kcyBGZXRjaEJhc2VFcnJvciB7XG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IG1lc3NhZ2UgLSAgICAgIEVycm9yIG1lc3NhZ2UgZm9yIGh1bWFuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gW3R5cGVdIC0gICAgICAgIEVycm9yIHR5cGUgZm9yIG1hY2hpbmVcblx0ICogQHBhcmFtICB7U3lzdGVtRXJyb3J9IFtzeXN0ZW1FcnJvcl0gLSBGb3IgTm9kZS5qcyBzeXN0ZW0gZXJyb3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHR5cGUsIHN5c3RlbUVycm9yKSB7XG5cdFx0c3VwZXIobWVzc2FnZSwgdHlwZSk7XG5cdFx0Ly8gV2hlbiBlcnIudHlwZSBpcyBgc3lzdGVtYCwgZXJyLmVycm9yZWRTeXNDYWxsIGNvbnRhaW5zIHN5c3RlbSBlcnJvciBhbmQgZXJyLmNvZGUgY29udGFpbnMgc3lzdGVtIGVycm9yIGNvZGVcblx0XHRpZiAoc3lzdGVtRXJyb3IpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cblx0XHRcdHRoaXMuY29kZSA9IHRoaXMuZXJybm8gPSBzeXN0ZW1FcnJvci5jb2RlO1xuXHRcdFx0dGhpcy5lcnJvcmVkU3lzQ2FsbCA9IHN5c3RlbUVycm9yLnN5c2NhbGw7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogSXMuanNcbiAqXG4gKiBPYmplY3QgdHlwZSBjaGVja3MuXG4gKi9cblxuY29uc3QgTkFNRSA9IFN5bWJvbC50b1N0cmluZ1RhZztcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvMjk2I2lzc3VlY29tbWVudC0zMDc1OTgxNDNcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrIGZvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNVUkxTZWFyY2hQYXJhbWV0ZXJzID0gb2JqZWN0ID0+IHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiBvYmplY3QuYXBwZW5kID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5kZWxldGUgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmdldCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBvYmplY3QuZ2V0QWxsID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5oYXMgPT09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnNldCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBvYmplY3Quc29ydCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdG9iamVjdFtOQU1FXSA9PT0gJ1VSTFNlYXJjaFBhcmFtcydcblx0KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamVjdGAgaXMgYSBXM0MgYEJsb2JgIG9iamVjdCAod2hpY2ggYEZpbGVgIGluaGVyaXRzIGZyb20pXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBjaGVjayBmb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzQmxvYiA9IG9iamVjdCA9PiB7XG5cdHJldHVybiAoXG5cdFx0b2JqZWN0ICYmXG5cdFx0dHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC50eXBlID09PSAnc3RyaW5nJyAmJlxuXHRcdHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdC9eKEJsb2J8RmlsZSkkLy50ZXN0KG9iamVjdFtOQU1FXSlcblx0KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gaW5zdGFuY2Ugb2YgQWJvcnRTaWduYWwuXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIE9iamVjdCB0byBjaGVjayBmb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzQWJvcnRTaWduYWwgPSBvYmplY3QgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIChcblx0XHRcdG9iamVjdFtOQU1FXSA9PT0gJ0Fib3J0U2lnbmFsJyB8fFxuXHRcdFx0b2JqZWN0W05BTUVdID09PSAnRXZlbnRUYXJnZXQnXG5cdFx0KVxuXHQpO1xufTtcblxuLyoqXG4gKiBpc0RvbWFpbk9yU3ViZG9tYWluIHJlcG9ydHMgd2hldGhlciBzdWIgaXMgYSBzdWJkb21haW4gKG9yIGV4YWN0IG1hdGNoKSBvZlxuICogdGhlIHBhcmVudCBkb21haW4uXG4gKlxuICogQm90aCBkb21haW5zIG11c3QgYWxyZWFkeSBiZSBpbiBjYW5vbmljYWwgZm9ybS5cbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gb3JpZ2luYWxcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gZGVzdGluYXRpb25cbiAqL1xuY29uc3QgaXNEb21haW5PclN1YmRvbWFpbiA9IChkZXN0aW5hdGlvbiwgb3JpZ2luYWwpID0+IHtcblx0Y29uc3Qgb3JpZyA9IG5ldyBVUkwob3JpZ2luYWwpLmhvc3RuYW1lO1xuXHRjb25zdCBkZXN0ID0gbmV3IFVSTChkZXN0aW5hdGlvbikuaG9zdG5hbWU7XG5cblx0cmV0dXJuIG9yaWcgPT09IGRlc3QgfHwgb3JpZy5lbmRzV2l0aChgLiR7ZGVzdH1gKTtcbn07XG5cbi8qKlxuICogaXNTYW1lUHJvdG9jb2wgcmVwb3J0cyB3aGV0aGVyIHRoZSB0d28gcHJvdmlkZWQgVVJMcyB1c2UgdGhlIHNhbWUgcHJvdG9jb2wuXG4gKlxuICogQm90aCBkb21haW5zIG11c3QgYWxyZWFkeSBiZSBpbiBjYW5vbmljYWwgZm9ybS5cbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gb3JpZ2luYWxcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gZGVzdGluYXRpb25cbiAqL1xuY29uc3QgaXNTYW1lUHJvdG9jb2wgPSAoZGVzdGluYXRpb24sIG9yaWdpbmFsKSA9PiB7XG5cdGNvbnN0IG9yaWcgPSBuZXcgVVJMKG9yaWdpbmFsKS5wcm90b2NvbDtcblx0Y29uc3QgZGVzdCA9IG5ldyBVUkwoZGVzdGluYXRpb24pLnByb3RvY29sO1xuXG5cdHJldHVybiBvcmlnID09PSBkZXN0O1xufTtcblxuY29uc3QgcGlwZWxpbmUgPSBub2RlX3V0aWwucHJvbWlzaWZ5KFN0cmVhbS5waXBlbGluZSk7XG5jb25zdCBJTlRFUk5BTFMkMiA9IFN5bWJvbCgnQm9keSBpbnRlcm5hbHMnKTtcblxuLyoqXG4gKiBCb2R5IG1peGluXG4gKlxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keVxuICpcbiAqIEBwYXJhbSAgIFN0cmVhbSAgYm9keSAgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gICBPYmplY3QgIG9wdHMgIFJlc3BvbnNlIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuY2xhc3MgQm9keSB7XG5cdGNvbnN0cnVjdG9yKGJvZHksIHtcblx0XHRzaXplID0gMFxuXHR9ID0ge30pIHtcblx0XHRsZXQgYm91bmRhcnkgPSBudWxsO1xuXG5cdFx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHRcdC8vIEJvZHkgaXMgdW5kZWZpbmVkIG9yIG51bGxcblx0XHRcdGJvZHkgPSBudWxsO1xuXHRcdH0gZWxzZSBpZiAoaXNVUkxTZWFyY2hQYXJhbWV0ZXJzKGJvZHkpKSB7XG5cdFx0XHQvLyBCb2R5IGlzIGEgVVJMU2VhcmNoUGFyYW1zXG5cdFx0XHRib2R5ID0gbm9kZV9idWZmZXIuQnVmZmVyLmZyb20oYm9keS50b1N0cmluZygpKTtcblx0XHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkgOyBlbHNlIGlmIChub2RlX2J1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYm9keSkpIDsgZWxzZSBpZiAobm9kZV91dGlsLnR5cGVzLmlzQW55QXJyYXlCdWZmZXIoYm9keSkpIHtcblx0XHRcdC8vIEJvZHkgaXMgQXJyYXlCdWZmZXJcblx0XHRcdGJvZHkgPSBub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShib2R5KTtcblx0XHR9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBBcnJheUJ1ZmZlclZpZXdcblx0XHRcdGJvZHkgPSBub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShib2R5LmJ1ZmZlciwgYm9keS5ieXRlT2Zmc2V0LCBib2R5LmJ5dGVMZW5ndGgpO1xuXHRcdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkgOyBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRcdC8vIEJvZHkgaXMgRm9ybURhdGFcblx0XHRcdGJvZHkgPSBmb3JtRGF0YVRvQmxvYihib2R5KTtcblx0XHRcdGJvdW5kYXJ5ID0gYm9keS50eXBlLnNwbGl0KCc9JylbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIE5vbmUgb2YgdGhlIGFib3ZlXG5cdFx0XHQvLyBjb2VyY2UgdG8gc3RyaW5nIHRoZW4gYnVmZmVyXG5cdFx0XHRib2R5ID0gbm9kZV9idWZmZXIuQnVmZmVyLmZyb20oU3RyaW5nKGJvZHkpKTtcblx0XHR9XG5cblx0XHRsZXQgc3RyZWFtID0gYm9keTtcblxuXHRcdGlmIChub2RlX2J1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcblx0XHRcdHN0cmVhbSA9IFN0cmVhbS5SZWFkYWJsZS5mcm9tKGJvZHkpO1xuXHRcdH0gZWxzZSBpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0XHRzdHJlYW0gPSBTdHJlYW0uUmVhZGFibGUuZnJvbShib2R5LnN0cmVhbSgpKTtcblx0XHR9XG5cblx0XHR0aGlzW0lOVEVSTkFMUyQyXSA9IHtcblx0XHRcdGJvZHksXG5cdFx0XHRzdHJlYW0sXG5cdFx0XHRib3VuZGFyeSxcblx0XHRcdGRpc3R1cmJlZDogZmFsc2UsXG5cdFx0XHRlcnJvcjogbnVsbFxuXHRcdH07XG5cdFx0dGhpcy5zaXplID0gc2l6ZTtcblxuXHRcdGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG5cdFx0XHRib2R5Lm9uKCdlcnJvcicsIGVycm9yXyA9PiB7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gZXJyb3JfIGluc3RhbmNlb2YgRmV0Y2hCYXNlRXJyb3IgP1xuXHRcdFx0XHRcdGVycm9yXyA6XG5cdFx0XHRcdFx0bmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHt0aGlzLnVybH06ICR7ZXJyb3JfLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycm9yXyk7XG5cdFx0XHRcdHRoaXNbSU5URVJOQUxTJDJdLmVycm9yID0gZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRnZXQgYm9keSgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMl0uc3RyZWFtO1xuXHR9XG5cblx0Z2V0IGJvZHlVc2VkKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQyXS5kaXN0dXJiZWQ7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIEFycmF5QnVmZmVyXG5cdCAqXG5cdCAqIEByZXR1cm4gIFByb21pc2Vcblx0ICovXG5cdGFzeW5jIGFycmF5QnVmZmVyKCkge1xuXHRcdGNvbnN0IHtidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGh9ID0gYXdhaXQgY29uc3VtZUJvZHkodGhpcyk7XG5cdFx0cmV0dXJuIGJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG5cdH1cblxuXHRhc3luYyBmb3JtRGF0YSgpIHtcblx0XHRjb25zdCBjdCA9IHRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuXG5cdFx0aWYgKGN0LnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpKSB7XG5cdFx0XHRjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXHRcdFx0Y29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoYXdhaXQgdGhpcy50ZXh0KCkpO1xuXG5cdFx0XHRmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgcGFyYW1ldGVycykge1xuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm9ybURhdGE7XG5cdFx0fVxuXG5cdFx0Y29uc3Qge3RvRm9ybURhdGF9ID0gYXdhaXQgaW1wb3J0KCcuLi9jaHVua3MvbXVsdGlwYXJ0LXBhcnNlci5janMnKTtcblx0XHRyZXR1cm4gdG9Gb3JtRGF0YSh0aGlzLmJvZHksIGN0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gcmF3IHJlc3BvbnNlIGFzIEJsb2Jcblx0ICpcblx0ICogQHJldHVybiBQcm9taXNlXG5cdCAqL1xuXHRhc3luYyBibG9iKCkge1xuXHRcdGNvbnN0IGN0ID0gKHRoaXMuaGVhZGVycyAmJiB0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkgfHwgKHRoaXNbSU5URVJOQUxTJDJdLmJvZHkgJiYgdGhpc1tJTlRFUk5BTFMkMl0uYm9keS50eXBlKSB8fCAnJztcblx0XHRjb25zdCBidWYgPSBhd2FpdCB0aGlzLmFycmF5QnVmZmVyKCk7XG5cblx0XHRyZXR1cm4gbmV3IF9CbG9iJDEoW2J1Zl0sIHtcblx0XHRcdHR5cGU6IGN0XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIGpzb25cblx0ICpcblx0ICogQHJldHVybiAgUHJvbWlzZVxuXHQgKi9cblx0YXN5bmMganNvbigpIHtcblx0XHRjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy50ZXh0KCk7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIHRleHRcblx0ICpcblx0ICogQHJldHVybiAgUHJvbWlzZVxuXHQgKi9cblx0YXN5bmMgdGV4dCgpIHtcblx0XHRjb25zdCBidWZmZXIgPSBhd2FpdCBjb25zdW1lQm9keSh0aGlzKTtcblx0XHRyZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZlcik7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIGJ1ZmZlciAobm9uLXNwZWMgYXBpKVxuXHQgKlxuXHQgKiBAcmV0dXJuICBQcm9taXNlXG5cdCAqL1xuXHRidWZmZXIoKSB7XG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMpO1xuXHR9XG59XG5cbkJvZHkucHJvdG90eXBlLmJ1ZmZlciA9IG5vZGVfdXRpbC5kZXByZWNhdGUoQm9keS5wcm90b3R5cGUuYnVmZmVyLCAnUGxlYXNlIHVzZSBcXCdyZXNwb25zZS5hcnJheUJ1ZmZlcigpXFwnIGluc3RlYWQgb2YgXFwncmVzcG9uc2UuYnVmZmVyKClcXCcnLCAnbm9kZS1mZXRjaCNidWZmZXInKTtcblxuLy8gSW4gYnJvd3NlcnMsIGFsbCBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQm9keS5wcm90b3R5cGUsIHtcblx0Ym9keToge2VudW1lcmFibGU6IHRydWV9LFxuXHRib2R5VXNlZDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRhcnJheUJ1ZmZlcjoge2VudW1lcmFibGU6IHRydWV9LFxuXHRibG9iOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGpzb246IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0dGV4dDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRkYXRhOiB7Z2V0OiBub2RlX3V0aWwuZGVwcmVjYXRlKCgpID0+IHt9LFxuXHRcdCdkYXRhIGRvZXNuXFwndCBleGlzdCwgdXNlIGpzb24oKSwgdGV4dCgpLCBhcnJheUJ1ZmZlcigpLCBvciBib2R5IGluc3RlYWQnLFxuXHRcdCdodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMDAwIChyZXNwb25zZSknKX1cbn0pO1xuXG4vKipcbiAqIENvbnN1bWUgYW5kIGNvbnZlcnQgYW4gZW50aXJlIEJvZHkgdG8gYSBCdWZmZXIuXG4gKlxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LWNvbnN1bWUtYm9keVxuICpcbiAqIEByZXR1cm4gUHJvbWlzZVxuICovXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lQm9keShkYXRhKSB7XG5cdGlmIChkYXRhW0lOVEVSTkFMUyQyXS5kaXN0dXJiZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBib2R5IHVzZWQgYWxyZWFkeSBmb3I6ICR7ZGF0YS51cmx9YCk7XG5cdH1cblxuXHRkYXRhW0lOVEVSTkFMUyQyXS5kaXN0dXJiZWQgPSB0cnVlO1xuXG5cdGlmIChkYXRhW0lOVEVSTkFMUyQyXS5lcnJvcikge1xuXHRcdHRocm93IGRhdGFbSU5URVJOQUxTJDJdLmVycm9yO1xuXHR9XG5cblx0Y29uc3Qge2JvZHl9ID0gZGF0YTtcblxuXHQvLyBCb2R5IGlzIG51bGxcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gbm9kZV9idWZmZXIuQnVmZmVyLmFsbG9jKDApO1xuXHR9XG5cblx0LyogYzggaWdub3JlIG5leHQgMyAqL1xuXHRpZiAoIShib2R5IGluc3RhbmNlb2YgU3RyZWFtKSkge1xuXHRcdHJldHVybiBub2RlX2J1ZmZlci5CdWZmZXIuYWxsb2MoMCk7XG5cdH1cblxuXHQvLyBCb2R5IGlzIHN0cmVhbVxuXHQvLyBnZXQgcmVhZHkgdG8gYWN0dWFsbHkgY29uc3VtZSB0aGUgYm9keVxuXHRjb25zdCBhY2N1bSA9IFtdO1xuXHRsZXQgYWNjdW1CeXRlcyA9IDA7XG5cblx0dHJ5IHtcblx0XHRmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcblx0XHRcdGlmIChkYXRhLnNpemUgPiAwICYmIGFjY3VtQnl0ZXMgKyBjaHVuay5sZW5ndGggPiBkYXRhLnNpemUpIHtcblx0XHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgRmV0Y2hFcnJvcihgY29udGVudCBzaXplIGF0ICR7ZGF0YS51cmx9IG92ZXIgbGltaXQ6ICR7ZGF0YS5zaXplfWAsICdtYXgtc2l6ZScpO1xuXHRcdFx0XHRib2R5LmRlc3Ryb3koZXJyb3IpO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblxuXHRcdFx0YWNjdW1CeXRlcyArPSBjaHVuay5sZW5ndGg7XG5cdFx0XHRhY2N1bS5wdXNoKGNodW5rKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Y29uc3QgZXJyb3JfID0gZXJyb3IgaW5zdGFuY2VvZiBGZXRjaEJhc2VFcnJvciA/IGVycm9yIDogbmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtkYXRhLnVybH06ICR7ZXJyb3IubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyb3IpO1xuXHRcdHRocm93IGVycm9yXztcblx0fVxuXG5cdGlmIChib2R5LnJlYWRhYmxlRW5kZWQgPT09IHRydWUgfHwgYm9keS5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9PT0gdHJ1ZSkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoYWNjdW0uZXZlcnkoYyA9PiB0eXBlb2YgYyA9PT0gJ3N0cmluZycpKSB7XG5cdFx0XHRcdHJldHVybiBub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShhY2N1bS5qb2luKCcnKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBub2RlX2J1ZmZlci5CdWZmZXIuY29uY2F0KGFjY3VtLCBhY2N1bUJ5dGVzKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhyb3cgbmV3IEZldGNoRXJyb3IoYENvdWxkIG5vdCBjcmVhdGUgQnVmZmVyIGZyb20gcmVzcG9uc2UgYm9keSBmb3IgJHtkYXRhLnVybH06ICR7ZXJyb3IubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyb3IpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRmV0Y2hFcnJvcihgUHJlbWF0dXJlIGNsb3NlIG9mIHNlcnZlciByZXNwb25zZSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtkYXRhLnVybH1gKTtcblx0fVxufVxuXG4vKipcbiAqIENsb25lIGJvZHkgZ2l2ZW4gUmVzL1JlcSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAgIE1peGVkICAgaW5zdGFuY2UgICAgICAgUmVzcG9uc2Ugb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAgU3RyaW5nICBoaWdoV2F0ZXJNYXJrICBoaWdoV2F0ZXJNYXJrIGZvciBib3RoIFBhc3NUaHJvdWdoIGJvZHkgc3RyZWFtc1xuICogQHJldHVybiAgTWl4ZWRcbiAqL1xuY29uc3QgY2xvbmUgPSAoaW5zdGFuY2UsIGhpZ2hXYXRlck1hcmspID0+IHtcblx0bGV0IHAxO1xuXHRsZXQgcDI7XG5cdGxldCB7Ym9keX0gPSBpbnN0YW5jZVtJTlRFUk5BTFMkMl07XG5cblx0Ly8gRG9uJ3QgYWxsb3cgY2xvbmluZyBhIHVzZWQgYm9keVxuXHRpZiAoaW5zdGFuY2UuYm9keVVzZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjbG9uZSBib2R5IGFmdGVyIGl0IGlzIHVzZWQnKTtcblx0fVxuXG5cdC8vIENoZWNrIHRoYXQgYm9keSBpcyBhIHN0cmVhbSBhbmQgbm90IGZvcm0tZGF0YSBvYmplY3Rcblx0Ly8gbm90ZTogd2UgY2FuJ3QgY2xvbmUgdGhlIGZvcm0tZGF0YSBvYmplY3Qgd2l0aG91dCBoYXZpbmcgaXQgYXMgYSBkZXBlbmRlbmN5XG5cdGlmICgoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkgJiYgKHR5cGVvZiBib2R5LmdldEJvdW5kYXJ5ICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdC8vIFRlZSBpbnN0YW5jZSBib2R5XG5cdFx0cDEgPSBuZXcgU3RyZWFtLlBhc3NUaHJvdWdoKHtoaWdoV2F0ZXJNYXJrfSk7XG5cdFx0cDIgPSBuZXcgU3RyZWFtLlBhc3NUaHJvdWdoKHtoaWdoV2F0ZXJNYXJrfSk7XG5cdFx0Ym9keS5waXBlKHAxKTtcblx0XHRib2R5LnBpcGUocDIpO1xuXHRcdC8vIFNldCBpbnN0YW5jZSBib2R5IHRvIHRlZWQgYm9keSBhbmQgcmV0dXJuIHRoZSBvdGhlciB0ZWVkIGJvZHlcblx0XHRpbnN0YW5jZVtJTlRFUk5BTFMkMl0uc3RyZWFtID0gcDE7XG5cdFx0Ym9keSA9IHAyO1xuXHR9XG5cblx0cmV0dXJuIGJvZHk7XG59O1xuXG5jb25zdCBnZXROb25TcGVjRm9ybURhdGFCb3VuZGFyeSA9IG5vZGVfdXRpbC5kZXByZWNhdGUoXG5cdGJvZHkgPT4gYm9keS5nZXRCb3VuZGFyeSgpLFxuXHQnZm9ybS1kYXRhIGRvZXNuXFwndCBmb2xsb3cgdGhlIHNwZWMgYW5kIHJlcXVpcmVzIHNwZWNpYWwgdHJlYXRtZW50LiBVc2UgYWx0ZXJuYXRpdmUgcGFja2FnZScsXG5cdCdodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMTY3J1xuKTtcblxuLyoqXG4gKiBQZXJmb3JtcyB0aGUgb3BlcmF0aW9uIFwiZXh0cmFjdCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb20gfG9iamVjdHxcIiBhc1xuICogc3BlY2lmaWVkIGluIHRoZSBzcGVjaWZpY2F0aW9uOlxuICogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGluc3RhbmNlLmJvZHkgaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge2FueX0gYm9keSBBbnkgb3B0aW9ucy5ib2R5IGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cbiAqL1xuY29uc3QgZXh0cmFjdENvbnRlbnRUeXBlID0gKGJvZHksIHJlcXVlc3QpID0+IHtcblx0Ly8gQm9keSBpcyBudWxsIG9yIHVuZGVmaW5lZFxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBzdHJpbmdcblx0aWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jztcblx0fVxuXG5cdC8vIEJvZHkgaXMgYSBVUkxTZWFyY2hQYXJhbXNcblx0aWYgKGlzVVJMU2VhcmNoUGFyYW1ldGVycyhib2R5KSkge1xuXHRcdHJldHVybiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBibG9iXG5cdGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHRyZXR1cm4gYm9keS50eXBlIHx8IG51bGw7XG5cdH1cblxuXHQvLyBCb2R5IGlzIGEgQnVmZmVyIChCdWZmZXIsIEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldylcblx0aWYgKG5vZGVfYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcihib2R5KSB8fCBub2RlX3V0aWwudHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihib2R5KSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmIChib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRyZXR1cm4gYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PSR7cmVxdWVzdFtJTlRFUk5BTFMkMl0uYm91bmRhcnl9YDtcblx0fVxuXG5cdC8vIERldGVjdCBmb3JtIGRhdGEgaW5wdXQgZnJvbSBmb3JtLWRhdGEgbW9kdWxlXG5cdGlmIChib2R5ICYmIHR5cGVvZiBib2R5LmdldEJvdW5kYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGBtdWx0aXBhcnQvZm9ybS1kYXRhO2JvdW5kYXJ5PSR7Z2V0Tm9uU3BlY0Zvcm1EYXRhQm91bmRhcnkoYm9keSl9YDtcblx0fVxuXG5cdC8vIEJvZHkgaXMgc3RyZWFtIC0gY2FuJ3QgcmVhbGx5IGRvIG11Y2ggYWJvdXQgdGhpc1xuXHRpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gQm9keSBjb25zdHJ1Y3RvciBkZWZhdWx0cyBvdGhlciB0aGluZ3MgdG8gc3RyaW5nXG5cdHJldHVybiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jztcbn07XG5cbi8qKlxuICogVGhlIEZldGNoIFN0YW5kYXJkIHRyZWF0cyB0aGlzIGFzIGlmIFwidG90YWwgYnl0ZXNcIiBpcyBhIHByb3BlcnR5IG9uIHRoZSBib2R5LlxuICogRm9yIHVzLCB3ZSBoYXZlIHRvIGV4cGxpY2l0bHkgZ2V0IGl0IHdpdGggYSBmdW5jdGlvbi5cbiAqXG4gKiByZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktdG90YWwtYnl0ZXNcbiAqXG4gKiBAcGFyYW0ge2FueX0gb2JqLmJvZHkgQm9keSBvYmplY3QgZnJvbSB0aGUgQm9keSBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtudW1iZXIgfCBudWxsfVxuICovXG5jb25zdCBnZXRUb3RhbEJ5dGVzID0gcmVxdWVzdCA9PiB7XG5cdGNvbnN0IHtib2R5fSA9IHJlcXVlc3RbSU5URVJOQUxTJDJdO1xuXG5cdC8vIEJvZHkgaXMgbnVsbCBvciB1bmRlZmluZWRcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdC8vIEJvZHkgaXMgQmxvYlxuXHRpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0cmV0dXJuIGJvZHkuc2l6ZTtcblx0fVxuXG5cdC8vIEJvZHkgaXMgQnVmZmVyXG5cdGlmIChub2RlX2J1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcblx0XHRyZXR1cm4gYm9keS5sZW5ndGg7XG5cdH1cblxuXHQvLyBEZXRlY3QgZm9ybSBkYXRhIGlucHV0IGZyb20gZm9ybS1kYXRhIG1vZHVsZVxuXHRpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5nZXRMZW5ndGhTeW5jID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGJvZHkuaGFzS25vd25MZW5ndGggJiYgYm9keS5oYXNLbm93bkxlbmd0aCgpID8gYm9keS5nZXRMZW5ndGhTeW5jKCkgOiBudWxsO1xuXHR9XG5cblx0Ly8gQm9keSBpcyBzdHJlYW1cblx0cmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgQm9keSB0byBhIE5vZGUuanMgV3JpdGFibGVTdHJlYW0gKGUuZy4gaHR0cC5SZXF1ZXN0KSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJlYW0uV3JpdGFibGV9IGRlc3QgVGhlIHN0cmVhbSB0byB3cml0ZSB0by5cbiAqIEBwYXJhbSBvYmouYm9keSBCb2R5IG9iamVjdCBmcm9tIHRoZSBCb2R5IGluc3RhbmNlLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmNvbnN0IHdyaXRlVG9TdHJlYW0gPSBhc3luYyAoZGVzdCwge2JvZHl9KSA9PiB7XG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0Ly8gQm9keSBpcyBudWxsXG5cdFx0ZGVzdC5lbmQoKTtcblx0fSBlbHNlIHtcblx0XHQvLyBCb2R5IGlzIHN0cmVhbVxuXHRcdGF3YWl0IHBpcGVsaW5lKGJvZHksIGRlc3QpO1xuXHR9XG59O1xuXG4vKipcbiAqIEhlYWRlcnMuanNcbiAqXG4gKiBIZWFkZXJzIGNsYXNzIG9mZmVycyBjb252ZW5pZW50IGhlbHBlcnNcbiAqL1xuXG4vKiBjOCBpZ25vcmUgbmV4dCA5ICovXG5jb25zdCB2YWxpZGF0ZUhlYWRlck5hbWUgPSB0eXBlb2YgaHR0cC52YWxpZGF0ZUhlYWRlck5hbWUgPT09ICdmdW5jdGlvbicgP1xuXHRodHRwLnZhbGlkYXRlSGVhZGVyTmFtZSA6XG5cdG5hbWUgPT4ge1xuXHRcdGlmICghL15bXFxeYFxcLVxcdyEjJCUmJyorLnx+XSskLy50ZXN0KG5hbWUpKSB7XG5cdFx0XHRjb25zdCBlcnJvciA9IG5ldyBUeXBlRXJyb3IoYEhlYWRlciBuYW1lIG11c3QgYmUgYSB2YWxpZCBIVFRQIHRva2VuIFske25hbWV9XWApO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yLCAnY29kZScsIHt2YWx1ZTogJ0VSUl9JTlZBTElEX0hUVFBfVE9LRU4nfSk7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH07XG5cbi8qIGM4IGlnbm9yZSBuZXh0IDkgKi9cbmNvbnN0IHZhbGlkYXRlSGVhZGVyVmFsdWUgPSB0eXBlb2YgaHR0cC52YWxpZGF0ZUhlYWRlclZhbHVlID09PSAnZnVuY3Rpb24nID9cblx0aHR0cC52YWxpZGF0ZUhlYWRlclZhbHVlIDpcblx0KG5hbWUsIHZhbHVlKSA9PiB7XG5cdFx0aWYgKC9bXlxcdFxcdTAwMjAtXFx1MDA3RVxcdTAwODAtXFx1MDBGRl0vLnRlc3QodmFsdWUpKSB7XG5cdFx0XHRjb25zdCBlcnJvciA9IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBjb250ZW50IFtcIiR7bmFtZX1cIl1gKTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ2NvZGUnLCB7dmFsdWU6ICdFUlJfSU5WQUxJRF9DSEFSJ30pO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtIZWFkZXJzIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IEl0ZXJhYmxlPHJlYWRvbmx5IFtzdHJpbmcsIHN0cmluZ10+IHwgSXRlcmFibGU8SXRlcmFibGU8c3RyaW5nPj59IEhlYWRlcnNJbml0XG4gKi9cblxuLyoqXG4gKiBUaGlzIEZldGNoIEFQSSBpbnRlcmZhY2UgYWxsb3dzIHlvdSB0byBwZXJmb3JtIHZhcmlvdXMgYWN0aW9ucyBvbiBIVFRQIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGhlYWRlcnMuXG4gKiBUaGVzZSBhY3Rpb25zIGluY2x1ZGUgcmV0cmlldmluZywgc2V0dGluZywgYWRkaW5nIHRvLCBhbmQgcmVtb3ZpbmcuXG4gKiBBIEhlYWRlcnMgb2JqZWN0IGhhcyBhbiBhc3NvY2lhdGVkIGhlYWRlciBsaXN0LCB3aGljaCBpcyBpbml0aWFsbHkgZW1wdHkgYW5kIGNvbnNpc3RzIG9mIHplcm8gb3IgbW9yZSBuYW1lIGFuZCB2YWx1ZSBwYWlycy5cbiAqIFlvdSBjYW4gYWRkIHRvIHRoaXMgdXNpbmcgbWV0aG9kcyBsaWtlIGFwcGVuZCgpIChzZWUgRXhhbXBsZXMuKVxuICogSW4gYWxsIG1ldGhvZHMgb2YgdGhpcyBpbnRlcmZhY2UsIGhlYWRlciBuYW1lcyBhcmUgbWF0Y2hlZCBieSBjYXNlLWluc2Vuc2l0aXZlIGJ5dGUgc2VxdWVuY2UuXG4gKlxuICovXG5jbGFzcyBIZWFkZXJzIGV4dGVuZHMgVVJMU2VhcmNoUGFyYW1zIHtcblx0LyoqXG5cdCAqIEhlYWRlcnMgY2xhc3Ncblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7SGVhZGVyc0luaXR9IFtpbml0XSAtIFJlc3BvbnNlIGhlYWRlcnNcblx0ICovXG5cdGNvbnN0cnVjdG9yKGluaXQpIHtcblx0XHQvLyBWYWxpZGF0ZSBhbmQgbm9ybWFsaXplIGluaXQgb2JqZWN0IGluIFtuYW1lLCB2YWx1ZShzKV1bXVxuXHRcdC8qKiBAdHlwZSB7c3RyaW5nW11bXX0gKi9cblx0XHRsZXQgcmVzdWx0ID0gW107XG5cdFx0aWYgKGluaXQgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG5cdFx0XHRjb25zdCByYXcgPSBpbml0LnJhdygpO1xuXHRcdFx0Zm9yIChjb25zdCBbbmFtZSwgdmFsdWVzXSBvZiBPYmplY3QuZW50cmllcyhyYXcpKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKC4uLnZhbHVlcy5tYXAodmFsdWUgPT4gW25hbWUsIHZhbHVlXSkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoaW5pdCA9PSBudWxsKSA7IGVsc2UgaWYgKHR5cGVvZiBpbml0ID09PSAnb2JqZWN0JyAmJiAhbm9kZV91dGlsLnR5cGVzLmlzQm94ZWRQcmltaXRpdmUoaW5pdCkpIHtcblx0XHRcdGNvbnN0IG1ldGhvZCA9IGluaXRbU3ltYm9sLml0ZXJhdG9yXTtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRcdGlmIChtZXRob2QgPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBSZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz5cblx0XHRcdFx0cmVzdWx0LnB1c2goLi4uT2JqZWN0LmVudHJpZXMoaW5pdCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBtZXRob2QgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdIZWFkZXIgcGFpcnMgbXVzdCBiZSBpdGVyYWJsZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+XG5cdFx0XHRcdC8vIE5vdGU6IHBlciBzcGVjIHdlIGhhdmUgdG8gZmlyc3QgZXhoYXVzdCB0aGUgbGlzdHMgdGhlbiBwcm9jZXNzIHRoZW1cblx0XHRcdFx0cmVzdWx0ID0gWy4uLmluaXRdXG5cdFx0XHRcdFx0Lm1hcChwYWlyID0+IHtcblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0dHlwZW9mIHBhaXIgIT09ICdvYmplY3QnIHx8IG5vZGVfdXRpbC50eXBlcy5pc0JveGVkUHJpbWl0aXZlKHBhaXIpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBoZWFkZXIgcGFpciBtdXN0IGJlIGFuIGl0ZXJhYmxlIG9iamVjdCcpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gWy4uLnBhaXJdO1xuXHRcdFx0XHRcdH0pLm1hcChwYWlyID0+IHtcblx0XHRcdFx0XHRcdGlmIChwYWlyLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYSBuYW1lL3ZhbHVlIHR1cGxlJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBbLi4ucGFpcl07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnSGVhZGVyc1xcJzogVGhlIHByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvZiB0eXBlIFxcJyhzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4gb3IgcmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+KScpO1xuXHRcdH1cblxuXHRcdC8vIFZhbGlkYXRlIGFuZCBsb3dlcmNhc2Vcblx0XHRyZXN1bHQgPVxuXHRcdFx0cmVzdWx0Lmxlbmd0aCA+IDAgP1xuXHRcdFx0XHRyZXN1bHQubWFwKChbbmFtZSwgdmFsdWVdKSA9PiB7XG5cdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuXHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyVmFsdWUobmFtZSwgU3RyaW5nKHZhbHVlKSk7XG5cdFx0XHRcdFx0cmV0dXJuIFtTdHJpbmcobmFtZSkudG9Mb3dlckNhc2UoKSwgU3RyaW5nKHZhbHVlKV07XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXG5cdFx0c3VwZXIocmVzdWx0KTtcblxuXHRcdC8vIFJldHVybmluZyBhIFByb3h5IHRoYXQgd2lsbCBsb3dlcmNhc2Uga2V5IG5hbWVzLCB2YWxpZGF0ZSBwYXJhbWV0ZXJzIGFuZCBzb3J0IGtleXNcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG5cdFx0cmV0dXJuIG5ldyBQcm94eSh0aGlzLCB7XG5cdFx0XHRnZXQodGFyZ2V0LCBwLCByZWNlaXZlcikge1xuXHRcdFx0XHRzd2l0Y2ggKHApIHtcblx0XHRcdFx0XHRjYXNlICdhcHBlbmQnOlxuXHRcdFx0XHRcdGNhc2UgJ3NldCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gKG5hbWUsIHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcblx0XHRcdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJWYWx1ZShuYW1lLCBTdHJpbmcodmFsdWUpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbcF0uY2FsbChcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXQsXG5cdFx0XHRcdFx0XHRcdFx0U3RyaW5nKG5hbWUpLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHRcdFx0U3RyaW5nKHZhbHVlKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGNhc2UgJ2RlbGV0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAnaGFzJzpcblx0XHRcdFx0XHRjYXNlICdnZXRBbGwnOlxuXHRcdFx0XHRcdFx0cmV0dXJuIG5hbWUgPT4ge1xuXHRcdFx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlW3BdLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRcdFN0cmluZyhuYW1lKS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Y2FzZSAna2V5cyc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXQuc29ydCgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFNldChVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmtleXMuY2FsbCh0YXJnZXQpKS5rZXlzKCk7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHAsIHJlY2VpdmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdC8qIGM4IGlnbm9yZSBuZXh0ICovXG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcyk7XG5cdH1cblxuXHRnZXQobmFtZSkge1xuXHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMuZ2V0QWxsKG5hbWUpO1xuXHRcdGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRsZXQgdmFsdWUgPSB2YWx1ZXMuam9pbignLCAnKTtcblx0XHRpZiAoL15jb250ZW50LWVuY29kaW5nJC9pLnRlc3QobmFtZSkpIHtcblx0XHRcdHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnID0gdW5kZWZpbmVkKSB7XG5cdFx0Zm9yIChjb25zdCBuYW1lIG9mIHRoaXMua2V5cygpKSB7XG5cdFx0XHRSZWZsZWN0LmFwcGx5KGNhbGxiYWNrLCB0aGlzQXJnLCBbdGhpcy5nZXQobmFtZSksIG5hbWUsIHRoaXNdKTtcblx0XHR9XG5cdH1cblxuXHQqIHZhbHVlcygpIHtcblx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5rZXlzKCkpIHtcblx0XHRcdHlpZWxkIHRoaXMuZ2V0KG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7KCkgPT4gSXRlcmFibGVJdGVyYXRvcjxbc3RyaW5nLCBzdHJpbmddPn1cblx0ICovXG5cdCogZW50cmllcygpIHtcblx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5rZXlzKCkpIHtcblx0XHRcdHlpZWxkIFtuYW1lLCB0aGlzLmdldChuYW1lKV07XG5cdFx0fVxuXHR9XG5cblx0W1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZW50cmllcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE5vZGUtZmV0Y2ggbm9uLXNwZWMgbWV0aG9kXG5cdCAqIHJldHVybmluZyBhbGwgaGVhZGVycyBhbmQgdGhlaXIgdmFsdWVzIGFzIGFycmF5XG5cdCAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT59XG5cdCAqL1xuXHRyYXcoKSB7XG5cdFx0cmV0dXJuIFsuLi50aGlzLmtleXMoKV0ucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuXHRcdFx0cmVzdWx0W2tleV0gPSB0aGlzLmdldEFsbChrZXkpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LCB7fSk7XG5cdH1cblxuXHQvKipcblx0ICogRm9yIGJldHRlciBjb25zb2xlLmxvZyhoZWFkZXJzKSBhbmQgYWxzbyB0byBjb252ZXJ0IEhlYWRlcnMgaW50byBOb2RlLmpzIFJlcXVlc3QgY29tcGF0aWJsZSBmb3JtYXRcblx0ICovXG5cdFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcblx0XHRyZXR1cm4gWy4uLnRoaXMua2V5cygpXS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG5cdFx0XHRjb25zdCB2YWx1ZXMgPSB0aGlzLmdldEFsbChrZXkpO1xuXHRcdFx0Ly8gSHR0cC5yZXF1ZXN0KCkgb25seSBzdXBwb3J0cyBzdHJpbmcgYXMgSG9zdCBoZWFkZXIuXG5cdFx0XHQvLyBUaGlzIGhhY2sgbWFrZXMgc3BlY2lmeWluZyBjdXN0b20gSG9zdCBoZWFkZXIgcG9zc2libGUuXG5cdFx0XHRpZiAoa2V5ID09PSAnaG9zdCcpIHtcblx0XHRcdFx0cmVzdWx0W2tleV0gPSB2YWx1ZXNbMF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRba2V5XSA9IHZhbHVlcy5sZW5ndGggPiAxID8gdmFsdWVzIDogdmFsdWVzWzBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sIHt9KTtcblx0fVxufVxuXG4vKipcbiAqIFJlLXNoYXBpbmcgb2JqZWN0IGZvciBXZWIgSURMIHRlc3RzXG4gKiBPbmx5IG5lZWQgdG8gZG8gaXQgZm9yIG92ZXJyaWRkZW4gbWV0aG9kc1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhcblx0SGVhZGVycy5wcm90b3R5cGUsXG5cdFsnZ2V0JywgJ2VudHJpZXMnLCAnZm9yRWFjaCcsICd2YWx1ZXMnXS5yZWR1Y2UoKHJlc3VsdCwgcHJvcGVydHkpID0+IHtcblx0XHRyZXN1bHRbcHJvcGVydHldID0ge2VudW1lcmFibGU6IHRydWV9O1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sIHt9KVxuKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBIZWFkZXJzIG9iamVjdCBmcm9tIGFuIGh0dHAuSW5jb21pbmdNZXNzYWdlLnJhd0hlYWRlcnMsIGlnbm9yaW5nIHRob3NlIHRoYXQgZG9cbiAqIG5vdCBjb25mb3JtIHRvIEhUVFAgZ3JhbW1hciBwcm9kdWN0aW9ucy5cbiAqIEBwYXJhbSB7aW1wb3J0KCdodHRwJykuSW5jb21pbmdNZXNzYWdlWydyYXdIZWFkZXJzJ119IGhlYWRlcnNcbiAqL1xuZnVuY3Rpb24gZnJvbVJhd0hlYWRlcnMoaGVhZGVycyA9IFtdKSB7XG5cdHJldHVybiBuZXcgSGVhZGVycyhcblx0XHRoZWFkZXJzXG5cdFx0XHQvLyBTcGxpdCBpbnRvIHBhaXJzXG5cdFx0XHQucmVkdWNlKChyZXN1bHQsIHZhbHVlLCBpbmRleCwgYXJyYXkpID0+IHtcblx0XHRcdFx0aWYgKGluZGV4ICUgMiA9PT0gMCkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGFycmF5LnNsaWNlKGluZGV4LCBpbmRleCArIDIpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9LCBbXSlcblx0XHRcdC5maWx0ZXIoKFtuYW1lLCB2YWx1ZV0pID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG5cdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJWYWx1ZShuYW1lLCBTdHJpbmcodmFsdWUpKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXG5cdCk7XG59XG5cbmNvbnN0IHJlZGlyZWN0U3RhdHVzID0gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcblxuLyoqXG4gKiBSZWRpcmVjdCBjb2RlIG1hdGNoaW5nXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGUgLSBTdGF0dXMgY29kZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNSZWRpcmVjdCA9IGNvZGUgPT4ge1xuXHRyZXR1cm4gcmVkaXJlY3RTdGF0dXMuaGFzKGNvZGUpO1xufTtcblxuLyoqXG4gKiBSZXNwb25zZS5qc1xuICpcbiAqIFJlc3BvbnNlIGNsYXNzIHByb3ZpZGVzIGNvbnRlbnQgZGVjb2RpbmdcbiAqL1xuXG5jb25zdCBJTlRFUk5BTFMkMSA9IFN5bWJvbCgnUmVzcG9uc2UgaW50ZXJuYWxzJyk7XG5cbi8qKlxuICogUmVzcG9uc2UgY2xhc3NcbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jbGFzc1xuICpcbiAqIEBwYXJhbSAgIFN0cmVhbSAgYm9keSAgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gICBPYmplY3QgIG9wdHMgIFJlc3BvbnNlIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuY2xhc3MgUmVzcG9uc2UgZXh0ZW5kcyBCb2R5IHtcblx0Y29uc3RydWN0b3IoYm9keSA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKGJvZHksIG9wdGlvbnMpO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcSwgbm8tbmVnYXRlZC1jb25kaXRpb25cblx0XHRjb25zdCBzdGF0dXMgPSBvcHRpb25zLnN0YXR1cyAhPSBudWxsID8gb3B0aW9ucy5zdGF0dXMgOiAyMDA7XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmIChib2R5ICE9PSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKGJvZHksIHRoaXMpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpc1tJTlRFUk5BTFMkMV0gPSB7XG5cdFx0XHR0eXBlOiAnZGVmYXVsdCcsXG5cdFx0XHR1cmw6IG9wdGlvbnMudXJsLFxuXHRcdFx0c3RhdHVzLFxuXHRcdFx0c3RhdHVzVGV4dDogb3B0aW9ucy5zdGF0dXNUZXh0IHx8ICcnLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdGNvdW50ZXI6IG9wdGlvbnMuY291bnRlcixcblx0XHRcdGhpZ2hXYXRlck1hcms6IG9wdGlvbnMuaGlnaFdhdGVyTWFya1xuXHRcdH07XG5cdH1cblxuXHRnZXQgdHlwZSgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0udHlwZTtcblx0fVxuXG5cdGdldCB1cmwoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLnVybCB8fCAnJztcblx0fVxuXG5cdGdldCBzdGF0dXMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLnN0YXR1cztcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZW5pZW5jZSBwcm9wZXJ0eSByZXByZXNlbnRpbmcgaWYgdGhlIHJlcXVlc3QgZW5kZWQgbm9ybWFsbHlcblx0ICovXG5cdGdldCBvaygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzID49IDIwMCAmJiB0aGlzW0lOVEVSTkFMUyQxXS5zdGF0dXMgPCAzMDA7XG5cdH1cblxuXHRnZXQgcmVkaXJlY3RlZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uY291bnRlciA+IDA7XG5cdH1cblxuXHRnZXQgc3RhdHVzVGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzVGV4dDtcblx0fVxuXG5cdGdldCBoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5oZWFkZXJzO1xuXHR9XG5cblx0Z2V0IGhpZ2hXYXRlck1hcmsoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLmhpZ2hXYXRlck1hcms7XG5cdH1cblxuXHQvKipcblx0ICogQ2xvbmUgdGhpcyByZXNwb25zZVxuXHQgKlxuXHQgKiBAcmV0dXJuICBSZXNwb25zZVxuXHQgKi9cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBSZXNwb25zZShjbG9uZSh0aGlzLCB0aGlzLmhpZ2hXYXRlck1hcmspLCB7XG5cdFx0XHR0eXBlOiB0aGlzLnR5cGUsXG5cdFx0XHR1cmw6IHRoaXMudXJsLFxuXHRcdFx0c3RhdHVzOiB0aGlzLnN0YXR1cyxcblx0XHRcdHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdG9rOiB0aGlzLm9rLFxuXHRcdFx0cmVkaXJlY3RlZDogdGhpcy5yZWRpcmVjdGVkLFxuXHRcdFx0c2l6ZTogdGhpcy5zaXplLFxuXHRcdFx0aGlnaFdhdGVyTWFyazogdGhpcy5oaWdoV2F0ZXJNYXJrXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICBUaGUgVVJMIHRoYXQgdGhlIG5ldyByZXNwb25zZSBpcyB0byBvcmlnaW5hdGUgZnJvbS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1cyBBbiBvcHRpb25hbCBzdGF0dXMgY29kZSBmb3IgdGhlIHJlc3BvbnNlIChlLmcuLCAzMDIuKVxuXHQgKiBAcmV0dXJucyB7UmVzcG9uc2V9ICAgIEEgUmVzcG9uc2Ugb2JqZWN0LlxuXHQgKi9cblx0c3RhdGljIHJlZGlyZWN0KHVybCwgc3RhdHVzID0gMzAyKSB7XG5cdFx0aWYgKCFpc1JlZGlyZWN0KHN0YXR1cykpIHtcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSBcInJlZGlyZWN0XCIgb24gXCJyZXNwb25zZVwiOiBJbnZhbGlkIHN0YXR1cyBjb2RlJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG5cdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdGxvY2F0aW9uOiBuZXcgVVJMKHVybCkudG9TdHJpbmcoKVxuXHRcdFx0fSxcblx0XHRcdHN0YXR1c1xuXHRcdH0pO1xuXHR9XG5cblx0c3RhdGljIGVycm9yKCkge1xuXHRcdGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG5cdFx0cmVzcG9uc2VbSU5URVJOQUxTJDFdLnR5cGUgPSAnZXJyb3InO1xuXHRcdHJldHVybiByZXNwb25zZTtcblx0fVxuXG5cdHN0YXRpYyBqc29uKGRhdGEgPSB1bmRlZmluZWQsIGluaXQgPSB7fSkge1xuXHRcdGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcblxuXHRcdGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgaXMgbm90IEpTT04gc2VyaWFsaXphYmxlJyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQgJiYgaW5pdC5oZWFkZXJzKTtcblxuXHRcdGlmICghaGVhZGVycy5oYXMoJ2NvbnRlbnQtdHlwZScpKSB7XG5cdFx0XHRoZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIHtcblx0XHRcdC4uLmluaXQsXG5cdFx0XHRoZWFkZXJzXG5cdFx0fSk7XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuICdSZXNwb25zZSc7XG5cdH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UucHJvdG90eXBlLCB7XG5cdHR5cGU6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0dXJsOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHN0YXR1czoge2VudW1lcmFibGU6IHRydWV9LFxuXHRvazoge2VudW1lcmFibGU6IHRydWV9LFxuXHRyZWRpcmVjdGVkOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHN0YXR1c1RleHQ6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0aGVhZGVyczoge2VudW1lcmFibGU6IHRydWV9LFxuXHRjbG9uZToge2VudW1lcmFibGU6IHRydWV9XG59KTtcblxuY29uc3QgZ2V0U2VhcmNoID0gcGFyc2VkVVJMID0+IHtcblx0aWYgKHBhcnNlZFVSTC5zZWFyY2gpIHtcblx0XHRyZXR1cm4gcGFyc2VkVVJMLnNlYXJjaDtcblx0fVxuXG5cdGNvbnN0IGxhc3RPZmZzZXQgPSBwYXJzZWRVUkwuaHJlZi5sZW5ndGggLSAxO1xuXHRjb25zdCBoYXNoID0gcGFyc2VkVVJMLmhhc2ggfHwgKHBhcnNlZFVSTC5ocmVmW2xhc3RPZmZzZXRdID09PSAnIycgPyAnIycgOiAnJyk7XG5cdHJldHVybiBwYXJzZWRVUkwuaHJlZltsYXN0T2Zmc2V0IC0gaGFzaC5sZW5ndGhdID09PSAnPycgPyAnPycgOiAnJztcbn07XG5cbi8qKlxuICogQGV4dGVybmFsIFVSTFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTHxVUkx9XG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIHV0aWxzL3JlZmVycmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3N0cmlwLXVybHxSZWZlcnJlciBQb2xpY3kgwqc4LjQuIFN0cmlwIHVybCBmb3IgdXNlIGFzIGEgcmVmZXJyZXJ9XG4gKiBAcGFyYW0ge3N0cmluZ30gVVJMXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcmlnaW5Pbmx5PWZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyKHVybCwgb3JpZ2luT25seSA9IGZhbHNlKSB7XG5cdC8vIDEuIElmIHVybCBpcyBudWxsLCByZXR1cm4gbm8gcmVmZXJyZXIuXG5cdGlmICh1cmwgPT0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXHR9XG5cblx0dXJsID0gbmV3IFVSTCh1cmwpO1xuXG5cdC8vIDIuIElmIHVybCdzIHNjaGVtZSBpcyBhIGxvY2FsIHNjaGVtZSwgdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG5cdGlmICgvXihhYm91dHxibG9ifGRhdGEpOiQvLnRlc3QodXJsLnByb3RvY29sKSkge1xuXHRcdHJldHVybiAnbm8tcmVmZXJyZXInO1xuXHR9XG5cblx0Ly8gMy4gU2V0IHVybCdzIHVzZXJuYW1lIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG5cdHVybC51c2VybmFtZSA9ICcnO1xuXG5cdC8vIDQuIFNldCB1cmwncyBwYXNzd29yZCB0byBudWxsLlxuXHQvLyBOb3RlOiBgbnVsbGAgYXBwZWFycyB0byBiZSBhIG1pc3Rha2UgYXMgdGhpcyBhY3R1YWxseSByZXN1bHRzIGluIHRoZSBwYXNzd29yZCBiZWluZyBgXCJudWxsXCJgLlxuXHR1cmwucGFzc3dvcmQgPSAnJztcblxuXHQvLyA1LiBTZXQgdXJsJ3MgZnJhZ21lbnQgdG8gbnVsbC5cblx0Ly8gTm90ZTogYG51bGxgIGFwcGVhcnMgdG8gYmUgYSBtaXN0YWtlIGFzIHRoaXMgYWN0dWFsbHkgcmVzdWx0cyBpbiB0aGUgZnJhZ21lbnQgYmVpbmcgYFwiI251bGxcImAuXG5cdHVybC5oYXNoID0gJyc7XG5cblx0Ly8gNi4gSWYgdGhlIG9yaWdpbi1vbmx5IGZsYWcgaXMgdHJ1ZSwgdGhlbjpcblx0aWYgKG9yaWdpbk9ubHkpIHtcblx0XHQvLyA2LjEuIFNldCB1cmwncyBwYXRoIHRvIG51bGwuXG5cdFx0Ly8gTm90ZTogYG51bGxgIGFwcGVhcnMgdG8gYmUgYSBtaXN0YWtlIGFzIHRoaXMgYWN0dWFsbHkgcmVzdWx0cyBpbiB0aGUgcGF0aCBiZWluZyBgXCIvbnVsbFwiYC5cblx0XHR1cmwucGF0aG5hbWUgPSAnJztcblxuXHRcdC8vIDYuMi4gU2V0IHVybCdzIHF1ZXJ5IHRvIG51bGwuXG5cdFx0Ly8gTm90ZTogYG51bGxgIGFwcGVhcnMgdG8gYmUgYSBtaXN0YWtlIGFzIHRoaXMgYWN0dWFsbHkgcmVzdWx0cyBpbiB0aGUgcXVlcnkgYmVpbmcgYFwiP251bGxcImAuXG5cdFx0dXJsLnNlYXJjaCA9ICcnO1xuXHR9XG5cblx0Ly8gNy4gUmV0dXJuIHVybC5cblx0cmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZW51bWRlZi1yZWZlcnJlcnBvbGljeXxlbnVtIFJlZmVycmVyUG9saWN5fVxuICovXG5jb25zdCBSZWZlcnJlclBvbGljeSA9IG5ldyBTZXQoW1xuXHQnJyxcblx0J25vLXJlZmVycmVyJyxcblx0J25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJyxcblx0J3NhbWUtb3JpZ2luJyxcblx0J29yaWdpbicsXG5cdCdzdHJpY3Qtb3JpZ2luJyxcblx0J29yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicsXG5cdCdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcblx0J3Vuc2FmZS11cmwnXG5dKTtcblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGVmYXVsdC1yZWZlcnJlci1wb2xpY3l8ZGVmYXVsdCByZWZlcnJlciBwb2xpY3l9XG4gKi9cbmNvbnN0IERFRkFVTFRfUkVGRVJSRVJfUE9MSUNZID0gJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nO1xuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNyZWZlcnJlci1wb2xpY2llc3xSZWZlcnJlciBQb2xpY3kgwqczLiBSZWZlcnJlciBQb2xpY2llc31cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWZlcnJlclBvbGljeVxuICogQHJldHVybnMge3N0cmluZ30gcmVmZXJyZXJQb2xpY3lcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSkge1xuXHRpZiAoIVJlZmVycmVyUG9saWN5LmhhcyhyZWZlcnJlclBvbGljeSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHJlZmVycmVyUG9saWN5OiAke3JlZmVycmVyUG9saWN5fWApO1xuXHR9XG5cblx0cmV0dXJuIHJlZmVycmVyUG9saWN5O1xufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc2VjdXJlLWNvbnRleHRzLyNpcy1vcmlnaW4tdHJ1c3R3b3J0aHl8UmVmZXJyZXIgUG9saWN5IMKnMy4yLiBJcyBvcmlnaW4gcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHk/fVxuICogQHBhcmFtIHtleHRlcm5hbDpVUkx9IHVybFxuICogQHJldHVybnMgYHRydWVgOiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIsIGBmYWxzZWA6IFwiTm90IFRydXN0d29ydGh5XCJcbiAqL1xuZnVuY3Rpb24gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5KHVybCkge1xuXHQvLyAxLiBJZiBvcmlnaW4gaXMgYW4gb3BhcXVlIG9yaWdpbiwgcmV0dXJuIFwiTm90IFRydXN0d29ydGh5XCIuXG5cdC8vIE5vdCBhcHBsaWNhYmxlXG5cblx0Ly8gMi4gQXNzZXJ0OiBvcmlnaW4gaXMgYSB0dXBsZSBvcmlnaW4uXG5cdC8vIE5vdCBmb3IgaW1wbGVtZW50YXRpb25zXG5cblx0Ly8gMy4gSWYgb3JpZ2luJ3Mgc2NoZW1lIGlzIGVpdGhlciBcImh0dHBzXCIgb3IgXCJ3c3NcIiwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0aWYgKC9eKGh0dHB8d3MpczokLy50ZXN0KHVybC5wcm90b2NvbCkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDQuIElmIG9yaWdpbidzIGhvc3QgY29tcG9uZW50IG1hdGNoZXMgb25lIG9mIHRoZSBDSURSIG5vdGF0aW9ucyAxMjcuMC4wLjAvOCBvciA6OjEvMTI4IFtSRkM0NjMyXSwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0Y29uc3QgaG9zdElwID0gdXJsLmhvc3QucmVwbGFjZSgvKF5cXFspfChdJCkvZywgJycpO1xuXHRjb25zdCBob3N0SVBWZXJzaW9uID0gbm9kZV9uZXQuaXNJUChob3N0SXApO1xuXG5cdGlmIChob3N0SVBWZXJzaW9uID09PSA0ICYmIC9eMTI3XFwuLy50ZXN0KGhvc3RJcCkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChob3N0SVBWZXJzaW9uID09PSA2ICYmIC9eKCgoMCs6KXs3fSl8KDo6KDArOil7MCw2fSkpMCoxJC8udGVzdChob3N0SXApKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyA1LiBJZiBvcmlnaW4ncyBob3N0IGNvbXBvbmVudCBpcyBcImxvY2FsaG9zdFwiIG9yIGZhbGxzIHdpdGhpbiBcIi5sb2NhbGhvc3RcIiwgYW5kIHRoZSB1c2VyIGFnZW50IGNvbmZvcm1zIHRvIHRoZSBuYW1lIHJlc29sdXRpb24gcnVsZXMgaW4gW2xldC1sb2NhbGhvc3QtYmUtbG9jYWxob3N0XSwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0Ly8gV2UgYXJlIHJldHVybmluZyBGQUxTRSBoZXJlIGJlY2F1c2Ugd2UgY2Fubm90IGVuc3VyZSBjb25mb3JtYW5jZSB0b1xuXHQvLyBsZXQtbG9jYWxob3N0LWJlLWxvYWxob3N0IChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtd2VzdC1sZXQtbG9jYWxob3N0LWJlLWxvY2FsaG9zdClcblx0aWYgKHVybC5ob3N0ID09PSAnbG9jYWxob3N0JyB8fCB1cmwuaG9zdC5lbmRzV2l0aCgnLmxvY2FsaG9zdCcpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gNi4gSWYgb3JpZ2luJ3Mgc2NoZW1lIGNvbXBvbmVudCBpcyBmaWxlLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAodXJsLnByb3RvY29sID09PSAnZmlsZTonKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyA3LiBJZiBvcmlnaW4ncyBzY2hlbWUgY29tcG9uZW50IGlzIG9uZSB3aGljaCB0aGUgdXNlciBhZ2VudCBjb25zaWRlcnMgdG8gYmUgYXV0aGVudGljYXRlZCwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblx0Ly8gTm90IHN1cHBvcnRlZFxuXG5cdC8vIDguIElmIG9yaWdpbiBoYXMgYmVlbiBjb25maWd1cmVkIGFzIGEgdHJ1c3R3b3J0aHkgb3JpZ2luLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHQvLyBOb3Qgc3VwcG9ydGVkXG5cblx0Ly8gOS4gUmV0dXJuIFwiTm90IFRydXN0d29ydGh5XCIuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXNlY3VyZS1jb250ZXh0cy8jaXMtdXJsLXRydXN0d29ydGh5fFJlZmVycmVyIFBvbGljeSDCpzMuMy4gSXMgdXJsIHBvdGVudGlhbGx5IHRydXN0d29ydGh5P31cbiAqIEBwYXJhbSB7ZXh0ZXJuYWw6VVJMfSB1cmxcbiAqIEByZXR1cm5zIGB0cnVlYDogXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLCBgZmFsc2VgOiBcIk5vdCBUcnVzdHdvcnRoeVwiXG4gKi9cbmZ1bmN0aW9uIGlzVXJsUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwpIHtcblx0Ly8gMS4gSWYgdXJsIGlzIFwiYWJvdXQ6YmxhbmtcIiBvciBcImFib3V0OnNyY2RvY1wiLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAoL15hYm91dDooYmxhbmt8c3JjZG9jKSQvLnRlc3QodXJsKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gMi4gSWYgdXJsJ3Mgc2NoZW1lIGlzIFwiZGF0YVwiLCByZXR1cm4gXCJQb3RlbnRpYWxseSBUcnVzdHdvcnRoeVwiLlxuXHRpZiAodXJsLnByb3RvY29sID09PSAnZGF0YTonKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBOb3RlOiBUaGUgb3JpZ2luIG9mIGJsb2I6IGFuZCBmaWxlc3lzdGVtOiBVUkxzIGlzIHRoZSBvcmlnaW4gb2YgdGhlIGNvbnRleHQgaW4gd2hpY2ggdGhleSB3ZXJlXG5cdC8vIGNyZWF0ZWQuIFRoZXJlZm9yZSwgYmxvYnMgY3JlYXRlZCBpbiBhIHRydXN0d29ydGh5IG9yaWdpbiB3aWxsIHRoZW1zZWx2ZXMgYmUgcG90ZW50aWFsbHlcblx0Ly8gdHJ1c3R3b3J0aHkuXG5cdGlmICgvXihibG9ifGZpbGVzeXN0ZW0pOiQvLnRlc3QodXJsLnByb3RvY29sKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gMy4gUmV0dXJuIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIMKnMy4yIElzIG9yaWdpbiBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeT8gb24gdXJsJ3Mgb3JpZ2luLlxuXHRyZXR1cm4gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5KHVybCk7XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHJlZmVycmVyVVJMIHRvIGVuZm9yY2UgYW55IGV4dHJhIHNlY3VyaXR5IHBvbGljeSBjb25zaWRlcmF0aW9ucy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNkZXRlcm1pbmUtcmVxdWVzdHMtcmVmZXJyZXJ8UmVmZXJyZXIgUG9saWN5IMKnOC4zLiBEZXRlcm1pbmUgcmVxdWVzdCdzIFJlZmVycmVyfSwgc3RlcCA3XG4gKiBAY2FsbGJhY2sgbW9kdWxlOnV0aWxzL3JlZmVycmVyfnJlZmVycmVyVVJMQ2FsbGJhY2tcbiAqIEBwYXJhbSB7ZXh0ZXJuYWw6VVJMfSByZWZlcnJlclVSTFxuICogQHJldHVybnMge2V4dGVybmFsOlVSTH0gbW9kaWZpZWQgcmVmZXJyZXJVUkxcbiAqL1xuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSByZWZlcnJlck9yaWdpbiB0byBlbmZvcmNlIGFueSBleHRyYSBzZWN1cml0eSBwb2xpY3kgY29uc2lkZXJhdGlvbnMuXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyfFJlZmVycmVyIFBvbGljeSDCpzguMy4gRGV0ZXJtaW5lIHJlcXVlc3QncyBSZWZlcnJlcn0sIHN0ZXAgN1xuICogQGNhbGxiYWNrIG1vZHVsZTp1dGlscy9yZWZlcnJlcn5yZWZlcnJlck9yaWdpbkNhbGxiYWNrXG4gKiBAcGFyYW0ge2V4dGVybmFsOlVSTH0gcmVmZXJyZXJPcmlnaW5cbiAqIEByZXR1cm5zIHtleHRlcm5hbDpVUkx9IG1vZGlmaWVkIHJlZmVycmVyT3JpZ2luXG4gKi9cblxuLyoqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyfFJlZmVycmVyIFBvbGljeSDCpzguMy4gRGV0ZXJtaW5lIHJlcXVlc3QncyBSZWZlcnJlcn1cbiAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICogQHBhcmFtIHtvYmplY3R9IG9cbiAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3JlZmVycmVyfnJlZmVycmVyVVJMQ2FsbGJhY2t9IG8ucmVmZXJyZXJVUkxDYWxsYmFja1xuICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcmVmZXJyZXJ+cmVmZXJyZXJPcmlnaW5DYWxsYmFja30gby5yZWZlcnJlck9yaWdpbkNhbGxiYWNrXG4gKiBAcmV0dXJucyB7ZXh0ZXJuYWw6VVJMfSBSZXF1ZXN0J3MgcmVmZXJyZXJcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihyZXF1ZXN0LCB7cmVmZXJyZXJVUkxDYWxsYmFjaywgcmVmZXJyZXJPcmlnaW5DYWxsYmFja30gPSB7fSkge1xuXHQvLyBUaGVyZSBhcmUgMiBub3RlcyBpbiB0aGUgc3BlY2lmaWNhdGlvbiBhYm91dCBpbnZhbGlkIHByZS1jb25kaXRpb25zLiAgV2UgcmV0dXJuIG51bGwsIGhlcmUsIGZvclxuXHQvLyB0aGVzZSBjYXNlczpcblx0Ly8gPiBOb3RlOiBJZiByZXF1ZXN0J3MgcmVmZXJyZXIgaXMgXCJuby1yZWZlcnJlclwiLCBGZXRjaCB3aWxsIG5vdCBjYWxsIGludG8gdGhpcyBhbGdvcml0aG0uXG5cdC8vID4gTm90ZTogSWYgcmVxdWVzdCdzIHJlZmVycmVyIHBvbGljeSBpcyB0aGUgZW1wdHkgc3RyaW5nLCBGZXRjaCB3aWxsIG5vdCBjYWxsIGludG8gdGhpc1xuXHQvLyA+IGFsZ29yaXRobS5cblx0aWYgKHJlcXVlc3QucmVmZXJyZXIgPT09ICduby1yZWZlcnJlcicgfHwgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9PT0gJycpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIDEuIExldCBwb2xpY3kgYmUgcmVxdWVzdCdzIGFzc29jaWF0ZWQgcmVmZXJyZXIgcG9saWN5LlxuXHRjb25zdCBwb2xpY3kgPSByZXF1ZXN0LnJlZmVycmVyUG9saWN5O1xuXG5cdC8vIDIuIExldCBlbnZpcm9ubWVudCBiZSByZXF1ZXN0J3MgY2xpZW50LlxuXHQvLyBub3QgYXBwbGljYWJsZSB0byBub2RlLmpzXG5cblx0Ly8gMy4gU3dpdGNoIG9uIHJlcXVlc3QncyByZWZlcnJlcjpcblx0aWYgKHJlcXVlc3QucmVmZXJyZXIgPT09ICdhYm91dDpjbGllbnQnKSB7XG5cdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cdH1cblxuXHQvLyBcImEgVVJMXCI6IExldCByZWZlcnJlclNvdXJjZSBiZSByZXF1ZXN0J3MgcmVmZXJyZXIuXG5cdGNvbnN0IHJlZmVycmVyU291cmNlID0gcmVxdWVzdC5yZWZlcnJlcjtcblxuXHQvLyA0LiBMZXQgcmVxdWVzdCdzIHJlZmVycmVyVVJMIGJlIHRoZSByZXN1bHQgb2Ygc3RyaXBwaW5nIHJlZmVycmVyU291cmNlIGZvciB1c2UgYXMgYSByZWZlcnJlci5cblx0bGV0IHJlZmVycmVyVVJMID0gc3RyaXBVUkxGb3JVc2VBc0FSZWZlcnJlcihyZWZlcnJlclNvdXJjZSk7XG5cblx0Ly8gNS4gTGV0IHJlZmVycmVyT3JpZ2luIGJlIHRoZSByZXN1bHQgb2Ygc3RyaXBwaW5nIHJlZmVycmVyU291cmNlIGZvciB1c2UgYXMgYSByZWZlcnJlciwgd2l0aCB0aGVcblx0Ly8gICAgb3JpZ2luLW9ubHkgZmxhZyBzZXQgdG8gdHJ1ZS5cblx0bGV0IHJlZmVycmVyT3JpZ2luID0gc3RyaXBVUkxGb3JVc2VBc0FSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSk7XG5cblx0Ly8gNi4gSWYgdGhlIHJlc3VsdCBvZiBzZXJpYWxpemluZyByZWZlcnJlclVSTCBpcyBhIHN0cmluZyB3aG9zZSBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIDQwOTYsIHNldFxuXHQvLyAgICByZWZlcnJlclVSTCB0byByZWZlcnJlck9yaWdpbi5cblx0aWYgKHJlZmVycmVyVVJMLnRvU3RyaW5nKCkubGVuZ3RoID4gNDA5Nikge1xuXHRcdHJlZmVycmVyVVJMID0gcmVmZXJyZXJPcmlnaW47XG5cdH1cblxuXHQvLyA3LiBUaGUgdXNlciBhZ2VudCBNQVkgYWx0ZXIgcmVmZXJyZXJVUkwgb3IgcmVmZXJyZXJPcmlnaW4gYXQgdGhpcyBwb2ludCB0byBlbmZvcmNlIGFyYml0cmFyeVxuXHQvLyAgICBwb2xpY3kgY29uc2lkZXJhdGlvbnMgaW4gdGhlIGludGVyZXN0cyBvZiBtaW5pbWl6aW5nIGRhdGEgbGVha2FnZS4gRm9yIGV4YW1wbGUsIHRoZSB1c2VyXG5cdC8vICAgIGFnZW50IGNvdWxkIHN0cmlwIHRoZSBVUkwgZG93biB0byBhbiBvcmlnaW4sIG1vZGlmeSBpdHMgaG9zdCwgcmVwbGFjZSBpdCB3aXRoIGFuIGVtcHR5XG5cdC8vICAgIHN0cmluZywgZXRjLlxuXHRpZiAocmVmZXJyZXJVUkxDYWxsYmFjaykge1xuXHRcdHJlZmVycmVyVVJMID0gcmVmZXJyZXJVUkxDYWxsYmFjayhyZWZlcnJlclVSTCk7XG5cdH1cblxuXHRpZiAocmVmZXJyZXJPcmlnaW5DYWxsYmFjaykge1xuXHRcdHJlZmVycmVyT3JpZ2luID0gcmVmZXJyZXJPcmlnaW5DYWxsYmFjayhyZWZlcnJlck9yaWdpbik7XG5cdH1cblxuXHQvLyA4LkV4ZWN1dGUgdGhlIHN0YXRlbWVudHMgY29ycmVzcG9uZGluZyB0byB0aGUgdmFsdWUgb2YgcG9saWN5OlxuXHRjb25zdCBjdXJyZW50VVJMID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG5cblx0c3dpdGNoIChwb2xpY3kpIHtcblx0XHRjYXNlICduby1yZWZlcnJlcic6XG5cdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblxuXHRcdGNhc2UgJ29yaWdpbic6XG5cdFx0XHRyZXR1cm4gcmVmZXJyZXJPcmlnaW47XG5cblx0XHRjYXNlICd1bnNhZmUtdXJsJzpcblx0XHRcdHJldHVybiByZWZlcnJlclVSTDtcblxuXHRcdGNhc2UgJ3N0cmljdC1vcmlnaW4nOlxuXHRcdFx0Ly8gMS4gSWYgcmVmZXJyZXJVUkwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgYW5kIHJlcXVlc3QncyBjdXJyZW50IFVSTCBpcyBub3QgYVxuXHRcdFx0Ly8gICAgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cblx0XHRcdGlmIChpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkocmVmZXJyZXJVUkwpICYmICFpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoY3VycmVudFVSTCkpIHtcblx0XHRcdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDIuIFJldHVybiByZWZlcnJlck9yaWdpbi5cblx0XHRcdHJldHVybiByZWZlcnJlck9yaWdpbi50b1N0cmluZygpO1xuXG5cdFx0Y2FzZSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6XG5cdFx0XHQvLyAxLiBJZiB0aGUgb3JpZ2luIG9mIHJlZmVycmVyVVJMIGFuZCB0aGUgb3JpZ2luIG9mIHJlcXVlc3QncyBjdXJyZW50IFVSTCBhcmUgdGhlIHNhbWUsIHRoZW5cblx0XHRcdC8vICAgIHJldHVybiByZWZlcnJlclVSTC5cblx0XHRcdGlmIChyZWZlcnJlclVSTC5vcmlnaW4gPT09IGN1cnJlbnRVUkwub3JpZ2luKSB7XG5cdFx0XHRcdHJldHVybiByZWZlcnJlclVSTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gMi4gSWYgcmVmZXJyZXJVUkwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgYW5kIHJlcXVlc3QncyBjdXJyZW50IFVSTCBpcyBub3QgYVxuXHRcdFx0Ly8gICAgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cblx0XHRcdGlmIChpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkocmVmZXJyZXJVUkwpICYmICFpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoY3VycmVudFVSTCkpIHtcblx0XHRcdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDMuIFJldHVybiByZWZlcnJlck9yaWdpbi5cblx0XHRcdHJldHVybiByZWZlcnJlck9yaWdpbjtcblxuXHRcdGNhc2UgJ3NhbWUtb3JpZ2luJzpcblx0XHRcdC8vIDEuIElmIHRoZSBvcmlnaW4gb2YgcmVmZXJyZXJVUkwgYW5kIHRoZSBvcmlnaW4gb2YgcmVxdWVzdCdzIGN1cnJlbnQgVVJMIGFyZSB0aGUgc2FtZSwgdGhlblxuXHRcdFx0Ly8gICAgcmV0dXJuIHJlZmVycmVyVVJMLlxuXHRcdFx0aWYgKHJlZmVycmVyVVJMLm9yaWdpbiA9PT0gY3VycmVudFVSTC5vcmlnaW4pIHtcblx0XHRcdFx0cmV0dXJuIHJlZmVycmVyVVJMO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAyLiBSZXR1cm4gbm8gcmVmZXJyZXIuXG5cdFx0XHRyZXR1cm4gJ25vLXJlZmVycmVyJztcblxuXHRcdGNhc2UgJ29yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6XG5cdFx0XHQvLyAxLiBJZiB0aGUgb3JpZ2luIG9mIHJlZmVycmVyVVJMIGFuZCB0aGUgb3JpZ2luIG9mIHJlcXVlc3QncyBjdXJyZW50IFVSTCBhcmUgdGhlIHNhbWUsIHRoZW5cblx0XHRcdC8vICAgIHJldHVybiByZWZlcnJlclVSTC5cblx0XHRcdGlmIChyZWZlcnJlclVSTC5vcmlnaW4gPT09IGN1cnJlbnRVUkwub3JpZ2luKSB7XG5cdFx0XHRcdHJldHVybiByZWZlcnJlclVSTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIHJlZmVycmVyT3JpZ2luLlxuXHRcdFx0cmV0dXJuIHJlZmVycmVyT3JpZ2luO1xuXG5cdFx0Y2FzZSAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnOlxuXHRcdFx0Ly8gMS4gSWYgcmVmZXJyZXJVUkwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgYW5kIHJlcXVlc3QncyBjdXJyZW50IFVSTCBpcyBub3QgYVxuXHRcdFx0Ly8gICAgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cblx0XHRcdGlmIChpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkocmVmZXJyZXJVUkwpICYmICFpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoY3VycmVudFVSTCkpIHtcblx0XHRcdFx0cmV0dXJuICduby1yZWZlcnJlcic7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDIuIFJldHVybiByZWZlcnJlclVSTC5cblx0XHRcdHJldHVybiByZWZlcnJlclVSTDtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHJlZmVycmVyUG9saWN5OiAke3BvbGljeX1gKTtcblx0fVxufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNwYXJzZS1yZWZlcnJlci1wb2xpY3ktZnJvbS1oZWFkZXJ8UmVmZXJyZXIgUG9saWN5IMKnOC4xLiBQYXJzZSBhIHJlZmVycmVyIHBvbGljeSBmcm9tIGEgUmVmZXJyZXItUG9saWN5IGhlYWRlcn1cbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVycyBSZXNwb25zZSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBwb2xpY3lcbiAqL1xuZnVuY3Rpb24gcGFyc2VSZWZlcnJlclBvbGljeUZyb21IZWFkZXIoaGVhZGVycykge1xuXHQvLyAxLiBMZXQgcG9saWN5LXRva2VucyBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzIGdpdmVuIGBSZWZlcnJlci1Qb2xpY3lgXG5cdC8vICAgIGFuZCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG5cdGNvbnN0IHBvbGljeVRva2VucyA9IChoZWFkZXJzLmdldCgncmVmZXJyZXItcG9saWN5JykgfHwgJycpLnNwbGl0KC9bLFxcc10rLyk7XG5cblx0Ly8gMi4gTGV0IHBvbGljeSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuXHRsZXQgcG9saWN5ID0gJyc7XG5cblx0Ly8gMy4gRm9yIGVhY2ggdG9rZW4gaW4gcG9saWN5LXRva2VucywgaWYgdG9rZW4gaXMgYSByZWZlcnJlciBwb2xpY3kgYW5kIHRva2VuIGlzIG5vdCB0aGUgZW1wdHlcblx0Ly8gICAgc3RyaW5nLCB0aGVuIHNldCBwb2xpY3kgdG8gdG9rZW4uXG5cdC8vIE5vdGU6IFRoaXMgYWxnb3JpdGhtIGxvb3BzIG92ZXIgbXVsdGlwbGUgcG9saWN5IHZhbHVlcyB0byBhbGxvdyBkZXBsb3ltZW50IG9mIG5ldyBwb2xpY3lcblx0Ly8gdmFsdWVzIHdpdGggZmFsbGJhY2tzIGZvciBvbGRlciB1c2VyIGFnZW50cywgYXMgZGVzY3JpYmVkIGluIMKnIDExLjEgVW5rbm93biBQb2xpY3kgVmFsdWVzLlxuXHRmb3IgKGNvbnN0IHRva2VuIG9mIHBvbGljeVRva2Vucykge1xuXHRcdGlmICh0b2tlbiAmJiBSZWZlcnJlclBvbGljeS5oYXModG9rZW4pKSB7XG5cdFx0XHRwb2xpY3kgPSB0b2tlbjtcblx0XHR9XG5cdH1cblxuXHQvLyA0LiBSZXR1cm4gcG9saWN5LlxuXHRyZXR1cm4gcG9saWN5O1xufVxuXG4vKipcbiAqIFJlcXVlc3QuanNcbiAqXG4gKiBSZXF1ZXN0IGNsYXNzIGNvbnRhaW5zIHNlcnZlciBvbmx5IG9wdGlvbnNcbiAqXG4gKiBBbGwgc3BlYyBhbGdvcml0aG0gc3RlcCBudW1iZXJzIGFyZSBiYXNlZCBvbiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy9jb21taXQtc25hcHNob3RzL2FlNzE2ODIyY2IzYTYxODQzMjI2Y2QwOTBlZWZjNjU4OTQ0NmMxZDIvLlxuICovXG5cbmNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbCgnUmVxdWVzdCBpbnRlcm5hbHMnKTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBpbnN0YW5jZSBvZiBSZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSAgeyp9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNSZXF1ZXN0ID0gb2JqZWN0ID0+IHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiBvYmplY3RbSU5URVJOQUxTXSA9PT0gJ29iamVjdCdcblx0KTtcbn07XG5cbmNvbnN0IGRvQmFkRGF0YVdhcm4gPSBub2RlX3V0aWwuZGVwcmVjYXRlKCgpID0+IHt9LFxuXHQnLmRhdGEgaXMgbm90IGEgdmFsaWQgUmVxdWVzdEluaXQgcHJvcGVydHksIHVzZSAuYm9keSBpbnN0ZWFkJyxcblx0J2h0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzEwMDAgKHJlcXVlc3QpJyk7XG5cbi8qKlxuICogUmVxdWVzdCBjbGFzc1xuICpcbiAqIFJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3QtY2xhc3NcbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgIGlucHV0ICBVcmwgb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAgT2JqZWN0ICBpbml0ICAgQ3VzdG9tIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuY2xhc3MgUmVxdWVzdCBleHRlbmRzIEJvZHkge1xuXHRjb25zdHJ1Y3RvcihpbnB1dCwgaW5pdCA9IHt9KSB7XG5cdFx0bGV0IHBhcnNlZFVSTDtcblxuXHRcdC8vIE5vcm1hbGl6ZSBpbnB1dCBhbmQgZm9yY2UgVVJMIHRvIGJlIGVuY29kZWQgYXMgVVRGLTggKGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzI0NSlcblx0XHRpZiAoaXNSZXF1ZXN0KGlucHV0KSkge1xuXHRcdFx0cGFyc2VkVVJMID0gbmV3IFVSTChpbnB1dC51cmwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXJzZWRVUkwgPSBuZXcgVVJMKGlucHV0KTtcblx0XHRcdGlucHV0ID0ge307XG5cdFx0fVxuXG5cdFx0aWYgKHBhcnNlZFVSTC51c2VybmFtZSAhPT0gJycgfHwgcGFyc2VkVVJMLnBhc3N3b3JkICE9PSAnJykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgJHtwYXJzZWRVUkx9IGlzIGFuIHVybCB3aXRoIGVtYmVkZGVkIGNyZWRlbnRpYWxzLmApO1xuXHRcdH1cblxuXHRcdGxldCBtZXRob2QgPSBpbml0Lm1ldGhvZCB8fCBpbnB1dC5tZXRob2QgfHwgJ0dFVCc7XG5cdFx0aWYgKC9eKGRlbGV0ZXxnZXR8aGVhZHxvcHRpb25zfHBvc3R8cHV0KSQvaS50ZXN0KG1ldGhvZCkpIHtcblx0XHRcdG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuXHRcdH1cblxuXHRcdGlmICghaXNSZXF1ZXN0KGluaXQpICYmICdkYXRhJyBpbiBpbml0KSB7XG5cdFx0XHRkb0JhZERhdGFXYXJuKCk7XG5cdFx0fVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdGlmICgoaW5pdC5ib2R5ICE9IG51bGwgfHwgKGlzUmVxdWVzdChpbnB1dCkgJiYgaW5wdXQuYm9keSAhPT0gbnVsbCkpICYmXG5cdFx0XHQobWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdIRUFEJykpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVlc3Qgd2l0aCBHRVQvSEVBRCBtZXRob2QgY2Fubm90IGhhdmUgYm9keScpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlucHV0Qm9keSA9IGluaXQuYm9keSA/XG5cdFx0XHRpbml0LmJvZHkgOlxuXHRcdFx0KGlzUmVxdWVzdChpbnB1dCkgJiYgaW5wdXQuYm9keSAhPT0gbnVsbCA/XG5cdFx0XHRcdGNsb25lKGlucHV0KSA6XG5cdFx0XHRcdG51bGwpO1xuXG5cdFx0c3VwZXIoaW5wdXRCb2R5LCB7XG5cdFx0XHRzaXplOiBpbml0LnNpemUgfHwgaW5wdXQuc2l6ZSB8fCAwXG5cdFx0fSk7XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzIHx8IGlucHV0LmhlYWRlcnMgfHwge30pO1xuXG5cdFx0aWYgKGlucHV0Qm9keSAhPT0gbnVsbCAmJiAhaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpKSB7XG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IGV4dHJhY3RDb250ZW50VHlwZShpbnB1dEJvZHksIHRoaXMpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHNpZ25hbCA9IGlzUmVxdWVzdChpbnB1dCkgP1xuXHRcdFx0aW5wdXQuc2lnbmFsIDpcblx0XHRcdG51bGw7XG5cdFx0aWYgKCdzaWduYWwnIGluIGluaXQpIHtcblx0XHRcdHNpZ25hbCA9IGluaXQuc2lnbmFsO1xuXHRcdH1cblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRpZiAoc2lnbmFsICE9IG51bGwgJiYgIWlzQWJvcnRTaWduYWwoc2lnbmFsKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgc2lnbmFsIHRvIGJlIGFuIGluc3RhbmNlb2YgQWJvcnRTaWduYWwgb3IgRXZlbnRUYXJnZXQnKTtcblx0XHR9XG5cblx0XHQvLyDCpzUuNCwgUmVxdWVzdCBjb25zdHJ1Y3RvciBzdGVwcywgc3RlcCAxNS4xXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdGxldCByZWZlcnJlciA9IGluaXQucmVmZXJyZXIgPT0gbnVsbCA/IGlucHV0LnJlZmVycmVyIDogaW5pdC5yZWZlcnJlcjtcblx0XHRpZiAocmVmZXJyZXIgPT09ICcnKSB7XG5cdFx0XHQvLyDCpzUuNCwgUmVxdWVzdCBjb25zdHJ1Y3RvciBzdGVwcywgc3RlcCAxNS4yXG5cdFx0XHRyZWZlcnJlciA9ICduby1yZWZlcnJlcic7XG5cdFx0fSBlbHNlIGlmIChyZWZlcnJlcikge1xuXHRcdFx0Ly8gwqc1LjQsIFJlcXVlc3QgY29uc3RydWN0b3Igc3RlcHMsIHN0ZXAgMTUuMy4xLCAxNS4zLjJcblx0XHRcdGNvbnN0IHBhcnNlZFJlZmVycmVyID0gbmV3IFVSTChyZWZlcnJlcik7XG5cdFx0XHQvLyDCpzUuNCwgUmVxdWVzdCBjb25zdHJ1Y3RvciBzdGVwcywgc3RlcCAxNS4zLjMsIDE1LjMuNFxuXHRcdFx0cmVmZXJyZXIgPSAvXmFib3V0OihcXC9cXC8pP2NsaWVudCQvLnRlc3QocGFyc2VkUmVmZXJyZXIpID8gJ2NsaWVudCcgOiBwYXJzZWRSZWZlcnJlcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVmZXJyZXIgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0dGhpc1tJTlRFUk5BTFNdID0ge1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0cmVkaXJlY3Q6IGluaXQucmVkaXJlY3QgfHwgaW5wdXQucmVkaXJlY3QgfHwgJ2ZvbGxvdycsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0cGFyc2VkVVJMLFxuXHRcdFx0c2lnbmFsLFxuXHRcdFx0cmVmZXJyZXJcblx0XHR9O1xuXG5cdFx0Ly8gTm9kZS1mZXRjaC1vbmx5IG9wdGlvbnNcblx0XHR0aGlzLmZvbGxvdyA9IGluaXQuZm9sbG93ID09PSB1bmRlZmluZWQgPyAoaW5wdXQuZm9sbG93ID09PSB1bmRlZmluZWQgPyAyMCA6IGlucHV0LmZvbGxvdykgOiBpbml0LmZvbGxvdztcblx0XHR0aGlzLmNvbXByZXNzID0gaW5pdC5jb21wcmVzcyA9PT0gdW5kZWZpbmVkID8gKGlucHV0LmNvbXByZXNzID09PSB1bmRlZmluZWQgPyB0cnVlIDogaW5wdXQuY29tcHJlc3MpIDogaW5pdC5jb21wcmVzcztcblx0XHR0aGlzLmNvdW50ZXIgPSBpbml0LmNvdW50ZXIgfHwgaW5wdXQuY291bnRlciB8fCAwO1xuXHRcdHRoaXMuYWdlbnQgPSBpbml0LmFnZW50IHx8IGlucHV0LmFnZW50O1xuXHRcdHRoaXMuaGlnaFdhdGVyTWFyayA9IGluaXQuaGlnaFdhdGVyTWFyayB8fCBpbnB1dC5oaWdoV2F0ZXJNYXJrIHx8IDE2Mzg0O1xuXHRcdHRoaXMuaW5zZWN1cmVIVFRQUGFyc2VyID0gaW5pdC5pbnNlY3VyZUhUVFBQYXJzZXIgfHwgaW5wdXQuaW5zZWN1cmVIVFRQUGFyc2VyIHx8IGZhbHNlO1xuXG5cdFx0Ly8gwqc1LjQsIFJlcXVlc3QgY29uc3RydWN0b3Igc3RlcHMsIHN0ZXAgMTYuXG5cdFx0Ly8gRGVmYXVsdCBpcyBlbXB0eSBzdHJpbmcgcGVyIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJlcXVlc3QtcmVmZXJyZXItcG9saWN5XG5cdFx0dGhpcy5yZWZlcnJlclBvbGljeSA9IGluaXQucmVmZXJyZXJQb2xpY3kgfHwgaW5wdXQucmVmZXJyZXJQb2xpY3kgfHwgJyc7XG5cdH1cblxuXHQvKiogQHJldHVybnMge3N0cmluZ30gKi9cblx0Z2V0IG1ldGhvZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLm1ldGhvZDtcblx0fVxuXG5cdC8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuXHRnZXQgdXJsKCkge1xuXHRcdHJldHVybiBub2RlX3VybC5mb3JtYXQodGhpc1tJTlRFUk5BTFNdLnBhcnNlZFVSTCk7XG5cdH1cblxuXHQvKiogQHJldHVybnMge0hlYWRlcnN9ICovXG5cdGdldCBoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uaGVhZGVycztcblx0fVxuXG5cdGdldCByZWRpcmVjdCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnJlZGlyZWN0O1xuXHR9XG5cblx0LyoqIEByZXR1cm5zIHtBYm9ydFNpZ25hbH0gKi9cblx0Z2V0IHNpZ25hbCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnNpZ25hbDtcblx0fVxuXG5cdC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdC1yZWZlcnJlclxuXHRnZXQgcmVmZXJyZXIoKSB7XG5cdFx0aWYgKHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlciA9PT0gJ25vLXJlZmVycmVyJykge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzW0lOVEVSTkFMU10ucmVmZXJyZXIgPT09ICdjbGllbnQnKSB7XG5cdFx0XHRyZXR1cm4gJ2Fib3V0OmNsaWVudCc7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlcikge1xuXHRcdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlci50b1N0cmluZygpO1xuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHRnZXQgcmVmZXJyZXJQb2xpY3koKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlclBvbGljeTtcblx0fVxuXG5cdHNldCByZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSkge1xuXHRcdHRoaXNbSU5URVJOQUxTXS5yZWZlcnJlclBvbGljeSA9IHZhbGlkYXRlUmVmZXJyZXJQb2xpY3kocmVmZXJyZXJQb2xpY3kpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsb25lIHRoaXMgcmVxdWVzdFxuXHQgKlxuXHQgKiBAcmV0dXJuICBSZXF1ZXN0XG5cdCAqL1xuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IFJlcXVlc3QodGhpcyk7XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuICdSZXF1ZXN0Jztcblx0fVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXF1ZXN0LnByb3RvdHlwZSwge1xuXHRtZXRob2Q6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0dXJsOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGhlYWRlcnM6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0cmVkaXJlY3Q6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0Y2xvbmU6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c2lnbmFsOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHJlZmVycmVyOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHJlZmVycmVyUG9saWN5OiB7ZW51bWVyYWJsZTogdHJ1ZX1cbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBSZXF1ZXN0IHRvIE5vZGUuanMgaHR0cCByZXF1ZXN0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0IC0gQSBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcmV0dXJuIFRoZSBvcHRpb25zIG9iamVjdCB0byBiZSBwYXNzZWQgdG8gaHR0cC5yZXF1ZXN0XG4gKi9cbmNvbnN0IGdldE5vZGVSZXF1ZXN0T3B0aW9ucyA9IHJlcXVlc3QgPT4ge1xuXHRjb25zdCB7cGFyc2VkVVJMfSA9IHJlcXVlc3RbSU5URVJOQUxTXTtcblx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlcXVlc3RbSU5URVJOQUxTXS5oZWFkZXJzKTtcblxuXHQvLyBGZXRjaCBzdGVwIDEuM1xuXHRpZiAoIWhlYWRlcnMuaGFzKCdBY2NlcHQnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnKi8qJyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcHMgMi40LTIuN1xuXHRsZXQgY29udGVudExlbmd0aFZhbHVlID0gbnVsbDtcblx0aWYgKHJlcXVlc3QuYm9keSA9PT0gbnVsbCAmJiAvXihwb3N0fHB1dCkkL2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcblx0XHRjb250ZW50TGVuZ3RoVmFsdWUgPSAnMCc7XG5cdH1cblxuXHRpZiAocmVxdWVzdC5ib2R5ICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgdG90YWxCeXRlcyA9IGdldFRvdGFsQnl0ZXMocmVxdWVzdCk7XG5cdFx0Ly8gU2V0IENvbnRlbnQtTGVuZ3RoIGlmIHRvdGFsQnl0ZXMgaXMgYSBudW1iZXIgKHRoYXQgaXMgbm90IE5hTilcblx0XHRpZiAodHlwZW9mIHRvdGFsQnl0ZXMgPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNOYU4odG90YWxCeXRlcykpIHtcblx0XHRcdGNvbnRlbnRMZW5ndGhWYWx1ZSA9IFN0cmluZyh0b3RhbEJ5dGVzKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY29udGVudExlbmd0aFZhbHVlKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0NvbnRlbnQtTGVuZ3RoJywgY29udGVudExlbmd0aFZhbHVlKTtcblx0fVxuXG5cdC8vIDQuMS4gTWFpbiBmZXRjaCwgc3RlcCAyLjZcblx0Ly8gPiBJZiByZXF1ZXN0J3MgcmVmZXJyZXIgcG9saWN5IGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3QncyByZWZlcnJlciBwb2xpY3kgdG8gdGhlXG5cdC8vID4gZGVmYXVsdCByZWZlcnJlciBwb2xpY3kuXG5cdGlmIChyZXF1ZXN0LnJlZmVycmVyUG9saWN5ID09PSAnJykge1xuXHRcdHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSBERUZBVUxUX1JFRkVSUkVSX1BPTElDWTtcblx0fVxuXG5cdC8vIDQuMS4gTWFpbiBmZXRjaCwgc3RlcCAyLjdcblx0Ly8gPiBJZiByZXF1ZXN0J3MgcmVmZXJyZXIgaXMgbm90IFwibm8tcmVmZXJyZXJcIiwgc2V0IHJlcXVlc3QncyByZWZlcnJlciB0byB0aGUgcmVzdWx0IG9mIGludm9raW5nXG5cdC8vID4gZGV0ZXJtaW5lIHJlcXVlc3QncyByZWZlcnJlci5cblx0aWYgKHJlcXVlc3QucmVmZXJyZXIgJiYgcmVxdWVzdC5yZWZlcnJlciAhPT0gJ25vLXJlZmVycmVyJykge1xuXHRcdHJlcXVlc3RbSU5URVJOQUxTXS5yZWZlcnJlciA9IGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIocmVxdWVzdCk7XG5cdH0gZWxzZSB7XG5cdFx0cmVxdWVzdFtJTlRFUk5BTFNdLnJlZmVycmVyID0gJ25vLXJlZmVycmVyJztcblx0fVxuXG5cdC8vIDQuNS4gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoLCBzdGVwIDYuOVxuXHQvLyA+IElmIGh0dHBSZXF1ZXN0J3MgcmVmZXJyZXIgaXMgYSBVUkwsIHRoZW4gYXBwZW5kIGBSZWZlcmVyYC9odHRwUmVxdWVzdCdzIHJlZmVycmVyLCBzZXJpYWxpemVkXG5cdC8vID4gIGFuZCBpc29tb3JwaGljIGVuY29kZWQsIHRvIGh0dHBSZXF1ZXN0J3MgaGVhZGVyIGxpc3QuXG5cdGlmIChyZXF1ZXN0W0lOVEVSTkFMU10ucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcblx0XHRoZWFkZXJzLnNldCgnUmVmZXJlcicsIHJlcXVlc3QucmVmZXJyZXIpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXAgMi4xMVxuXHRpZiAoIWhlYWRlcnMuaGFzKCdVc2VyLUFnZW50JykpIHtcblx0XHRoZWFkZXJzLnNldCgnVXNlci1BZ2VudCcsICdub2RlLWZldGNoJyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcCAyLjE1XG5cdGlmIChyZXF1ZXN0LmNvbXByZXNzICYmICFoZWFkZXJzLmhhcygnQWNjZXB0LUVuY29kaW5nJykpIHtcblx0XHRoZWFkZXJzLnNldCgnQWNjZXB0LUVuY29kaW5nJywgJ2d6aXAsIGRlZmxhdGUsIGJyJyk7XG5cdH1cblxuXHRsZXQge2FnZW50fSA9IHJlcXVlc3Q7XG5cdGlmICh0eXBlb2YgYWdlbnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRhZ2VudCA9IGFnZW50KHBhcnNlZFVSTCk7XG5cdH1cblxuXHRpZiAoIWhlYWRlcnMuaGFzKCdDb25uZWN0aW9uJykgJiYgIWFnZW50KSB7XG5cdFx0aGVhZGVycy5zZXQoJ0Nvbm5lY3Rpb24nLCAnY2xvc2UnKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDQuMlxuXHQvLyBjaHVua2VkIGVuY29kaW5nIGlzIGhhbmRsZWQgYnkgTm9kZS5qc1xuXG5cdGNvbnN0IHNlYXJjaCA9IGdldFNlYXJjaChwYXJzZWRVUkwpO1xuXG5cdC8vIFBhc3MgdGhlIGZ1bGwgVVJMIGRpcmVjdGx5IHRvIHJlcXVlc3QoKSwgYnV0IG92ZXJ3cml0ZSB0aGUgZm9sbG93aW5nXG5cdC8vIG9wdGlvbnM6XG5cdGNvbnN0IG9wdGlvbnMgPSB7XG5cdFx0Ly8gT3ZlcndyaXRlIHNlYXJjaCB0byByZXRhaW4gdHJhaWxpbmcgPyAoaXNzdWUgIzc3Nilcblx0XHRwYXRoOiBwYXJzZWRVUkwucGF0aG5hbWUgKyBzZWFyY2gsXG5cdFx0Ly8gVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBub3QgZXhwcmVzc2VkIGluIHRoZSBVUkxcblx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuXHRcdGhlYWRlcnM6IGhlYWRlcnNbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSxcblx0XHRpbnNlY3VyZUhUVFBQYXJzZXI6IHJlcXVlc3QuaW5zZWN1cmVIVFRQUGFyc2VyLFxuXHRcdGFnZW50XG5cdH07XG5cblx0cmV0dXJuIHtcblx0XHQvKiogQHR5cGUge1VSTH0gKi9cblx0XHRwYXJzZWRVUkwsXG5cdFx0b3B0aW9uc1xuXHR9O1xufTtcblxuLyoqXG4gKiBBYm9ydEVycm9yIGludGVyZmFjZSBmb3IgY2FuY2VsbGVkIHJlcXVlc3RzXG4gKi9cbmNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBGZXRjaEJhc2VFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHR5cGUgPSAnYWJvcnRlZCcpIHtcblx0XHRzdXBlcihtZXNzYWdlLCB0eXBlKTtcblx0fVxufVxuXG4vKiEgbm9kZS1kb21leGNlcHRpb24uIE1JVCBMaWNlbnNlLiBKaW1teSBXw6RydGluZyA8aHR0cHM6Ly9qaW1teS53YXJ0aW5nLnNlL29wZW5zb3VyY2U+ICovXG5cbmlmICghZ2xvYmFsVGhpcy5ET01FeGNlcHRpb24pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IE1lc3NhZ2VDaGFubmVsIH0gPSByZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpLFxuICAgIHBvcnQgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MSxcbiAgICBhYiA9IG5ldyBBcnJheUJ1ZmZlcigpO1xuICAgIHBvcnQucG9zdE1lc3NhZ2UoYWIsIFthYiwgYWJdKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdET01FeGNlcHRpb24nICYmIChcbiAgICAgIGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uID0gZXJyLmNvbnN0cnVjdG9yXG4gICAgKTtcbiAgfVxufVxuXG52YXIgbm9kZURvbWV4Y2VwdGlvbiA9IGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uO1xuXG4vKipcbiAqIEluZGV4LmpzXG4gKlxuICogYSByZXF1ZXN0IEFQSSBjb21wYXRpYmxlIHdpdGggd2luZG93LmZldGNoXG4gKlxuICogQWxsIHNwZWMgYWxnb3JpdGhtIHN0ZXAgbnVtYmVycyBhcmUgYmFzZWQgb24gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvY29tbWl0LXNuYXBzaG90cy9hZTcxNjgyMmNiM2E2MTg0MzIyNmNkMDkwZWVmYzY1ODk0NDZjMWQyLy5cbiAqL1xuXG5jb25zdCBzdXBwb3J0ZWRTY2hlbWFzID0gbmV3IFNldChbJ2RhdGE6JywgJ2h0dHA6JywgJ2h0dHBzOiddKTtcblxuLyoqXG4gKiBGZXRjaCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmcgfCBVUkwgfCBpbXBvcnQoJy4vcmVxdWVzdCcpLmRlZmF1bHR9IHVybCAtIEFic29sdXRlIHVybCBvciBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcGFyYW0gICB7Kn0gW29wdGlvbnNfXSAtIEZldGNoIG9wdGlvbnNcbiAqIEByZXR1cm4gIHtQcm9taXNlPGltcG9ydCgnLi9yZXNwb25zZScpLmRlZmF1bHQ+fVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaCh1cmwsIG9wdGlvbnNfKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0Ly8gQnVpbGQgcmVxdWVzdCBvYmplY3Rcblx0XHRjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCBvcHRpb25zXyk7XG5cdFx0Y29uc3Qge3BhcnNlZFVSTCwgb3B0aW9uc30gPSBnZXROb2RlUmVxdWVzdE9wdGlvbnMocmVxdWVzdCk7XG5cdFx0aWYgKCFzdXBwb3J0ZWRTY2hlbWFzLmhhcyhwYXJzZWRVUkwucHJvdG9jb2wpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBub2RlLWZldGNoIGNhbm5vdCBsb2FkICR7dXJsfS4gVVJMIHNjaGVtZSBcIiR7cGFyc2VkVVJMLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpfVwiIGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG5cdFx0fVxuXG5cdFx0aWYgKHBhcnNlZFVSTC5wcm90b2NvbCA9PT0gJ2RhdGE6Jykge1xuXHRcdFx0Y29uc3QgZGF0YSA9IGRhdGFVcmlUb0J1ZmZlcihyZXF1ZXN0LnVybCk7XG5cdFx0XHRjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShkYXRhLCB7aGVhZGVyczogeydDb250ZW50LVR5cGUnOiBkYXRhLnR5cGVGdWxsfX0pO1xuXHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gV3JhcCBodHRwLnJlcXVlc3QgaW50byBmZXRjaFxuXHRcdGNvbnN0IHNlbmQgPSAocGFyc2VkVVJMLnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzIDogaHR0cCkucmVxdWVzdDtcblx0XHRjb25zdCB7c2lnbmFsfSA9IHJlcXVlc3Q7XG5cdFx0bGV0IHJlc3BvbnNlID0gbnVsbDtcblxuXHRcdGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgQWJvcnRFcnJvcignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nKTtcblx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRpZiAocmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIFN0cmVhbS5SZWFkYWJsZSkge1xuXHRcdFx0XHRyZXF1ZXN0LmJvZHkuZGVzdHJveShlcnJvcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghcmVzcG9uc2UgfHwgIXJlc3BvbnNlLmJvZHkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZS5ib2R5LmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXHRcdH07XG5cblx0XHRpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0XHRhYm9ydCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGFib3J0QW5kRmluYWxpemUgPSAoKSA9PiB7XG5cdFx0XHRhYm9ydCgpO1xuXHRcdFx0ZmluYWxpemUoKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2VuZCByZXF1ZXN0XG5cdFx0Y29uc3QgcmVxdWVzdF8gPSBzZW5kKHBhcnNlZFVSTC50b1N0cmluZygpLCBvcHRpb25zKTtcblxuXHRcdGlmIChzaWduYWwpIHtcblx0XHRcdHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZpbmFsaXplID0gKCkgPT4ge1xuXHRcdFx0cmVxdWVzdF8uYWJvcnQoKTtcblx0XHRcdGlmIChzaWduYWwpIHtcblx0XHRcdFx0c2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJlcXVlc3RfLm9uKCdlcnJvcicsIGVycm9yID0+IHtcblx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgcmVxdWVzdCB0byAke3JlcXVlc3QudXJsfSBmYWlsZWQsIHJlYXNvbjogJHtlcnJvci5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlcnJvcikpO1xuXHRcdFx0ZmluYWxpemUoKTtcblx0XHR9KTtcblxuXHRcdGZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nKHJlcXVlc3RfLCBlcnJvciA9PiB7XG5cdFx0XHRpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYm9keSkge1xuXHRcdFx0XHRyZXNwb25zZS5ib2R5LmRlc3Ryb3koZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0LyogYzggaWdub3JlIG5leHQgMTggKi9cblx0XHRpZiAocHJvY2Vzcy52ZXJzaW9uIDwgJ3YxNCcpIHtcblx0XHRcdC8vIEJlZm9yZSBOb2RlLmpzIDE0LCBwaXBlbGluZSgpIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgYXN5bmMgaXRlcmF0b3JzIGFuZCBkb2VzIG5vdCBhbHdheXNcblx0XHRcdC8vIHByb3Blcmx5IGhhbmRsZSB3aGVuIHRoZSBzb2NrZXQgY2xvc2UvZW5kIGV2ZW50cyBhcmUgb3V0IG9mIG9yZGVyLlxuXHRcdFx0cmVxdWVzdF8ub24oJ3NvY2tldCcsIHMgPT4ge1xuXHRcdFx0XHRsZXQgZW5kZWRXaXRoRXZlbnRzQ291bnQ7XG5cdFx0XHRcdHMucHJlcGVuZExpc3RlbmVyKCdlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdFx0ZW5kZWRXaXRoRXZlbnRzQ291bnQgPSBzLl9ldmVudHNDb3VudDtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHMucHJlcGVuZExpc3RlbmVyKCdjbG9zZScsIGhhZEVycm9yID0+IHtcblx0XHRcdFx0XHQvLyBpZiBlbmQgaGFwcGVuZWQgYmVmb3JlIGNsb3NlIGJ1dCB0aGUgc29ja2V0IGRpZG4ndCBlbWl0IGFuIGVycm9yLCBkbyBpdCBub3dcblx0XHRcdFx0XHRpZiAocmVzcG9uc2UgJiYgZW5kZWRXaXRoRXZlbnRzQ291bnQgPCBzLl9ldmVudHNDb3VudCAmJiAhaGFkRXJyb3IpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdQcmVtYXR1cmUgY2xvc2UnKTtcblx0XHRcdFx0XHRcdGVycm9yLmNvZGUgPSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnO1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UuYm9keS5lbWl0KCdlcnJvcicsIGVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmVxdWVzdF8ub24oJ3Jlc3BvbnNlJywgcmVzcG9uc2VfID0+IHtcblx0XHRcdHJlcXVlc3RfLnNldFRpbWVvdXQoMCk7XG5cdFx0XHRjb25zdCBoZWFkZXJzID0gZnJvbVJhd0hlYWRlcnMocmVzcG9uc2VfLnJhd0hlYWRlcnMpO1xuXG5cdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNVxuXHRcdFx0aWYgKGlzUmVkaXJlY3QocmVzcG9uc2VfLnN0YXR1c0NvZGUpKSB7XG5cdFx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1LjJcblx0XHRcdFx0Y29uc3QgbG9jYXRpb24gPSBoZWFkZXJzLmdldCgnTG9jYXRpb24nKTtcblxuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS4zXG5cdFx0XHRcdGxldCBsb2NhdGlvblVSTCA9IG51bGw7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0bG9jYXRpb25VUkwgPSBsb2NhdGlvbiA9PT0gbnVsbCA/IG51bGwgOiBuZXcgVVJMKGxvY2F0aW9uLCByZXF1ZXN0LnVybCk7XG5cdFx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRcdC8vIGVycm9yIGhlcmUgY2FuIG9ubHkgYmUgaW52YWxpZCBVUkwgaW4gTG9jYXRpb246IGhlYWRlclxuXHRcdFx0XHRcdC8vIGRvIG5vdCB0aHJvdyB3aGVuIG9wdGlvbnMucmVkaXJlY3QgPT0gbWFudWFsXG5cdFx0XHRcdFx0Ly8gbGV0IHRoZSB1c2VyIGV4dHJhY3QgdGhlIGVycm9ybmVvdXMgcmVkaXJlY3QgVVJMXG5cdFx0XHRcdFx0aWYgKHJlcXVlc3QucmVkaXJlY3QgIT09ICdtYW51YWwnKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYHVyaSByZXF1ZXN0ZWQgcmVzcG9uZHMgd2l0aCBhbiBpbnZhbGlkIHJlZGlyZWN0IFVSTDogJHtsb2NhdGlvbn1gLCAnaW52YWxpZC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuNVxuXHRcdFx0XHRzd2l0Y2ggKHJlcXVlc3QucmVkaXJlY3QpIHtcblx0XHRcdFx0XHRjYXNlICdlcnJvcic6XG5cdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYHVyaSByZXF1ZXN0ZWQgcmVzcG9uZHMgd2l0aCBhIHJlZGlyZWN0LCByZWRpcmVjdCBtb2RlIGlzIHNldCB0byBlcnJvcjogJHtyZXF1ZXN0LnVybH1gLCAnbm8tcmVkaXJlY3QnKSk7XG5cdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdGNhc2UgJ21hbnVhbCc6XG5cdFx0XHRcdFx0XHQvLyBOb3RoaW5nIHRvIGRvXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdmb2xsb3cnOiB7XG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMlxuXHRcdFx0XHRcdFx0aWYgKGxvY2F0aW9uVVJMID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgNVxuXHRcdFx0XHRcdFx0aWYgKHJlcXVlc3QuY291bnRlciA+PSByZXF1ZXN0LmZvbGxvdykge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYG1heGltdW0gcmVkaXJlY3QgcmVhY2hlZCBhdDogJHtyZXF1ZXN0LnVybH1gLCAnbWF4LXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCA2IChjb3VudGVyIGluY3JlbWVudClcblx0XHRcdFx0XHRcdC8vIENyZWF0ZSBhIG5ldyBSZXF1ZXN0IG9iamVjdC5cblx0XHRcdFx0XHRcdGNvbnN0IHJlcXVlc3RPcHRpb25zID0ge1xuXHRcdFx0XHRcdFx0XHRoZWFkZXJzOiBuZXcgSGVhZGVycyhyZXF1ZXN0LmhlYWRlcnMpLFxuXHRcdFx0XHRcdFx0XHRmb2xsb3c6IHJlcXVlc3QuZm9sbG93LFxuXHRcdFx0XHRcdFx0XHRjb3VudGVyOiByZXF1ZXN0LmNvdW50ZXIgKyAxLFxuXHRcdFx0XHRcdFx0XHRhZ2VudDogcmVxdWVzdC5hZ2VudCxcblx0XHRcdFx0XHRcdFx0Y29tcHJlc3M6IHJlcXVlc3QuY29tcHJlc3MsXG5cdFx0XHRcdFx0XHRcdG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG5cdFx0XHRcdFx0XHRcdGJvZHk6IGNsb25lKHJlcXVlc3QpLFxuXHRcdFx0XHRcdFx0XHRzaWduYWw6IHJlcXVlc3Quc2lnbmFsLFxuXHRcdFx0XHRcdFx0XHRzaXplOiByZXF1ZXN0LnNpemUsXG5cdFx0XHRcdFx0XHRcdHJlZmVycmVyOiByZXF1ZXN0LnJlZmVycmVyLFxuXHRcdFx0XHRcdFx0XHRyZWZlcnJlclBvbGljeTogcmVxdWVzdC5yZWZlcnJlclBvbGljeVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0Ly8gd2hlbiBmb3J3YXJkaW5nIHNlbnNpdGl2ZSBoZWFkZXJzIGxpa2UgXCJBdXRob3JpemF0aW9uXCIsXG5cdFx0XHRcdFx0XHQvLyBcIldXVy1BdXRoZW50aWNhdGVcIiwgYW5kIFwiQ29va2llXCIgdG8gdW50cnVzdGVkIHRhcmdldHMsXG5cdFx0XHRcdFx0XHQvLyBoZWFkZXJzIHdpbGwgYmUgaWdub3JlZCB3aGVuIGZvbGxvd2luZyBhIHJlZGlyZWN0IHRvIGEgZG9tYWluXG5cdFx0XHRcdFx0XHQvLyB0aGF0IGlzIG5vdCBhIHN1YmRvbWFpbiBtYXRjaCBvciBleGFjdCBtYXRjaCBvZiB0aGUgaW5pdGlhbCBkb21haW4uXG5cdFx0XHRcdFx0XHQvLyBGb3IgZXhhbXBsZSwgYSByZWRpcmVjdCBmcm9tIFwiZm9vLmNvbVwiIHRvIGVpdGhlciBcImZvby5jb21cIiBvciBcInN1Yi5mb28uY29tXCJcblx0XHRcdFx0XHRcdC8vIHdpbGwgZm9yd2FyZCB0aGUgc2Vuc2l0aXZlIGhlYWRlcnMsIGJ1dCBhIHJlZGlyZWN0IHRvIFwiYmFyLmNvbVwiIHdpbGwgbm90LlxuXHRcdFx0XHRcdFx0Ly8gaGVhZGVycyB3aWxsIGFsc28gYmUgaWdub3JlZCB3aGVuIGZvbGxvd2luZyBhIHJlZGlyZWN0IHRvIGEgZG9tYWluIHVzaW5nXG5cdFx0XHRcdFx0XHQvLyBhIGRpZmZlcmVudCBwcm90b2NvbC4gRm9yIGV4YW1wbGUsIGEgcmVkaXJlY3QgZnJvbSBcImh0dHBzOi8vZm9vLmNvbVwiIHRvIFwiaHR0cDovL2Zvby5jb21cIlxuXHRcdFx0XHRcdFx0Ly8gd2lsbCBub3QgZm9yd2FyZCB0aGUgc2Vuc2l0aXZlIGhlYWRlcnNcblx0XHRcdFx0XHRcdGlmICghaXNEb21haW5PclN1YmRvbWFpbihyZXF1ZXN0LnVybCwgbG9jYXRpb25VUkwpIHx8ICFpc1NhbWVQcm90b2NvbChyZXF1ZXN0LnVybCwgbG9jYXRpb25VUkwpKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoY29uc3QgbmFtZSBvZiBbJ2F1dGhvcml6YXRpb24nLCAnd3d3LWF1dGhlbnRpY2F0ZScsICdjb29raWUnLCAnY29va2llMiddKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuaGVhZGVycy5kZWxldGUobmFtZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDlcblx0XHRcdFx0XHRcdGlmIChyZXNwb25zZV8uc3RhdHVzQ29kZSAhPT0gMzAzICYmIHJlcXVlc3QuYm9keSAmJiBvcHRpb25zXy5ib2R5IGluc3RhbmNlb2YgU3RyZWFtLlJlYWRhYmxlKSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcignQ2Fubm90IGZvbGxvdyByZWRpcmVjdCB3aXRoIGJvZHkgYmVpbmcgYSByZWFkYWJsZSBzdHJlYW0nLCAndW5zdXBwb3J0ZWQtcmVkaXJlY3QnKSk7XG5cdFx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDExXG5cdFx0XHRcdFx0XHRpZiAocmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDMwMyB8fCAoKHJlc3BvbnNlXy5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDMwMikgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdQT1NUJykpIHtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRpb25zLmJvZHkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRpb25zLmhlYWRlcnMuZGVsZXRlKCdjb250ZW50LWxlbmd0aCcpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMTRcblx0XHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlUmVmZXJyZXJQb2xpY3kgPSBwYXJzZVJlZmVycmVyUG9saWN5RnJvbUhlYWRlcihoZWFkZXJzKTtcblx0XHRcdFx0XHRcdGlmIChyZXNwb25zZVJlZmVycmVyUG9saWN5KSB7XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRpb25zLnJlZmVycmVyUG9saWN5ID0gcmVzcG9uc2VSZWZlcnJlclBvbGljeTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDE1XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGZldGNoKG5ldyBSZXF1ZXN0KGxvY2F0aW9uVVJMLCByZXF1ZXN0T3B0aW9ucykpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcihgUmVkaXJlY3Qgb3B0aW9uICcke3JlcXVlc3QucmVkaXJlY3R9JyBpcyBub3QgYSB2YWxpZCB2YWx1ZSBvZiBSZXF1ZXN0UmVkaXJlY3RgKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUHJlcGFyZSByZXNwb25zZVxuXHRcdFx0aWYgKHNpZ25hbCkge1xuXHRcdFx0XHRyZXNwb25zZV8ub25jZSgnZW5kJywgKCkgPT4ge1xuXHRcdFx0XHRcdHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGJvZHkgPSBTdHJlYW0ucGlwZWxpbmUocmVzcG9uc2VfLCBuZXcgU3RyZWFtLlBhc3NUaHJvdWdoKCksIGVycm9yID0+IHtcblx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMjkzNzZcblx0XHRcdC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cblx0XHRcdGlmIChwcm9jZXNzLnZlcnNpb24gPCAndjEyLjEwJykge1xuXHRcdFx0XHRyZXNwb25zZV8ub24oJ2Fib3J0ZWQnLCBhYm9ydEFuZEZpbmFsaXplKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmVzcG9uc2VPcHRpb25zID0ge1xuXHRcdFx0XHR1cmw6IHJlcXVlc3QudXJsLFxuXHRcdFx0XHRzdGF0dXM6IHJlc3BvbnNlXy5zdGF0dXNDb2RlLFxuXHRcdFx0XHRzdGF0dXNUZXh0OiByZXNwb25zZV8uc3RhdHVzTWVzc2FnZSxcblx0XHRcdFx0aGVhZGVycyxcblx0XHRcdFx0c2l6ZTogcmVxdWVzdC5zaXplLFxuXHRcdFx0XHRjb3VudGVyOiByZXF1ZXN0LmNvdW50ZXIsXG5cdFx0XHRcdGhpZ2hXYXRlck1hcms6IHJlcXVlc3QuaGlnaFdhdGVyTWFya1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgMTIuMS4xLjNcblx0XHRcdGNvbnN0IGNvZGluZ3MgPSBoZWFkZXJzLmdldCgnQ29udGVudC1FbmNvZGluZycpO1xuXG5cdFx0XHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCAxMi4xLjEuNDogaGFuZGxlIGNvbnRlbnQgY29kaW5nc1xuXG5cdFx0XHQvLyBpbiBmb2xsb3dpbmcgc2NlbmFyaW9zIHdlIGlnbm9yZSBjb21wcmVzc2lvbiBzdXBwb3J0XG5cdFx0XHQvLyAxLiBjb21wcmVzc2lvbiBzdXBwb3J0IGlzIGRpc2FibGVkXG5cdFx0XHQvLyAyLiBIRUFEIHJlcXVlc3Rcblx0XHRcdC8vIDMuIG5vIENvbnRlbnQtRW5jb2RpbmcgaGVhZGVyXG5cdFx0XHQvLyA0LiBubyBjb250ZW50IHJlc3BvbnNlICgyMDQpXG5cdFx0XHQvLyA1LiBjb250ZW50IG5vdCBtb2RpZmllZCByZXNwb25zZSAoMzA0KVxuXHRcdFx0aWYgKCFyZXF1ZXN0LmNvbXByZXNzIHx8IHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcgfHwgY29kaW5ncyA9PT0gbnVsbCB8fCByZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMjA0IHx8IHJlc3BvbnNlXy5zdGF0dXNDb2RlID09PSAzMDQpIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIE5vZGUgdjYrXG5cdFx0XHQvLyBCZSBsZXNzIHN0cmljdCB3aGVuIGRlY29kaW5nIGNvbXByZXNzZWQgcmVzcG9uc2VzLCBzaW5jZSBzb21ldGltZXNcblx0XHRcdC8vIHNlcnZlcnMgc2VuZCBzbGlnaHRseSBpbnZhbGlkIHJlc3BvbnNlcyB0aGF0IGFyZSBzdGlsbCBhY2NlcHRlZFxuXHRcdFx0Ly8gYnkgY29tbW9uIGJyb3dzZXJzLlxuXHRcdFx0Ly8gQWx3YXlzIHVzaW5nIFpfU1lOQ19GTFVTSCBpcyB3aGF0IGNVUkwgZG9lcy5cblx0XHRcdGNvbnN0IHpsaWJPcHRpb25zID0ge1xuXHRcdFx0XHRmbHVzaDogemxpYi5aX1NZTkNfRkxVU0gsXG5cdFx0XHRcdGZpbmlzaEZsdXNoOiB6bGliLlpfU1lOQ19GTFVTSFxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gRm9yIGd6aXBcblx0XHRcdGlmIChjb2RpbmdzID09PSAnZ3ppcCcgfHwgY29kaW5ncyA9PT0gJ3gtZ3ppcCcpIHtcblx0XHRcdFx0Ym9keSA9IFN0cmVhbS5waXBlbGluZShib2R5LCB6bGliLmNyZWF0ZUd1bnppcCh6bGliT3B0aW9ucyksIGVycm9yID0+IHtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIGRlZmxhdGVcblx0XHRcdGlmIChjb2RpbmdzID09PSAnZGVmbGF0ZScgfHwgY29kaW5ncyA9PT0gJ3gtZGVmbGF0ZScpIHtcblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBpbmZhbW91cyByYXcgZGVmbGF0ZSByZXNwb25zZSBmcm9tIG9sZCBzZXJ2ZXJzXG5cdFx0XHRcdC8vIGEgaGFjayBmb3Igb2xkIElJUyBhbmQgQXBhY2hlIHNlcnZlcnNcblx0XHRcdFx0Y29uc3QgcmF3ID0gU3RyZWFtLnBpcGVsaW5lKHJlc3BvbnNlXywgbmV3IFN0cmVhbS5QYXNzVGhyb3VnaCgpLCBlcnJvciA9PiB7XG5cdFx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJhdy5vbmNlKCdkYXRhJywgY2h1bmsgPT4ge1xuXHRcdFx0XHRcdC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM3NTE5ODI4XG5cdFx0XHRcdFx0aWYgKChjaHVua1swXSAmIDB4MEYpID09PSAweDA4KSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gU3RyZWFtLnBpcGVsaW5lKGJvZHksIHpsaWIuY3JlYXRlSW5mbGF0ZSgpLCBlcnJvciA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gU3RyZWFtLnBpcGVsaW5lKGJvZHksIHpsaWIuY3JlYXRlSW5mbGF0ZVJhdygpLCBlcnJvciA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyYXcub25jZSgnZW5kJywgKCkgPT4ge1xuXHRcdFx0XHRcdC8vIFNvbWUgb2xkIElJUyBzZXJ2ZXJzIHJldHVybiB6ZXJvLWxlbmd0aCBPSyBkZWZsYXRlIHJlc3BvbnNlcywgc29cblx0XHRcdFx0XHQvLyAnZGF0YScgaXMgbmV2ZXIgZW1pdHRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvcHVsbC85MDNcblx0XHRcdFx0XHRpZiAoIXJlc3BvbnNlKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZU9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgYnJcblx0XHRcdGlmIChjb2RpbmdzID09PSAnYnInKSB7XG5cdFx0XHRcdGJvZHkgPSBTdHJlYW0ucGlwZWxpbmUoYm9keSwgemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKCksIGVycm9yID0+IHtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCB1c2UgcmVzcG9uc2UgYXMtaXNcblx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHR9KTtcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG5cdFx0d3JpdGVUb1N0cmVhbShyZXF1ZXN0XywgcmVxdWVzdCkuY2F0Y2gocmVqZWN0KTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nKHJlcXVlc3QsIGVycm9yQ2FsbGJhY2spIHtcblx0Y29uc3QgTEFTVF9DSFVOSyA9IG5vZGVfYnVmZmVyLkJ1ZmZlci5mcm9tKCcwXFxyXFxuXFxyXFxuJyk7XG5cblx0bGV0IGlzQ2h1bmtlZFRyYW5zZmVyID0gZmFsc2U7XG5cdGxldCBwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCA9IGZhbHNlO1xuXHRsZXQgcHJldmlvdXNDaHVuaztcblxuXHRyZXF1ZXN0Lm9uKCdyZXNwb25zZScsIHJlc3BvbnNlID0+IHtcblx0XHRjb25zdCB7aGVhZGVyc30gPSByZXNwb25zZTtcblx0XHRpc0NodW5rZWRUcmFuc2ZlciA9IGhlYWRlcnNbJ3RyYW5zZmVyLWVuY29kaW5nJ10gPT09ICdjaHVua2VkJyAmJiAhaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcblx0fSk7XG5cblx0cmVxdWVzdC5vbignc29ja2V0Jywgc29ja2V0ID0+IHtcblx0XHRjb25zdCBvblNvY2tldENsb3NlID0gKCkgPT4ge1xuXHRcdFx0aWYgKGlzQ2h1bmtlZFRyYW5zZmVyICYmICFwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCkge1xuXHRcdFx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJyk7XG5cdFx0XHRcdGVycm9yLmNvZGUgPSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrKGVycm9yKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qgb25EYXRhID0gYnVmID0+IHtcblx0XHRcdHByb3Blckxhc3RDaHVua1JlY2VpdmVkID0gbm9kZV9idWZmZXIuQnVmZmVyLmNvbXBhcmUoYnVmLnNsaWNlKC01KSwgTEFTVF9DSFVOSykgPT09IDA7XG5cblx0XHRcdC8vIFNvbWV0aW1lcyBmaW5hbCAwLWxlbmd0aCBjaHVuayBhbmQgZW5kIG9mIG1lc3NhZ2UgY29kZSBhcmUgaW4gc2VwYXJhdGUgcGFja2V0c1xuXHRcdFx0aWYgKCFwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCAmJiBwcmV2aW91c0NodW5rKSB7XG5cdFx0XHRcdHByb3Blckxhc3RDaHVua1JlY2VpdmVkID0gKFxuXHRcdFx0XHRcdG5vZGVfYnVmZmVyLkJ1ZmZlci5jb21wYXJlKHByZXZpb3VzQ2h1bmsuc2xpY2UoLTMpLCBMQVNUX0NIVU5LLnNsaWNlKDAsIDMpKSA9PT0gMCAmJlxuXHRcdFx0XHRcdG5vZGVfYnVmZmVyLkJ1ZmZlci5jb21wYXJlKGJ1Zi5zbGljZSgtMiksIExBU1RfQ0hVTksuc2xpY2UoMykpID09PSAwXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHByZXZpb3VzQ2h1bmsgPSBidWY7XG5cdFx0fTtcblxuXHRcdHNvY2tldC5wcmVwZW5kTGlzdGVuZXIoJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSk7XG5cdFx0c29ja2V0Lm9uKCdkYXRhJywgb25EYXRhKTtcblxuXHRcdHJlcXVlc3Qub24oJ2Nsb3NlJywgKCkgPT4ge1xuXHRcdFx0c29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpO1xuXHRcdFx0c29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKTtcblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQGF1dGhvciBUb3J1IE5hZ2FzaGltYSA8aHR0cHM6Ly9naXRodWIuY29tL215c3RpY2F0ZWE+XG4gKiBAY29weXJpZ2h0IDIwMTUgVG9ydSBOYWdhc2hpbWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTZWUgTElDRU5TRSBmaWxlIGluIHJvb3QgZGlyZWN0b3J5IGZvciBmdWxsIGxpY2Vuc2UuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gUHJpdmF0ZURhdGFcbiAqIEBwcm9wZXJ0eSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQuXG4gKiBAcHJvcGVydHkge3t0eXBlOnN0cmluZ319IGV2ZW50IFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnRQaGFzZSBUaGUgY3VycmVudCBldmVudCBwaGFzZS5cbiAqIEBwcm9wZXJ0eSB7RXZlbnRUYXJnZXR8bnVsbH0gY3VycmVudFRhcmdldCBUaGUgY3VycmVudCBldmVudCB0YXJnZXQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbmNlbGVkIFRoZSBmbGFnIHRvIHByZXZlbnQgZGVmYXVsdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3RvcHBlZCBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBpbW1lZGlhdGVTdG9wcGVkIFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24gaW1tZWRpYXRlbHkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufG51bGx9IHBhc3NpdmVMaXN0ZW5lciBUaGUgbGlzdGVuZXIgaWYgdGhlIGN1cnJlbnQgbGlzdGVuZXIgaXMgcGFzc2l2ZS4gT3RoZXJ3aXNlIHRoaXMgaXMgbnVsbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lU3RhbXAgVGhlIHVuaXggdGltZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBQcml2YXRlIGRhdGEgZm9yIGV2ZW50IHdyYXBwZXJzLlxuICogQHR5cGUge1dlYWtNYXA8RXZlbnQsIFByaXZhdGVEYXRhPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBDYWNoZSBmb3Igd3JhcHBlciBjbGFzc2VzLlxuICogQHR5cGUge1dlYWtNYXA8T2JqZWN0LCBGdW5jdGlvbj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3cmFwcGVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogR2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCBvYmplY3QgdG8gZ2V0IHByaXZhdGUgZGF0YS5cbiAqIEByZXR1cm5zIHtQcml2YXRlRGF0YX0gVGhlIHByaXZhdGUgZGF0YSBvZiB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwZChldmVudCkge1xuICAgIGNvbnN0IHJldHYgPSBwcml2YXRlRGF0YS5nZXQoZXZlbnQpO1xuICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICByZXR2ICE9IG51bGwsXG4gICAgICAgIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50IG9iamVjdCwgYnV0IGdvdFwiLFxuICAgICAgICBldmVudFxuICAgICk7XG4gICAgcmV0dXJuIHJldHZcbn1cblxuLyoqXG4gKiBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI3NldC10aGUtY2FuY2VsZWQtZmxhZ1xuICogQHBhcmFtIGRhdGEge1ByaXZhdGVEYXRhfSBwcml2YXRlIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHNldENhbmNlbEZsYWcoZGF0YSkge1xuICAgIGlmIChkYXRhLnBhc3NpdmVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlVuYWJsZSB0byBwcmV2ZW50RGVmYXVsdCBpbnNpZGUgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBpbnZvY2F0aW9uLlwiLFxuICAgICAgICAgICAgICAgIGRhdGEucGFzc2l2ZUxpc3RlbmVyXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIWRhdGEuZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBkYXRhLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQucHJldmVudERlZmF1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbi8qKlxuICogVGhlIGV2ZW50IHdyYXBwZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2YgdGhpcyBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50IHRvIHdyYXAuXG4gKi9cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIHByaXZhdGVEYXRhLnNldCh0aGlzLCB7XG4gICAgICAgIGV2ZW50VGFyZ2V0LFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnRQaGFzZTogMixcbiAgICAgICAgY3VycmVudFRhcmdldDogZXZlbnRUYXJnZXQsXG4gICAgICAgIGNhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAgc3RvcHBlZDogZmFsc2UsXG4gICAgICAgIGltbWVkaWF0ZVN0b3BwZWQ6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlTGlzdGVuZXI6IG51bGwsXG4gICAgICAgIHRpbWVTdGFtcDogZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCksXG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNVbmZvcmdlYWJsZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzVHJ1c3RlZFwiLCB7IHZhbHVlOiBmYWxzZSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnNcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIShrZXkgaW4gdGhpcykpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gU2hvdWxkIGJlIGVudW1lcmFibGUsIGJ1dCBjbGFzcyBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZS5cbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudC50eXBlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAgZ2V0IHRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jdXJyZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtFdmVudFRhcmdldFtdfSBUaGUgY29tcG9zZWQgcGF0aCBvZiB0aGlzIGV2ZW50LlxuICAgICAqL1xuICAgIGNvbXBvc2VkUGF0aCgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRhcmdldCA9IHBkKHRoaXMpLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3VycmVudFRhcmdldF1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgb2YgTk9ORS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBOT05FKCkge1xuICAgICAgICByZXR1cm4gMFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBDQVBUVVJJTkdfUEhBU0UuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQ0FQVFVSSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBBVF9UQVJHRVQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQVRfVEFSR0VUKCkge1xuICAgICAgICByZXR1cm4gMlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBCVUJCTElOR19QSEFTRS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBCVUJCTElOR19QSEFTRSgpIHtcbiAgICAgICAgcmV0dXJuIDNcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGV2ZW50UGhhc2UoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFBoYXNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcyk7XG5cbiAgICAgICAgZGF0YS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcyk7XG5cbiAgICAgICAgZGF0YS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YS5pbW1lZGlhdGVTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGJ1YmJsaW5nLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBidWJibGVzKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5idWJibGVzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBjYW5jZWxhYmxlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjYW5jZWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5jYW5jZWxhYmxlKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgdGhpcyBldmVudC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgc2V0Q2FuY2VsRmxhZyhwZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGluZGljYXRlIGNhbmNlbGxhdGlvbiBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgZGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmNhbmNlbGVkXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGNvbXBvc2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjb21wb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuY29tcG9zZWQpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB1bml4IHRpbWUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB0aW1lU3RhbXAoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS50aW1lU3RhbXBcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCBzcmNFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gc3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCBjYW5jZWxCdWJibGUoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5zdG9wcGVkXG4gICAgfSxcbiAgICBzZXQgY2FuY2VsQnViYmxlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKTtcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuY2FuY2VsQnViYmxlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgZGF0YS5ldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGluZGljYXRlIGNhbmNlbGxhdGlvbiBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCByZXR1cm5WYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuICFwZCh0aGlzKS5jYW5jZWxlZFxuICAgIH0sXG4gICAgc2V0IHJldHVyblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHNldENhbmNlbEZsYWcocGQodGhpcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhpcyBldmVudCBvYmplY3QuIEJ1dCBkbyBub3RoaW5nIHVuZGVyIGV2ZW50IGRpc3BhdGNoaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIFRoZSBmbGFnIHRvIGJlIHBvc3NpYmxlIHRvIGJ1YmJsZSB1cC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjYW5jZWxhYmxlPWZhbHNlXSBUaGUgZmxhZyB0byBiZSBwb3NzaWJsZSB0byBjYW5jZWwuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBpbml0RXZlbnQoKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfSxcbn07XG5cbi8vIGBjb25zdHJ1Y3RvcmAgaXMgbm90IGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHtcbiAgICB2YWx1ZTogRXZlbnQsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxufSk7XG5cbi8vIEVuc3VyZSBgZXZlbnQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnRgIGlzIGB0cnVlYC5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnQucHJvdG90eXBlLCB3aW5kb3cuRXZlbnQucHJvdG90eXBlKTtcblxuICAgIC8vIE1ha2UgYXNzb2NpYXRpb24gZm9yIHdyYXBwZXJzLlxuICAgIHdyYXBwZXJzLnNldCh3aW5kb3cuRXZlbnQucHJvdG90eXBlLCBFdmVudCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIHJlZGlyZWN0IGEgZ2l2ZW4gcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWUgdG8gZGVmaW5lIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byByZWRpcmVjdCB0aGUgcHJvcGVydHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3Ioa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50W2tleV1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICBwZCh0aGlzKS5ldmVudFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGNhbGwgYSBnaXZlbiBtZXRob2QgcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWUgdG8gZGVmaW5lIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byBjYWxsIHRoZSBtZXRob2QgcHJvcGVydHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVDYWxsRGVzY3JpcHRvcihrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gcGQodGhpcykuZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRba2V5XS5hcHBseShldmVudCwgYXJndW1lbnRzKVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBuZXcgd3JhcHBlciBjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IEJhc2VFdmVudCBUaGUgYmFzZSB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBwcm90b3R5cGUgb2YgdGhlIG9yaWdpbmFsIGV2ZW50LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgZGVmaW5lZCB3cmFwcGVyIGNsYXNzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lV3JhcHBlcihCYXNlRXZlbnQsIHByb3RvKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3RvKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJhc2VFdmVudFxuICAgIH1cblxuICAgIC8qKiBDdXN0b21FdmVudCAqL1xuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgICAgICBCYXNlRXZlbnQuY2FsbCh0aGlzLCBldmVudFRhcmdldCwgZXZlbnQpO1xuICAgIH1cblxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUV2ZW50LnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogQ3VzdG9tRXZlbnQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICB9KTtcblxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghKGtleSBpbiBCYXNlRXZlbnQucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGtleSk7XG4gICAgICAgICAgICBjb25zdCBpc0Z1bmMgPSB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgaXNGdW5jXG4gICAgICAgICAgICAgICAgICAgID8gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50XG59XG5cbi8qKlxuICogR2V0IHRoZSB3cmFwcGVyIGNsYXNzIG9mIGEgZ2l2ZW4gcHJvdG90eXBlLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBwcm90b3R5cGUgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIGdldCBpdHMgd3JhcHBlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIHdyYXBwZXIgY2xhc3MuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRXcmFwcGVyKHByb3RvKSB7XG4gICAgaWYgKHByb3RvID09IG51bGwgfHwgcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50XG4gICAgfVxuXG4gICAgbGV0IHdyYXBwZXIgPSB3cmFwcGVycy5nZXQocHJvdG8pO1xuICAgIGlmICh3cmFwcGVyID09IG51bGwpIHtcbiAgICAgICAgd3JhcHBlciA9IGRlZmluZVdyYXBwZXIoZ2V0V3JhcHBlcihPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pKSwgcHJvdG8pO1xuICAgICAgICB3cmFwcGVycy5zZXQocHJvdG8sIHdyYXBwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlclxufVxuXG4vKipcbiAqIFdyYXAgYSBnaXZlbiBldmVudCB0byBtYW5hZ2VtZW50IGEgZGlzcGF0Y2hpbmcuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoaXMgZGlzcGF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHRvIHdyYXAuXG4gKiBAcmV0dXJucyB7RXZlbnR9IFRoZSB3cmFwcGVyIGluc3RhbmNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIGNvbnN0IFdyYXBwZXIgPSBnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkpO1xuICAgIHJldHVybiBuZXcgV3JhcHBlcihldmVudFRhcmdldCwgZXZlbnQpXG59XG5cbi8qKlxuICogR2V0IHRoZSBpbW1lZGlhdGVTdG9wcGVkIGZsYWcgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGZsYWcgdG8gc3RvcCBwcm9wYWdhdGlvbiBpbW1lZGlhdGVseS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU3RvcHBlZChldmVudCkge1xuICAgIHJldHVybiBwZChldmVudCkuaW1tZWRpYXRlU3RvcHBlZFxufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCBldmVudCBwaGFzZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHNldCBjdXJyZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBldmVudFBoYXNlIE5ldyBldmVudCBwaGFzZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0RXZlbnRQaGFzZShldmVudCwgZXZlbnRQaGFzZSkge1xuICAgIHBkKGV2ZW50KS5ldmVudFBoYXNlID0gZXZlbnRQaGFzZTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgdGFyZ2V0IG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtFdmVudFRhcmdldHxudWxsfSBjdXJyZW50VGFyZ2V0IE5ldyBjdXJyZW50IHRhcmdldC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0Q3VycmVudFRhcmdldChldmVudCwgY3VycmVudFRhcmdldCkge1xuICAgIHBkKGV2ZW50KS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbn1cblxuLyoqXG4gKiBTZXQgYSBwYXNzaXZlIGxpc3RlbmVyIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgTmV3IHBhc3NpdmUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFBhc3NpdmVMaXN0ZW5lcihldmVudCwgcGFzc2l2ZUxpc3RlbmVyKSB7XG4gICAgcGQoZXZlbnQpLnBhc3NpdmVMaXN0ZW5lciA9IHBhc3NpdmVMaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBMaXN0ZW5lck5vZGVcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiBAcHJvcGVydHkgezF8MnwzfSBsaXN0ZW5lclR5cGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGFzc2l2ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBvbmNlXG4gKiBAcHJvcGVydHkge0xpc3RlbmVyTm9kZXxudWxsfSBuZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogQHR5cGUge1dlYWtNYXA8b2JqZWN0LCBNYXA8c3RyaW5nLCBMaXN0ZW5lck5vZGU+Pn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGxpc3RlbmVyc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIExpc3RlbmVyIHR5cGVzXG5jb25zdCBDQVBUVVJFID0gMTtcbmNvbnN0IEJVQkJMRSA9IDI7XG5jb25zdCBBVFRSSUJVVEUgPSAzO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3Qgb3Igbm90LlxuICogQHBhcmFtIHthbnl9IHggVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG59XG5cbi8qKlxuICogR2V0IGxpc3RlbmVycy5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgdG8gZ2V0LlxuICogQHJldHVybnMge01hcDxzdHJpbmcsIExpc3RlbmVyTm9kZT59IFRoZSBsaXN0ZW5lcnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZlbnRUYXJnZXQpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNNYXAuZ2V0KGV2ZW50VGFyZ2V0KTtcbiAgICBpZiAobGlzdGVuZXJzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50VGFyZ2V0IG9iamVjdCwgYnV0IGdvdCBhbm90aGVyIHZhbHVlLlwiXG4gICAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RlbmVyc1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgdGhlIGV2ZW50IGF0dHJpYnV0ZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBnZXQgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyVHlwZSA9PT0gQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmxpc3RlbmVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHNldChsaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiICYmICFpc09iamVjdChsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcblxuICAgICAgICAgICAgLy8gVHJhdmVyc2UgdG8gdGhlIHRhaWwgd2hpbGUgcmVtb3Zpbmcgb2xkIHZhbHVlLlxuICAgICAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXJUeXBlID09PSBBVFRSSUJVVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIG5ldyB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclR5cGU6IEFUVFJJQlVURSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ld05vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBhbiBldmVudCBhdHRyaWJ1dGUgKGUuZy4gYGV2ZW50VGFyZ2V0Lm9uY2xpY2tgKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFRhcmdldFByb3RvdHlwZSBUaGUgZXZlbnQgdGFyZ2V0IHByb3RvdHlwZSB0byBkZWZpbmUgYW4gZXZlbnQgYXR0cmJpdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGRlZmluZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZShldmVudFRhcmdldFByb3RvdHlwZSwgZXZlbnROYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICBldmVudFRhcmdldFByb3RvdHlwZSxcbiAgICAgICAgYG9uJHtldmVudE5hbWV9YCxcbiAgICAgICAgZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSlcbiAgICApO1xufVxuXG4vKipcbiAqIERlZmluZSBhIGN1c3RvbSBFdmVudFRhcmdldCB3aXRoIGV2ZW50IGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBldmVudE5hbWVzIEV2ZW50IG5hbWVzIGZvciBldmVudCBhdHRyaWJ1dGVzLlxuICogQHJldHVybnMge0V2ZW50VGFyZ2V0fSBUaGUgY3VzdG9tIEV2ZW50VGFyZ2V0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoZXZlbnROYW1lcykge1xuICAgIC8qKiBDdXN0b21FdmVudFRhcmdldCAqL1xuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50VGFyZ2V0KCkge1xuICAgICAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogQ3VzdG9tRXZlbnRUYXJnZXQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZShDdXN0b21FdmVudFRhcmdldC5wcm90b3R5cGUsIGV2ZW50TmFtZXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBDdXN0b21FdmVudFRhcmdldFxufVxuXG4vKipcbiAqIEV2ZW50VGFyZ2V0LlxuICpcbiAqIC0gVGhpcyBpcyBjb25zdHJ1Y3RvciBpZiBubyBhcmd1bWVudHMuXG4gKiAtIFRoaXMgaXMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgQ3VzdG9tRXZlbnRUYXJnZXQgY29uc3RydWN0b3IgaWYgdGhlcmUgYXJlIGFyZ3VtZW50cy5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgY2xhc3MgQSBleHRlbmRzIEV2ZW50VGFyZ2V0IHt9XG4gKiAgICAgY2xhc3MgQiBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiKSB7fVxuICogICAgIGNsYXNzIEMgZXh0ZW5kcyBFdmVudFRhcmdldChcIm1lc3NhZ2VcIiwgXCJlcnJvclwiKSB7fVxuICogICAgIGNsYXNzIEQgZXh0ZW5kcyBFdmVudFRhcmdldChbXCJtZXNzYWdlXCIsIFwiZXJyb3JcIl0pIHt9XG4gKi9cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIGxpc3RlbmVyc01hcC5zZXQodGhpcywgbmV3IE1hcCgpKTtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoYXJndW1lbnRzWzBdKVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0eXBlc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQodHlwZXMpXG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIilcbiAgICAvKmVzbGludC1lbmFibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbn1cblxuLy8gU2hvdWxkIGJlIGVudW1lcmFibGUsIGJ1dCBjbGFzcyBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZS5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBBZGQgYSBnaXZlbiBsaXN0ZW5lciB0byB0aGlzIGV2ZW50IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx7Y2FwdHVyZT86Ym9vbGVhbixwYXNzaXZlPzpib29sZWFuLG9uY2U/OmJvb2xlYW59fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoaXMgbGlzdGVuZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIgJiYgIWlzT2JqZWN0KGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidsaXN0ZW5lcicgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0LlwiKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBvcHRpb25zSXNPYmogPSBpc09iamVjdChvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IG9wdGlvbnNJc09ialxuICAgICAgICAgICAgPyBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSlcbiAgICAgICAgICAgIDogQm9vbGVhbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJUeXBlID0gY2FwdHVyZSA/IENBUFRVUkUgOiBCVUJCTEU7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgIGxpc3RlbmVyVHlwZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IG9wdGlvbnNJc09iaiAmJiBCb29sZWFuKG9wdGlvbnMucGFzc2l2ZSksXG4gICAgICAgICAgICBvbmNlOiBvcHRpb25zSXNPYmogJiYgQm9vbGVhbihvcHRpb25zLm9uY2UpLFxuICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTZXQgaXQgYXMgdGhlIGZpcnN0IG5vZGUgaWYgdGhlIGZpcnN0IG5vZGUgaXMgbnVsbC5cbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhdmVyc2UgdG8gdGhlIHRhaWwgd2hpbGUgY2hlY2tpbmcgZHVwbGljYXRpb24uLlxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJlxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXJUeXBlID09PSBsaXN0ZW5lclR5cGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBpZ25vcmUgZHVwbGljYXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgaXQuXG4gICAgICAgIHByZXYubmV4dCA9IG5ld05vZGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGdpdmVuIGxpc3RlbmVyIGZyb20gdGhpcyBldmVudCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58e2NhcHR1cmU/OmJvb2xlYW4scGFzc2l2ZT86Ym9vbGVhbixvbmNlPzpib29sZWFufX0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGlzIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBpc09iamVjdChvcHRpb25zKVxuICAgICAgICAgICAgPyBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSlcbiAgICAgICAgICAgIDogQm9vbGVhbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJUeXBlID0gY2FwdHVyZSA/IENBUFRVUkUgOiBCVUJCTEU7XG5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lclR5cGUgPT09IGxpc3RlbmVyVHlwZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhIGdpdmVuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIGV2ZW50IHRvIGRpc3BhdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgZmFsc2VgIGlmIGNhbmNlbGVkLlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50ID09IG51bGwgfHwgdHlwZW9mIGV2ZW50LnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXZlbnQudHlwZVwiIHNob3VsZCBiZSBhIHN0cmluZy4nKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbGlzdGVuZXJzIGFyZW4ndCByZWdpc3RlcmVkLCB0ZXJtaW5hdGUuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gZXZlbnQudHlwZTtcbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5jZSB3ZSBjYW5ub3QgcmV3cml0ZSBzZXZlcmFsIHByb3BlcnRpZXMsIHNvIHdyYXAgb2JqZWN0LlxuICAgICAgICBjb25zdCB3cmFwcGVkRXZlbnQgPSB3cmFwRXZlbnQodGhpcywgZXZlbnQpO1xuXG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBwcm9jZXNzIGNhcHR1cmluZyBwaGFzZSBhbmQgYnViYmxpbmcgcGhhc2UuXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgcGFydGljaXBhdGluZyBpbiBhIHRyZWUuXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgbGlzdGVuZXIgaWYgaXQncyBvbmNlXG4gICAgICAgICAgICBpZiAobm9kZS5vbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxsIHRoaXMgbGlzdGVuZXJcbiAgICAgICAgICAgIHNldFBhc3NpdmVMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICB3cmFwcGVkRXZlbnQsXG4gICAgICAgICAgICAgICAgbm9kZS5wYXNzaXZlID8gbm9kZS5saXN0ZW5lciA6IG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUubGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIuY2FsbCh0aGlzLCB3cmFwcGVkRXZlbnQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lclR5cGUgIT09IEFUVFJJQlVURSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlLmxpc3RlbmVyLmhhbmRsZUV2ZW50ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIuaGFuZGxlRXZlbnQod3JhcHBlZEV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQnJlYWsgaWYgYGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbmAgd2FzIGNhbGxlZC5cbiAgICAgICAgICAgIGlmIChpc1N0b3BwZWQod3JhcHBlZEV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UGFzc2l2ZUxpc3RlbmVyKHdyYXBwZWRFdmVudCwgbnVsbCk7XG4gICAgICAgIHNldEV2ZW50UGhhc2Uod3JhcHBlZEV2ZW50LCAwKTtcbiAgICAgICAgc2V0Q3VycmVudFRhcmdldCh3cmFwcGVkRXZlbnQsIG51bGwpO1xuXG4gICAgICAgIHJldHVybiAhd3JhcHBlZEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcbiAgICB9LFxufTtcblxuLy8gYGNvbnN0cnVjdG9yYCBpcyBub3QgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFRhcmdldC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwge1xuICAgIHZhbHVlOiBFdmVudFRhcmdldCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG59KTtcblxuLy8gRW5zdXJlIGBldmVudFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudFRhcmdldGAgaXMgYHRydWVgLlxuaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2Ygd2luZG93LkV2ZW50VGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiXG4pIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlKTtcbn1cblxuLyoqXG4gKiBAYXV0aG9yIFRvcnUgTmFnYXNoaW1hIDxodHRwczovL2dpdGh1Yi5jb20vbXlzdGljYXRlYT5cbiAqIFNlZSBMSUNFTlNFIGZpbGUgaW4gcm9vdCBkaXJlY3RvcnkgZm9yIGZ1bGwgbGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFRoZSBzaWduYWwgY2xhc3MuXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jYWJvcnRzaWduYWxcbiAqL1xuY2xhc3MgQWJvcnRTaWduYWwgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgLyoqXG4gICAgICogQWJvcnRTaWduYWwgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWJvcnRTaWduYWwgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGBBYm9ydFNpZ25hbGAncyBgQWJvcnRDb250cm9sbGVyYCBoYXMgc2lnbmFsZWQgdG8gYWJvcnQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgYWJvcnRlZCgpIHtcbiAgICAgICAgY29uc3QgYWJvcnRlZCA9IGFib3J0ZWRGbGFncy5nZXQodGhpcyk7XG4gICAgICAgIGlmICh0eXBlb2YgYWJvcnRlZCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkICd0aGlzJyB0byBiZSBhbiAnQWJvcnRTaWduYWwnIG9iamVjdCwgYnV0IGdvdCAke3RoaXMgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiB0aGlzfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYm9ydGVkO1xuICAgIH1cbn1cbmRlZmluZUV2ZW50QXR0cmlidXRlKEFib3J0U2lnbmFsLnByb3RvdHlwZSwgXCJhYm9ydFwiKTtcbi8qKlxuICogQ3JlYXRlIGFuIEFib3J0U2lnbmFsIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWJvcnRTaWduYWwoKSB7XG4gICAgY29uc3Qgc2lnbmFsID0gT2JqZWN0LmNyZWF0ZShBYm9ydFNpZ25hbC5wcm90b3R5cGUpO1xuICAgIEV2ZW50VGFyZ2V0LmNhbGwoc2lnbmFsKTtcbiAgICBhYm9ydGVkRmxhZ3Muc2V0KHNpZ25hbCwgZmFsc2UpO1xuICAgIHJldHVybiBzaWduYWw7XG59XG4vKipcbiAqIEFib3J0IGEgZ2l2ZW4gc2lnbmFsLlxuICovXG5mdW5jdGlvbiBhYm9ydFNpZ25hbChzaWduYWwpIHtcbiAgICBpZiAoYWJvcnRlZEZsYWdzLmdldChzaWduYWwpICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFib3J0ZWRGbGFncy5zZXQoc2lnbmFsLCB0cnVlKTtcbiAgICBzaWduYWwuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwiYWJvcnRcIiB9KTtcbn1cbi8qKlxuICogQWJvcnRlZCBmbGFnIGZvciBlYWNoIGluc3RhbmNlcy5cbiAqL1xuY29uc3QgYWJvcnRlZEZsYWdzID0gbmV3IFdlYWtNYXAoKTtcbi8vIFByb3BlcnRpZXMgc2hvdWxkIGJlIGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBYm9ydFNpZ25hbC5wcm90b3R5cGUsIHtcbiAgICBhYm9ydGVkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbn0pO1xuLy8gYHRvU3RyaW5nKClgIHNob3VsZCByZXR1cm4gYFwiW29iamVjdCBBYm9ydFNpZ25hbF1cImBcbmlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gXCJzeW1ib2xcIikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYm9ydFNpZ25hbC5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBcIkFib3J0U2lnbmFsXCIsXG4gICAgfSk7XG59XG5cbi8qKlxuICogVGhlIEFib3J0Q29udHJvbGxlci5cbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNhYm9ydGNvbnRyb2xsZXJcbiAqL1xuY2xhc3MgQWJvcnRDb250cm9sbGVyJDEge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzaWduYWxzLnNldCh0aGlzLCBjcmVhdGVBYm9ydFNpZ25hbCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYEFib3J0U2lnbmFsYCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgIHJldHVybiBnZXRTaWduYWwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0IGFuZCBzaWduYWwgdG8gYW55IG9ic2VydmVycyB0aGF0IHRoZSBhc3NvY2lhdGVkIGFjdGl2aXR5IGlzIHRvIGJlIGFib3J0ZWQuXG4gICAgICovXG4gICAgYWJvcnQoKSB7XG4gICAgICAgIGFib3J0U2lnbmFsKGdldFNpZ25hbCh0aGlzKSk7XG4gICAgfVxufVxuLyoqXG4gKiBBc3NvY2lhdGVkIHNpZ25hbHMuXG4gKi9cbmNvbnN0IHNpZ25hbHMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBHZXQgdGhlIGFzc29jaWF0ZWQgc2lnbmFsIG9mIGEgZ2l2ZW4gY29udHJvbGxlci5cbiAqL1xuZnVuY3Rpb24gZ2V0U2lnbmFsKGNvbnRyb2xsZXIpIHtcbiAgICBjb25zdCBzaWduYWwgPSBzaWduYWxzLmdldChjb250cm9sbGVyKTtcbiAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgJ3RoaXMnIHRvIGJlIGFuICdBYm9ydENvbnRyb2xsZXInIG9iamVjdCwgYnV0IGdvdCAke2NvbnRyb2xsZXIgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBjb250cm9sbGVyfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmFsO1xufVxuLy8gUHJvcGVydGllcyBzaG91bGQgYmUgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFib3J0Q29udHJvbGxlciQxLnByb3RvdHlwZSwge1xuICAgIHNpZ25hbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxufSk7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09IFwic3ltYm9sXCIpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJvcnRDb250cm9sbGVyJDEucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogXCJBYm9ydENvbnRyb2xsZXJcIixcbiAgICB9KTtcbn1cblxuZXhwb3J0cy5BYm9ydENvbnRyb2xsZXIgPSBBYm9ydENvbnRyb2xsZXIkMTtcbmV4cG9ydHMuQWJvcnRFcnJvciA9IEFib3J0RXJyb3I7XG5leHBvcnRzLkZldGNoRXJyb3IgPSBGZXRjaEVycm9yO1xuZXhwb3J0cy5GaWxlID0gRmlsZSQxO1xuZXhwb3J0cy5Gb3JtRGF0YSA9IEZvcm1EYXRhO1xuZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gUmVzcG9uc2U7XG5leHBvcnRzLl9CbG9iID0gX0Jsb2IkMTtcbmV4cG9ydHMuZmV0Y2ggPSBmZXRjaDtcbmV4cG9ydHMuaXNSZWRpcmVjdCA9IGlzUmVkaXJlY3Q7XG5leHBvcnRzLm5vZGVEb21leGNlcHRpb24gPSBub2RlRG9tZXhjZXB0aW9uO1xuIl0sIm5hbWVzIjpbImh0dHAiLCJyZXF1aXJlIiwiaHR0cHMiLCJ6bGliIiwiU3RyZWFtIiwibm9kZV9idWZmZXIiLCJub2RlX3V0aWwiLCJub2RlX3VybCIsIm5vZGVfbmV0IiwiZGF0YVVyaVRvQnVmZmVyIiwidXJpIiwidGVzdCIsIlR5cGVFcnJvciIsInJlcGxhY2UiLCJmaXJzdENvbW1hIiwiaW5kZXhPZiIsIm1ldGEiLCJzdWJzdHJpbmciLCJzcGxpdCIsImNoYXJzZXQiLCJiYXNlNjQiLCJ0eXBlIiwidHlwZUZ1bGwiLCJpIiwibGVuZ3RoIiwiZW5jb2RpbmciLCJkYXRhIiwidW5lc2NhcGUiLCJidWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsInBvbnlmaWxsX2VzMjAxOCIsImV4cG9ydHMiLCJoYXNSZXF1aXJlZFBvbnlmaWxsX2VzMjAxOCIsInJlcXVpcmVQb255ZmlsbF9lczIwMTgiLCJtb2R1bGUiLCJmYWN0b3J5IiwiU3ltYm9sUG9seWZpbGwiLCJTeW1ib2wiLCJpdGVyYXRvciIsImRlc2NyaXB0aW9uIiwibm9vcCIsInVuZGVmaW5lZCIsImdldEdsb2JhbHMiLCJnbG9iYWxzIiwidHlwZUlzT2JqZWN0IiwieCIsInJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbiIsIm9yaWdpbmFsUHJvbWlzZSIsIlByb21pc2UiLCJvcmlnaW5hbFByb21pc2VUaGVuIiwicHJvdG90eXBlIiwidGhlbiIsIm9yaWdpbmFsUHJvbWlzZVJlc29sdmUiLCJyZXNvbHZlIiwiYmluZCIsIm9yaWdpbmFsUHJvbWlzZVJlamVjdCIsInJlamVjdCIsIm5ld1Byb21pc2UiLCJleGVjdXRvciIsInByb21pc2VSZXNvbHZlZFdpdGgiLCJ2YWx1ZSIsInByb21pc2VSZWplY3RlZFdpdGgiLCJyZWFzb24iLCJQZXJmb3JtUHJvbWlzZVRoZW4iLCJwcm9taXNlIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiY2FsbCIsInVwb25Qcm9taXNlIiwidXBvbkZ1bGZpbGxtZW50IiwidXBvblJlamVjdGlvbiIsInRyYW5zZm9ybVByb21pc2VXaXRoIiwiZnVsZmlsbG1lbnRIYW5kbGVyIiwicmVqZWN0aW9uSGFuZGxlciIsInNldFByb21pc2VJc0hhbmRsZWRUb1RydWUiLCJxdWV1ZU1pY3JvdGFzayIsImdsb2JhbFF1ZXVlTWljcm90YXNrIiwicmVzb2x2ZWRQcm9taXNlIiwiZm4iLCJyZWZsZWN0Q2FsbCIsIkYiLCJWIiwiYXJncyIsIkZ1bmN0aW9uIiwiYXBwbHkiLCJwcm9taXNlQ2FsbCIsIlFVRVVFX01BWF9BUlJBWV9TSVpFIiwiU2ltcGxlUXVldWUiLCJjb25zdHJ1Y3RvciIsIl9jdXJzb3IiLCJfc2l6ZSIsIl9mcm9udCIsIl9lbGVtZW50cyIsIl9uZXh0IiwiX2JhY2siLCJwdXNoIiwiZWxlbWVudCIsIm9sZEJhY2siLCJuZXdCYWNrIiwic2hpZnQiLCJvbGRGcm9udCIsIm5ld0Zyb250Iiwib2xkQ3Vyc29yIiwibmV3Q3Vyc29yIiwiZWxlbWVudHMiLCJmb3JFYWNoIiwiY2FsbGJhY2siLCJub2RlIiwicGVlayIsImZyb250IiwiY3Vyc29yIiwiUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSIsInJlYWRlciIsInN0cmVhbSIsIl9vd25lclJlYWRhYmxlU3RyZWFtIiwiX3JlYWRlciIsIl9zdGF0ZSIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkIiwiX3N0b3JlZEVycm9yIiwiUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsIiwiUmVhZGFibGVTdHJlYW1DYW5jZWwiLCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCIsInJlYWRlckxvY2tFeGNlcHRpb24iLCJuYW1lIiwiX2Nsb3NlZFByb21pc2UiLCJfY2xvc2VkUHJvbWlzZV9yZXNvbHZlIiwiX2Nsb3NlZFByb21pc2VfcmVqZWN0IiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlIiwiQWJvcnRTdGVwcyIsIkVycm9yU3RlcHMiLCJDYW5jZWxTdGVwcyIsIlB1bGxTdGVwcyIsIk51bWJlcklzRmluaXRlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJNYXRoVHJ1bmMiLCJNYXRoIiwidHJ1bmMiLCJ2IiwiY2VpbCIsImZsb29yIiwiaXNEaWN0aW9uYXJ5IiwiYXNzZXJ0RGljdGlvbmFyeSIsIm9iaiIsImNvbnRleHQiLCJhc3NlcnRGdW5jdGlvbiIsImlzT2JqZWN0IiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCIsInBvc2l0aW9uIiwiYXNzZXJ0UmVxdWlyZWRGaWVsZCIsImZpZWxkIiwiY29udmVydFVucmVzdHJpY3RlZERvdWJsZSIsImNlbnNvck5lZ2F0aXZlWmVybyIsImludGVnZXJQYXJ0IiwiY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJNQVhfU0FGRV9JTlRFR0VSIiwiYXNzZXJ0UmVhZGFibGVTdHJlYW0iLCJJc1JlYWRhYmxlU3RyZWFtIiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3QiLCJyZWFkUmVxdWVzdCIsIl9yZWFkUmVxdWVzdHMiLCJSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdCIsImNodW5rIiwiZG9uZSIsIl9jbG9zZVN0ZXBzIiwiX2NodW5rU3RlcHMiLCJSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyIsIlJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlciIsIklzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwiSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCIsImNsb3NlZCIsImRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwiY2FuY2VsIiwicmVhZCIsInJlc29sdmVQcm9taXNlIiwicmVqZWN0UHJvbWlzZSIsIl9lcnJvclN0ZXBzIiwiZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQiLCJyZWxlYXNlTG9jayIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJlbnVtZXJhYmxlIiwidG9TdHJpbmdUYWciLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImhhc093blByb3BlcnR5IiwiX2Rpc3R1cmJlZCIsIl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIiLCJBc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsIiwicHJldmVudENhbmNlbCIsIl9vbmdvaW5nUHJvbWlzZSIsIl9pc0ZpbmlzaGVkIiwiX3ByZXZlbnRDYW5jZWwiLCJuZXh0IiwibmV4dFN0ZXBzIiwiX25leHRTdGVwcyIsInJldHVybiIsInJldHVyblN0ZXBzIiwiX3JldHVyblN0ZXBzIiwicmVzdWx0IiwiUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwiSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IiLCJzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbiIsIl9hc3luY0l0ZXJhdG9ySW1wbCIsInNldFByb3RvdHlwZU9mIiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciIsImltcGwiLCJjcmVhdGUiLCJfYSIsIk51bWJlcklzTmFOIiwiaXNOYU4iLCJDcmVhdGVBcnJheUZyb21MaXN0Iiwic2xpY2UiLCJDb3B5RGF0YUJsb2NrQnl0ZXMiLCJkZXN0IiwiZGVzdE9mZnNldCIsInNyYyIsInNyY09mZnNldCIsIm4iLCJVaW50OEFycmF5Iiwic2V0IiwiVHJhbnNmZXJBcnJheUJ1ZmZlciIsIk8iLCJJc0RldGFjaGVkQnVmZmVyIiwiQXJyYXlCdWZmZXJTbGljZSIsImJlZ2luIiwiZW5kIiwiQXJyYXlCdWZmZXIiLCJJc05vbk5lZ2F0aXZlTnVtYmVyIiwiQ2xvbmVBc1VpbnQ4QXJyYXkiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIkRlcXVldWVWYWx1ZSIsImNvbnRhaW5lciIsInBhaXIiLCJfcXVldWUiLCJfcXVldWVUb3RhbFNpemUiLCJzaXplIiwiRW5xdWV1ZVZhbHVlV2l0aFNpemUiLCJJbmZpbml0eSIsIlJhbmdlRXJyb3IiLCJQZWVrUXVldWVWYWx1ZSIsIlJlc2V0UXVldWUiLCJSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IiwidmlldyIsIklzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsImJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbiIsIl92aWV3IiwicmVzcG9uZCIsImJ5dGVzV3JpdHRlbiIsIl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kIiwicmVzcG9uZFdpdGhOZXdWaWV3IiwiaXNWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIiLCJieW9iUmVxdWVzdCIsIklzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsImJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdCIsImRlc2lyZWRTaXplIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplIiwiY2xvc2UiLCJfY2xvc2VSZXF1ZXN0ZWQiLCJzdGF0ZSIsIl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlIiwiZW5xdWV1ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlIiwiZXJyb3IiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zIiwiX2NhbmNlbEFsZ29yaXRobSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMiLCJlbnRyeSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluIiwiYXV0b0FsbG9jYXRlQ2h1bmtTaXplIiwiX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSIsImJ1ZmZlckUiLCJwdWxsSW50b0Rlc2NyaXB0b3IiLCJidWZmZXJCeXRlTGVuZ3RoIiwiYnl0ZXNGaWxsZWQiLCJlbGVtZW50U2l6ZSIsInZpZXdDb25zdHJ1Y3RvciIsInJlYWRlclR5cGUiLCJfcGVuZGluZ1B1bGxJbnRvcyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkIiwiY29udHJvbGxlciIsInNob3VsZFB1bGwiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwiLCJfcHVsbGluZyIsIl9wdWxsQWdhaW4iLCJwdWxsUHJvbWlzZSIsIl9wdWxsQWxnb3JpdGhtIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IiLCJmaWxsZWRWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IiLCJSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3QiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlIiwiY3VycmVudEFsaWduZWRCeXRlcyIsIm1heEJ5dGVzVG9Db3B5IiwibWluIiwibWF4Qnl0ZXNGaWxsZWQiLCJtYXhBbGlnbmVkQnl0ZXMiLCJ0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nIiwicmVhZHkiLCJxdWV1ZSIsImhlYWRPZlF1ZXVlIiwiYnl0ZXNUb0NvcHkiLCJkZXN0U3RhcnQiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IiLCJSZWFkYWJsZVN0cmVhbUNsb3NlIiwiX2J5b2JSZXF1ZXN0IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50byIsInJlYWRJbnRvUmVxdWVzdCIsIkRhdGFWaWV3IiwiQllURVNfUEVSX0VMRU1FTlQiLCJjdG9yIiwiUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3QiLCJlbXB0eVZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUiLCJmaXJzdERlc2NyaXB0b3IiLCJSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZSIsInJlbWFpbmRlclNpemUiLCJyZW1haW5kZXIiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsIiwiZGVzY3JpcHRvciIsIl9zdGFydGVkIiwiZmlyc3RQZW5kaW5nUHVsbEludG8iLCJ0cmFuc2ZlcnJlZEJ1ZmZlciIsInRyYW5zZmVycmVkVmlldyIsIlJlYWRhYmxlU3RyZWFtRXJyb3IiLCJTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QiLCJfc3RyYXRlZ3lIV00iLCJ2aWV3Qnl0ZUxlbmd0aCIsIlNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsInN0YXJ0QWxnb3JpdGhtIiwicHVsbEFsZ29yaXRobSIsImNhbmNlbEFsZ29yaXRobSIsImhpZ2hXYXRlck1hcmsiLCJzdGFydFJlc3VsdCIsInIiLCJTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSIsInVuZGVybHlpbmdCeXRlU291cmNlIiwic3RhcnQiLCJwdWxsIiwicmVxdWVzdCIsIkFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCJfcmVhZEludG9SZXF1ZXN0cyIsIklzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwiYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkIiwiRXh0cmFjdEhpZ2hXYXRlck1hcmsiLCJzdHJhdGVneSIsImRlZmF1bHRIV00iLCJFeHRyYWN0U2l6ZUFsZ29yaXRobSIsImNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kiLCJpbml0IiwiY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUiLCJjb252ZXJ0VW5kZXJseWluZ1NpbmsiLCJvcmlnaW5hbCIsImFib3J0Iiwid3JpdGUiLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrIiwiYXNzZXJ0V3JpdGFibGVTdHJlYW0iLCJJc1dyaXRhYmxlU3RyZWFtIiwiaXNBYm9ydFNpZ25hbCIsImFib3J0ZWQiLCJzdXBwb3J0c0Fib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImNyZWF0ZUFib3J0Q29udHJvbGxlciIsIldyaXRhYmxlU3RyZWFtIiwicmF3VW5kZXJseWluZ1NpbmsiLCJyYXdTdHJhdGVneSIsInVuZGVybHlpbmdTaW5rIiwiSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtIiwic2l6ZUFsZ29yaXRobSIsIlNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayIsImxvY2tlZCIsInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMiIsIklzV3JpdGFibGVTdHJlYW1Mb2NrZWQiLCJXcml0YWJsZVN0cmVhbUFib3J0IiwiV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQiLCJXcml0YWJsZVN0cmVhbUNsb3NlIiwiZ2V0V3JpdGVyIiwiQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsIkNyZWF0ZVdyaXRhYmxlU3RyZWFtIiwid3JpdGVBbGdvcml0aG0iLCJjbG9zZUFsZ29yaXRobSIsImFib3J0QWxnb3JpdGhtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIlNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIl93cml0ZXIiLCJfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyIiwiX3dyaXRlUmVxdWVzdHMiLCJfaW5GbGlnaHRXcml0ZVJlcXVlc3QiLCJfY2xvc2VSZXF1ZXN0IiwiX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0IiwiX3BlbmRpbmdBYm9ydFJlcXVlc3QiLCJfYmFja3ByZXNzdXJlIiwiX2Fib3J0UmVhc29uIiwiX2Fib3J0Q29udHJvbGxlciIsIl9wcm9taXNlIiwid2FzQWxyZWFkeUVycm9yaW5nIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwiX3JlYXNvbiIsIl93YXNBbHJlYWR5RXJyb3JpbmciLCJXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3JpbmciLCJjbG9zZVJlcXVlc3QiLCJ3cml0ZXIiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSIsIldyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0Iiwid3JpdGVSZXF1ZXN0IiwiV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbiIsIldyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3JpbmciLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCIsIldyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQiLCJzdG9yZWRFcnJvciIsIldyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQiLCJhYm9ydFJlcXVlc3QiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVXaXRoRXJyb3IiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2UiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3IiLCJXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodCIsIldyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCIsIldyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlIiwiYmFja3ByZXNzdXJlIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0IiwiX293bmVyV3JpdGFibGVTdHJlYW0iLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkIiwiSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIiLCJkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsImRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUiLCJfcmVhZHlQcm9taXNlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQiLCJfY2xvc2VkUHJvbWlzZVN0YXRlIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQiLCJfcmVhZHlQcm9taXNlU3RhdGUiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0IiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSIsInJlbGVhc2VkRXJyb3IiLCJjaHVua1NpemUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlIiwiY2xvc2VTZW50aW5lbCIsImFib3J0UmVhc29uIiwiSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIiLCJzaWduYWwiLCJfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwiX2Fib3J0QWxnb3JpdGhtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIl9zdHJhdGVneVNpemVBbGdvcml0aG0iLCJfd3JpdGVBbGdvcml0aG0iLCJfY2xvc2VBbGdvcml0aG0iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlIiwic3RhcnRQcm9taXNlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkIiwiY2h1bmtTaXplRSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkIiwiZW5xdWV1ZUUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZSIsInNpbmtDbG9zZVByb21pc2UiLCJzaW5rV3JpdGVQcm9taXNlIiwiX3JlYWR5UHJvbWlzZV9yZXNvbHZlIiwiX3JlYWR5UHJvbWlzZV9yZWplY3QiLCJOYXRpdmVET01FeGNlcHRpb24iLCJET01FeGNlcHRpb24iLCJpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yIiwiY3JlYXRlRE9NRXhjZXB0aW9uUG9seWZpbGwiLCJtZXNzYWdlIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIndyaXRhYmxlIiwiRE9NRXhjZXB0aW9uJDEiLCJSZWFkYWJsZVN0cmVhbVBpcGVUbyIsInNvdXJjZSIsInByZXZlbnRDbG9zZSIsInByZXZlbnRBYm9ydCIsInNodXR0aW5nRG93biIsImN1cnJlbnRXcml0ZSIsImFjdGlvbnMiLCJzaHV0ZG93bldpdGhBY3Rpb24iLCJhbGwiLCJtYXAiLCJhY3Rpb24iLCJhZGRFdmVudExpc3RlbmVyIiwicGlwZUxvb3AiLCJyZXNvbHZlTG9vcCIsInJlamVjdExvb3AiLCJwaXBlU3RlcCIsInJlc29sdmVSZWFkIiwicmVqZWN0UmVhZCIsImlzT3JCZWNvbWVzRXJyb3JlZCIsInNodXRkb3duIiwiaXNPckJlY29tZXNDbG9zZWQiLCJkZXN0Q2xvc2VkIiwid2FpdEZvcldyaXRlc1RvRmluaXNoIiwib2xkQ3VycmVudFdyaXRlIiwib3JpZ2luYWxJc0Vycm9yIiwib3JpZ2luYWxFcnJvciIsImRvVGhlUmVzdCIsImZpbmFsaXplIiwibmV3RXJyb3IiLCJpc0Vycm9yIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0iLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUiLCJTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSIsInVuZGVybHlpbmdTb3VyY2UiLCJSZWFkYWJsZVN0cmVhbVRlZSIsImNsb25lRm9yQnJhbmNoMiIsIlJlYWRhYmxlQnl0ZVN0cmVhbVRlZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZSIsInJlYWRpbmciLCJyZWFkQWdhaW4iLCJjYW5jZWxlZDEiLCJjYW5jZWxlZDIiLCJyZWFzb24xIiwicmVhc29uMiIsImJyYW5jaDEiLCJicmFuY2gyIiwicmVzb2x2ZUNhbmNlbFByb21pc2UiLCJjYW5jZWxQcm9taXNlIiwiY2h1bmsxIiwiY2h1bmsyIiwiY2FuY2VsMUFsZ29yaXRobSIsImNvbXBvc2l0ZVJlYXNvbiIsImNhbmNlbFJlc3VsdCIsImNhbmNlbDJBbGdvcml0aG0iLCJDcmVhdGVSZWFkYWJsZVN0cmVhbSIsInJlYWRBZ2FpbkZvckJyYW5jaDEiLCJyZWFkQWdhaW5Gb3JCcmFuY2gyIiwiZm9yd2FyZFJlYWRlckVycm9yIiwidGhpc1JlYWRlciIsInB1bGxXaXRoRGVmYXVsdFJlYWRlciIsImNsb25lRSIsInB1bGwxQWxnb3JpdGhtIiwicHVsbDJBbGdvcml0aG0iLCJwdWxsV2l0aEJZT0JSZWFkZXIiLCJmb3JCcmFuY2gyIiwiYnlvYkJyYW5jaCIsIm90aGVyQnJhbmNoIiwiYnlvYkNhbmNlbGVkIiwib3RoZXJDYW5jZWxlZCIsImNsb25lZENodW5rIiwiQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtIiwiY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlIiwiY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrIiwiY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSIsImNvbnZlcnRSZWFkZXJPcHRpb25zIiwib3B0aW9ucyIsIm1vZGUiLCJjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlIiwiY29udmVydEl0ZXJhdG9yT3B0aW9ucyIsIkJvb2xlYW4iLCJjb252ZXJ0UGlwZU9wdGlvbnMiLCJhc3NlcnRBYm9ydFNpZ25hbCIsImNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpciIsInJlYWRhYmxlIiwiUmVhZGFibGVTdHJlYW0iLCJyYXdVbmRlcmx5aW5nU291cmNlIiwiSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtIiwic3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxIiwiZ2V0UmVhZGVyIiwicmF3T3B0aW9ucyIsInBpcGVUaHJvdWdoIiwicmF3VHJhbnNmb3JtIiwidHJhbnNmb3JtIiwicGlwZVRvIiwiZGVzdGluYXRpb24iLCJ0ZWUiLCJicmFuY2hlcyIsInZhbHVlcyIsImFzeW5jSXRlcmF0b3IiLCJzb3VyY2VDYW5jZWxQcm9taXNlIiwiY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQiLCJieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uIiwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSIsIl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayIsIklzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSIsImJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uIiwiY291bnRTaXplRnVuY3Rpb24iLCJDb3VudFF1ZXVpbmdTdHJhdGVneSIsIl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsiLCJJc0NvdW50UXVldWluZ1N0cmF0ZWd5IiwiY291bnRCcmFuZENoZWNrRXhjZXB0aW9uIiwiY29udmVydFRyYW5zZm9ybWVyIiwiZmx1c2giLCJyZWFkYWJsZVR5cGUiLCJ3cml0YWJsZVR5cGUiLCJjb252ZXJ0VHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrIiwiY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayIsImNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrIiwiVHJhbnNmb3JtU3RyZWFtIiwicmF3VHJhbnNmb3JtZXIiLCJyYXdXcml0YWJsZVN0cmF0ZWd5IiwicmF3UmVhZGFibGVTdHJhdGVneSIsIndyaXRhYmxlU3RyYXRlZ3kiLCJyZWFkYWJsZVN0cmF0ZWd5IiwidHJhbnNmb3JtZXIiLCJyZWFkYWJsZUhpZ2hXYXRlck1hcmsiLCJyZWFkYWJsZVNpemVBbGdvcml0aG0iLCJ3cml0YWJsZUhpZ2hXYXRlck1hcmsiLCJ3cml0YWJsZVNpemVBbGdvcml0aG0iLCJzdGFydFByb21pc2VfcmVzb2x2ZSIsIkluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0iLCJTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVRyYW5zZm9ybWVyIiwiX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIiLCJJc1RyYW5zZm9ybVN0cmVhbSIsInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24iLCJfcmVhZGFibGUiLCJfd3JpdGFibGUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUiLCJfYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSIsIl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUiLCJUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUiLCJUcmFuc2Zvcm1TdHJlYW1FcnJvciIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwicmVhZGFibGVDb250cm9sbGVyIiwiX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwidGVybWluYXRlIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUiLCJTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwidHJhbnNmb3JtQWxnb3JpdGhtIiwiZmx1c2hBbGdvcml0aG0iLCJfdHJhbnNmb3JtQWxnb3JpdGhtIiwiX2ZsdXNoQWxnb3JpdGhtIiwidHJhbnNmb3JtUmVzdWx0RSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybSIsInRyYW5zZm9ybVByb21pc2UiLCJiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlIiwiZmx1c2hQcm9taXNlIiwiUE9PTF9TSVpFJDEiLCJwcm9jZXNzIiwiZW1pdFdhcm5pbmciLCJhc3NpZ24iLCJCbG9iIiwicGFyYW1zIiwiYmxvYiIsImN0cmwiLCJhcnJheUJ1ZmZlciIsIlBPT0xfU0laRSIsInRvSXRlcmF0b3IiLCJwYXJ0cyIsImNsb25lIiwicGFydCIsImIiLCJfQmxvYiIsImVuZGluZ3MiLCJibG9iUGFydHMiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJTdHJpbmciLCJ0ZXh0IiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwic3RyIiwiZGVjb2RlIiwib2Zmc2V0IiwiaXQiLCJyZWxhdGl2ZVN0YXJ0IiwibWF4IiwicmVsYXRpdmVFbmQiLCJzcGFuIiwiYWRkZWQiLCJzdWJhcnJheSIsInRvTG93ZXJDYXNlIiwiaGFzSW5zdGFuY2UiLCJvYmplY3QiLCJfQmxvYiQxIiwiX0ZpbGUiLCJGaWxlIiwibGFzdE1vZGlmaWVkIiwiZmlsZUJpdHMiLCJmaWxlTmFtZSIsImFyZ3VtZW50cyIsIkRhdGUiLCJub3ciLCJGaWxlJDEiLCJ0IiwiaCIsInJhbmRvbSIsIm0iLCJmIiwiYSIsImMiLCJGb3JtRGF0YSIsImQiLCJlbnRyaWVzIiwibyIsInNvbWUiLCJhcHBlbmQiLCJkZWxldGUiLCJmaWx0ZXIiLCJnZXQiLCJsIiwiZ2V0QWxsIiwiaGFzIiwia2V5cyIsImZvcm1EYXRhVG9CbG9iIiwiQiIsInBhZFN0YXJ0IiwicCIsIkZldGNoQmFzZUVycm9yIiwiRmV0Y2hFcnJvciIsInN5c3RlbUVycm9yIiwiY29kZSIsImVycm5vIiwiZXJyb3JlZFN5c0NhbGwiLCJzeXNjYWxsIiwiTkFNRSIsImlzVVJMU2VhcmNoUGFyYW1ldGVycyIsInNvcnQiLCJpc0Jsb2IiLCJpc0RvbWFpbk9yU3ViZG9tYWluIiwib3JpZyIsIlVSTCIsImhvc3RuYW1lIiwiZW5kc1dpdGgiLCJpc1NhbWVQcm90b2NvbCIsInByb3RvY29sIiwicGlwZWxpbmUiLCJwcm9taXNpZnkiLCJJTlRFUk5BTFMkMiIsIkJvZHkiLCJib2R5IiwiYm91bmRhcnkiLCJ0b1N0cmluZyIsImlzQnVmZmVyIiwidHlwZXMiLCJpc0FueUFycmF5QnVmZmVyIiwiUmVhZGFibGUiLCJkaXN0dXJiZWQiLCJvbiIsImVycm9yXyIsInVybCIsImJvZHlVc2VkIiwiY29uc3VtZUJvZHkiLCJmb3JtRGF0YSIsImN0IiwiaGVhZGVycyIsInN0YXJ0c1dpdGgiLCJwYXJhbWV0ZXJzIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9Gb3JtRGF0YSIsImJ1ZiIsImpzb24iLCJKU09OIiwicGFyc2UiLCJkZXByZWNhdGUiLCJhbGxvYyIsImFjY3VtIiwiYWNjdW1CeXRlcyIsImRlc3Ryb3kiLCJyZWFkYWJsZUVuZGVkIiwiX3JlYWRhYmxlU3RhdGUiLCJlbmRlZCIsImV2ZXJ5Iiwiam9pbiIsImNvbmNhdCIsImluc3RhbmNlIiwicDEiLCJwMiIsImdldEJvdW5kYXJ5IiwiUGFzc1Rocm91Z2giLCJwaXBlIiwiZ2V0Tm9uU3BlY0Zvcm1EYXRhQm91bmRhcnkiLCJleHRyYWN0Q29udGVudFR5cGUiLCJnZXRUb3RhbEJ5dGVzIiwiZ2V0TGVuZ3RoU3luYyIsImhhc0tub3duTGVuZ3RoIiwid3JpdGVUb1N0cmVhbSIsInZhbGlkYXRlSGVhZGVyTmFtZSIsInZhbGlkYXRlSGVhZGVyVmFsdWUiLCJIZWFkZXJzIiwicmF3IiwiaXNCb3hlZFByaW1pdGl2ZSIsIm1ldGhvZCIsIlByb3h5IiwidGFyZ2V0IiwicmVjZWl2ZXIiLCJTZXQiLCJSZWZsZWN0IiwidGhpc0FyZyIsInJlZHVjZSIsImtleSIsImZvciIsInByb3BlcnR5IiwiZnJvbVJhd0hlYWRlcnMiLCJpbmRleCIsImFycmF5IiwicmVkaXJlY3RTdGF0dXMiLCJpc1JlZGlyZWN0IiwiSU5URVJOQUxTJDEiLCJSZXNwb25zZSIsInN0YXR1cyIsImNvbnRlbnRUeXBlIiwic3RhdHVzVGV4dCIsImNvdW50ZXIiLCJvayIsInJlZGlyZWN0ZWQiLCJyZWRpcmVjdCIsImxvY2F0aW9uIiwicmVzcG9uc2UiLCJzdHJpbmdpZnkiLCJnZXRTZWFyY2giLCJwYXJzZWRVUkwiLCJzZWFyY2giLCJsYXN0T2Zmc2V0IiwiaHJlZiIsImhhc2giLCJzdHJpcFVSTEZvclVzZUFzQVJlZmVycmVyIiwib3JpZ2luT25seSIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJwYXRobmFtZSIsIlJlZmVycmVyUG9saWN5IiwiREVGQVVMVF9SRUZFUlJFUl9QT0xJQ1kiLCJ2YWxpZGF0ZVJlZmVycmVyUG9saWN5IiwicmVmZXJyZXJQb2xpY3kiLCJpc09yaWdpblBvdGVudGlhbGx5VHJ1c3R3b3J0aHkiLCJob3N0SXAiLCJob3N0IiwiaG9zdElQVmVyc2lvbiIsImlzSVAiLCJpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkiLCJkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIiwicmVmZXJyZXJVUkxDYWxsYmFjayIsInJlZmVycmVyT3JpZ2luQ2FsbGJhY2siLCJyZWZlcnJlciIsInBvbGljeSIsInJlZmVycmVyU291cmNlIiwicmVmZXJyZXJVUkwiLCJyZWZlcnJlck9yaWdpbiIsImN1cnJlbnRVUkwiLCJvcmlnaW4iLCJwYXJzZVJlZmVycmVyUG9saWN5RnJvbUhlYWRlciIsInBvbGljeVRva2VucyIsInRva2VuIiwiSU5URVJOQUxTIiwiaXNSZXF1ZXN0IiwiZG9CYWREYXRhV2FybiIsIlJlcXVlc3QiLCJpbnB1dCIsInRvVXBwZXJDYXNlIiwiaW5wdXRCb2R5IiwicGFyc2VkUmVmZXJyZXIiLCJmb2xsb3ciLCJjb21wcmVzcyIsImFnZW50IiwiaW5zZWN1cmVIVFRQUGFyc2VyIiwiZm9ybWF0IiwiZ2V0Tm9kZVJlcXVlc3RPcHRpb25zIiwiY29udGVudExlbmd0aFZhbHVlIiwidG90YWxCeXRlcyIsInBhdGgiLCJBYm9ydEVycm9yIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0IiwicG9ydDEiLCJhYiIsInBvc3RNZXNzYWdlIiwiZXJyIiwibm9kZURvbWV4Y2VwdGlvbiIsInN1cHBvcnRlZFNjaGVtYXMiLCJmZXRjaCIsIm9wdGlvbnNfIiwic2VuZCIsImVtaXQiLCJhYm9ydEFuZEZpbmFsaXplIiwicmVxdWVzdF8iLCJmaXhSZXNwb25zZUNodW5rZWRUcmFuc2ZlckJhZEVuZGluZyIsInZlcnNpb24iLCJzIiwiZW5kZWRXaXRoRXZlbnRzQ291bnQiLCJwcmVwZW5kTGlzdGVuZXIiLCJfZXZlbnRzQ291bnQiLCJoYWRFcnJvciIsInJlc3BvbnNlXyIsInNldFRpbWVvdXQiLCJyYXdIZWFkZXJzIiwic3RhdHVzQ29kZSIsImxvY2F0aW9uVVJMIiwicmVxdWVzdE9wdGlvbnMiLCJyZXNwb25zZVJlZmVycmVyUG9saWN5Iiwib25jZSIsInJlc3BvbnNlT3B0aW9ucyIsInN0YXR1c01lc3NhZ2UiLCJjb2RpbmdzIiwiemxpYk9wdGlvbnMiLCJaX1NZTkNfRkxVU0giLCJmaW5pc2hGbHVzaCIsImNyZWF0ZUd1bnppcCIsImNyZWF0ZUluZmxhdGUiLCJjcmVhdGVJbmZsYXRlUmF3IiwiY3JlYXRlQnJvdGxpRGVjb21wcmVzcyIsImNhdGNoIiwiZXJyb3JDYWxsYmFjayIsIkxBU1RfQ0hVTksiLCJpc0NodW5rZWRUcmFuc2ZlciIsInByb3Blckxhc3RDaHVua1JlY2VpdmVkIiwicHJldmlvdXNDaHVuayIsInNvY2tldCIsIm9uU29ja2V0Q2xvc2UiLCJvbkRhdGEiLCJjb21wYXJlIiwicmVtb3ZlTGlzdGVuZXIiLCJwcml2YXRlRGF0YSIsIldlYWtNYXAiLCJ3cmFwcGVycyIsInBkIiwiZXZlbnQiLCJyZXR2IiwiY29uc29sZSIsImFzc2VydCIsInNldENhbmNlbEZsYWciLCJwYXNzaXZlTGlzdGVuZXIiLCJjYW5jZWxhYmxlIiwiY2FuY2VsZWQiLCJwcmV2ZW50RGVmYXVsdCIsIkV2ZW50IiwiZXZlbnRUYXJnZXQiLCJldmVudFBoYXNlIiwiY3VycmVudFRhcmdldCIsInN0b3BwZWQiLCJpbW1lZGlhdGVTdG9wcGVkIiwidGltZVN0YW1wIiwiZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yIiwiY29tcG9zZWRQYXRoIiwiTk9ORSIsIkNBUFRVUklOR19QSEFTRSIsIkFUX1RBUkdFVCIsIkJVQkJMSU5HX1BIQVNFIiwic3RvcFByb3BhZ2F0aW9uIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiYnViYmxlcyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjb21wb3NlZCIsInNyY0VsZW1lbnQiLCJjYW5jZWxCdWJibGUiLCJyZXR1cm5WYWx1ZSIsImluaXRFdmVudCIsImRlZmluZUNhbGxEZXNjcmlwdG9yIiwiZGVmaW5lV3JhcHBlciIsIkJhc2VFdmVudCIsInByb3RvIiwiQ3VzdG9tRXZlbnQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc0Z1bmMiLCJnZXRXcmFwcGVyIiwid3JhcHBlciIsIndyYXBFdmVudCIsIldyYXBwZXIiLCJpc1N0b3BwZWQiLCJzZXRFdmVudFBoYXNlIiwic2V0Q3VycmVudFRhcmdldCIsInNldFBhc3NpdmVMaXN0ZW5lciIsImxpc3RlbmVyc01hcCIsIkNBUFRVUkUiLCJCVUJCTEUiLCJBVFRSSUJVVEUiLCJnZXRMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IiLCJldmVudE5hbWUiLCJsaXN0ZW5lclR5cGUiLCJsaXN0ZW5lciIsInByZXYiLCJuZXdOb2RlIiwicGFzc2l2ZSIsImRlZmluZUV2ZW50QXR0cmlidXRlIiwiZXZlbnRUYXJnZXRQcm90b3R5cGUiLCJkZWZpbmVDdXN0b21FdmVudFRhcmdldCIsImV2ZW50TmFtZXMiLCJDdXN0b21FdmVudFRhcmdldCIsIkV2ZW50VGFyZ2V0IiwiTWFwIiwiQXJyYXkiLCJpc0FycmF5Iiwib3B0aW9uc0lzT2JqIiwiY2FwdHVyZSIsImRpc3BhdGNoRXZlbnQiLCJ3cmFwcGVkRXZlbnQiLCJoYW5kbGVFdmVudCIsIkFib3J0U2lnbmFsIiwiYWJvcnRlZEZsYWdzIiwiY3JlYXRlQWJvcnRTaWduYWwiLCJhYm9ydFNpZ25hbCIsIkFib3J0Q29udHJvbGxlciQxIiwic2lnbmFscyIsImdldFNpZ25hbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-fetch-native/lib/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/node-fetch-native/lib/index.cjs ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst nodeFetch = __webpack_require__(/*! ../dist/index.cjs */ \"(rsc)/./node_modules/node-fetch-native/dist/index.cjs\");\nfunction fetch(input, options) {\n    return nodeFetch.fetch(input, options);\n}\nfor(const key in nodeFetch){\n    fetch[key] = nodeFetch[key];\n}\nmodule.exports = fetch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvbGliL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsWUFBWUMsbUJBQU9BLENBQUMsZ0ZBQW1CO0FBRTdDLFNBQVNDLE1BQU9DLEtBQUssRUFBRUMsT0FBTztJQUM1QixPQUFPSixVQUFVRSxLQUFLLENBQUNDLE9BQU9DO0FBQ2hDO0FBRUEsSUFBSyxNQUFNQyxPQUFPTCxVQUFXO0lBQzNCRSxLQUFLLENBQUNHLElBQUksR0FBR0wsU0FBUyxDQUFDSyxJQUFJO0FBQzdCO0FBRUFDLE9BQU9DLE9BQU8sR0FBR0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZXJucHJvamVjdC8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoLW5hdGl2ZS9saWIvaW5kZXguY2pzPzA3NGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgbm9kZUZldGNoID0gcmVxdWlyZShcIi4uL2Rpc3QvaW5kZXguY2pzXCIpO1xuXG5mdW5jdGlvbiBmZXRjaCAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5vZGVGZXRjaC5mZXRjaChpbnB1dCwgb3B0aW9ucyk7XG59XG5cbmZvciAoY29uc3Qga2V5IGluIG5vZGVGZXRjaCkge1xuICBmZXRjaFtrZXldID0gbm9kZUZldGNoW2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmV0Y2g7XG4iXSwibmFtZXMiOlsibm9kZUZldGNoIiwicmVxdWlyZSIsImZldGNoIiwiaW5wdXQiLCJvcHRpb25zIiwia2V5IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch-native/lib/index.cjs\n");

/***/ })

};
;